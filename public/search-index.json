[
  {
    "objectID": "/releases/5.1.0/#0",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "Welcome to this new release of Mockoon. It brings exciting features like a new command palette and the migration to Faker.js v8. We also fixed some bugs in the desktop application and CLI. Read on to learn more about this release.",
    "link": "/releases/5.1.0/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 8,
    "groupScore": 0
  },
  {
    "objectID": "/releases/5.1.0/#our-sponsors",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "NOSTYLE GitHub Localazy Peakcrypto Fern  Mockoon is an open-source project built by volunteer maintainers. If you like our application, please consider sponsoring us and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/releases/5.1.0/",
    "sectionTitle": "Our sponsors",
    "sectionAnchor": "our-sponsors",
    "score": 8,
    "groupScore": 1
  },
  {
    "objectID": "/releases/5.1.0/#new-command-palette",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "We added a new command palette in the desktop application to quickly access all the application's features. You can open it by pressing Ctrl+P (Windows/Linux) or Cmd+P (MacOS). You can also access it by clicking on the icon in the header (see capture below).  It currently supports most common actions like creating new environments, starting/stopping them, opening the settings, etc. You can also search for any environment, route, or data bucket by typing their name or path. We will add more actions in the future. Let us know what you think, and do not hesitate to suggest new actions on our Discord server or GitHub discussions.  Command palette showing a search for the word create",
    "link": "/releases/5.1.0/",
    "sectionTitle": "New command palette",
    "sectionAnchor": "new-command-palette",
    "score": 8,
    "groupScore": 2
  },
  {
    "objectID": "/releases/5.1.0/#fakerjs-v8-migration-Ô∏è-potentially-breaking",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "Mockoon now uses Faker.js v8. This update packs a lot of changes regarding the helper names. Some were removed, and many were renamed. For example, name.firstName moved to person.firstName. Some new locales were also added, like Danish. Be sure to check their migration guide to learn more.  This new version (both desktop and CLI) will automatically update your environment's inline bodies and data buckets content. However, it won't migrate external files (JSON, CSV, etc.) containing templating helpers, and you will have to do it manually.  All the documentation and mock samples were updated to reflect these changes and avoid any confusion with old helpers names.  (Issue #1150)",
    "link": "/releases/5.1.0/",
    "sectionTitle": "Faker.js v8 migration (‚ö†Ô∏è potentially breaking)",
    "sectionAnchor": "fakerjs-v8-migration-Ô∏è-potentially-breaking",
    "score": 8,
    "groupScore": 3
  },
  {
    "objectID": "/releases/5.1.0/#range-header-support",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "Mockoon now supports the Range header. This header is used to request only a part of a resource, like a binary file, to allow the download in chunks. You can now use it in your routes to simulate this behavior.  Head over to the documentation to learn more about this header.  (Issue #1044)",
    "link": "/releases/5.1.0/",
    "sectionTitle": "Range header support",
    "sectionAnchor": "range-header-support",
    "score": 8,
    "groupScore": 4
  },
  {
    "objectID": "/releases/5.1.0/#desktop-application",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "We fixed a bug occurring at startup when the application was maximized causing the environments and routes menus sizes to not be correctly restored from the settings and often reduced in size. We also fixed a rare bug caused by the same resizing feature that could propagate an erroneous state of the settings and result in an empty UI at startup. (Issue #1167) We fixed a bug where the data bucket dropdowns would overflow the screen when displaying long names. The log in modal is now automatically closed when the authentication happens through the custom protocol. (Issue #1158)",
    "link": "/releases/5.1.0/",
    "sectionTitle": "Desktop application",
    "sectionAnchor": "desktop-application",
    "score": 8,
    "groupScore": 5
  },
  {
    "objectID": "/releases/5.1.0/#cli",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "We improved the error reporting during OpenAPI/data file parsing. (Issue #1161)",
    "link": "/releases/5.1.0/",
    "sectionTitle": "CLI",
    "sectionAnchor": "cli",
    "score": 8,
    "groupScore": 6
  },
  {
    "objectID": "/releases/5.1.0/#thank-you",
    "title": "Mockoon release v5.1.0",
    "category": "releases",
    "content": "A big thank you to the following people that helped to make Mockoon better:  @ajatkj: Faker.js v8 migration. (Issue #1150) @PineappleIOnic: Range header support. (Issue #1044)",
    "link": "/releases/5.1.0/",
    "sectionTitle": "Thank you",
    "sectionAnchor": "thank-you",
    "score": 8,
    "groupScore": 7
  },
  {
    "objectID": "/releases/5.0.0/#0",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "Welcome to this new major release of Mockoon. It brings a lot of new features and improvements.",
    "link": "/releases/5.0.0/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 8,
    "groupScore": 0
  },
  {
    "objectID": "/releases/5.0.0/#our-platinum-sponsors",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "GitHub Localazy Peakcrypto  Mockoon is an open-source project built by volunteer maintainers. If you like our application, please consider sponsoring us and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Our platinum sponsors",
    "sectionAnchor": "our-platinum-sponsors",
    "score": 8,
    "groupScore": 1
  },
  {
    "objectID": "/releases/5.0.0/#Ô∏è-breaking-changes",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "We introduced two breaking changes in this major release:  We dropped support for Node.js v16. The CLI and the serverless package now require at least Node.js 18. Support was dropped for legacy data files in both Desktop and CLI. If you are updating from v1.15.0, please first update to any version between v1.16.0 and v4.1.0, then to v5.0.0.",
    "link": "/releases/5.0.0/",
    "sectionTitle": "‚ö†Ô∏è Breaking changes",
    "sectionAnchor": "Ô∏è-breaking-changes",
    "score": 8,
    "groupScore": 2
  },
  {
    "objectID": "/releases/5.0.0/#jsonpath-support",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "Mockoon now supports JSONPath alongside object-path everywhere a path to an object property can be provided:  in templating helpers like data, dataRaw, body, bodyRaw, queryParam and queryParamRaw. in the response rules path.  We are using the JSONPath Plus library. Please refer to its documentation to learn more about the syntax. The simpler object-path syntax is still supported.  (Issue #995)",
    "link": "/releases/5.0.0/",
    "sectionTitle": "JSONPath support",
    "sectionAnchor": "jsonpath-support",
    "score": 8,
    "groupScore": 3
  },
  {
    "objectID": "/releases/5.0.0/#routes-targeting-all-http-methods",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "It is now possible to create routes that will match any HTTP method. You can now select \"All methods\" in the routes method dropdown:  wildcard route on all methods",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Routes targeting all HTTP methods",
    "sectionAnchor": "routes-targeting-all-http-methods",
    "score": 8,
    "groupScore": 4
  },
  {
    "objectID": "/releases/5.0.0/#global-routes-with-rules",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "Thanks to the response fallback mode introduced in v4.1.0, it was already possible to create wildcard routes containing \"global\" rules, like validating the presence of an Authorization header, or verifying that the request body contains a specific property. The only missing piece was the ability to create a global route that would match any HTTP method, which is now possible with the new feature above.  Head over to our new \"Global routes with rules\" documentation section to learn how to create reusable responses and rules and apply them to all your routes.  We also updated the desktop application's demo environment to showcase this new feature.  (Issue #221)",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Global routes with rules",
    "sectionAnchor": "global-routes-with-rules",
    "score": 8,
    "groupScore": 5
  },
  {
    "objectID": "/releases/5.0.0/#desktop-application",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "Breaking change: Support was dropped for legacy data files (pre v1.16.0). The desktop application will no longer automatically migrate your environments from the old system. If you are updating from v1.15.0, please first update to any version between v1.16.0 and v4.1.0, then to v5.0.0. (Issue #1138)   We added a link in the footer update notification to let you easily check the new version's changelog (will be visible for updates >v5.0.0):  footer update notification",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Desktop application",
    "sectionAnchor": "desktop-application",
    "score": 8,
    "groupScore": 6
  },
  {
    "objectID": "/releases/5.0.0/#cli",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "Breaking change: We dropped support for Node.js v16. The CLI now requires Node.js 18 at least. (Issue #1119) Breaking change: Support was dropped for opening legacy data files (pre v1.16.0). (Issue #1138) The Docker image is now tagged with its major version. Starting with version 5, all v5.x.x will be tagged 5 and so on. (Issue #1132)",
    "link": "/releases/5.0.0/",
    "sectionTitle": "CLI",
    "sectionAnchor": "cli",
    "score": 8,
    "groupScore": 7
  },
  {
    "objectID": "/releases/5.0.0/#serverless-package",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "Breaking change: We dropped support for Node.js v16. The package is now requiring Node.js 18 at least. (Issue #1119)",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Serverless package",
    "sectionAnchor": "serverless-package",
    "score": 8,
    "groupScore": 8
  },
  {
    "objectID": "/releases/5.0.0/#chores",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "We updated most of the application dependencies to their latest version in order to fix recent security vulnerabilities.",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Chores",
    "sectionAnchor": "chores",
    "score": 8,
    "groupScore": 9
  },
  {
    "objectID": "/releases/5.0.0/#thank-you",
    "title": "Mockoon release v5.0.0",
    "category": "releases",
    "content": "A big thank you to the following people that helped to make Mockoon better:  @ajatkj: JSONPath support. (Issue #995)",
    "link": "/releases/5.0.0/",
    "sectionTitle": "Thank you",
    "sectionAnchor": "thank-you",
    "score": 8,
    "groupScore": 10
  },
  {
    "objectID": "/releases/4.1.0/#0",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "Welcome to this new release of Mockoon. There are several bug fixes and new features in this version that we hope you will like.",
    "link": "/releases/4.1.0/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 8,
    "groupScore": 0
  },
  {
    "objectID": "/releases/4.1.0/#our-platinum-sponsors",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "GitHub Localazy Peakcrypto  Mockoon is an open-source project built by volunteer maintainers. If you like our application, please consider sponsoring us and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/releases/4.1.0/",
    "sectionTitle": "Our platinum sponsors",
    "sectionAnchor": "our-platinum-sponsors",
    "score": 8,
    "groupScore": 1
  },
  {
    "objectID": "/releases/4.1.0/#new-response-fallback-mode",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "A new response mode has been added. It allows you to fallback to the next route and ultimately the proxied server when no response rules match instead of serving the default response. Visit the documentation to learn more. (Issues #363)  enable fallback mode",
    "link": "/releases/4.1.0/",
    "sectionTitle": "New response fallback mode",
    "sectionAnchor": "new-response-fallback-mode",
    "score": 8,
    "groupScore": 2
  },
  {
    "objectID": "/releases/4.1.0/#dynamic-rules-with-templating",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "The templating helpers are now supported in the rule values letting you create dynamic rules. (Issue #988)  screenshot showing a response rule with a template helper in the value field",
    "link": "/releases/4.1.0/",
    "sectionTitle": "Dynamic rules with templating",
    "sectionAnchor": "dynamic-rules-with-templating",
    "score": 8,
    "groupScore": 3
  },
  {
    "objectID": "/releases/4.1.0/#changes-to-templating-helpers",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "Two new templating helpers have been added to allow array filtering and object creation. (Issues #1103)   Properties with dots are now supported in the queryParam and queryParamRaw templating helpers. Escape the dots when you want to reach values contained in a property with dots. See the examples in our documentation. (Issue #1115)   The eq templating helper is now compatible with strings. (Issue #1114)",
    "link": "/releases/4.1.0/",
    "sectionTitle": "Changes to templating helpers",
    "sectionAnchor": "changes-to-templating-helpers",
    "score": 8,
    "groupScore": 4
  },
  {
    "objectID": "/releases/4.1.0/#other-changes",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "Templating helpers in Handlebars files with .hbs or .handlebars are now correctly parsed. (Issue #1120)",
    "link": "/releases/4.1.0/",
    "sectionTitle": "Other changes",
    "sectionAnchor": "other-changes",
    "score": 8,
    "groupScore": 5
  },
  {
    "objectID": "/releases/4.1.0/#thank-you",
    "title": "Mockoon release v4.1.0",
    "category": "releases",
    "content": "A big thank you to the following people that helped to make Mockoon better:  @ajatkj: Support for properties with dots in queryParam and queryParamRaw helpers. (Issue #1115) @edtoken: filter and object templating helpers and eq helper update. (Issues #1103 and #1114) @HarryEMartland: New response fallback mode. (Issue #363) @Jerantony: Templating helpers in rule value. (Issue #988)",
    "link": "/releases/4.1.0/",
    "sectionTitle": "Thank you",
    "sectionAnchor": "thank-you",
    "score": 8,
    "groupScore": 6
  },
  {
    "objectID": "/releases/4.0.0/#0",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "Welcome to this new major release of Mockoon. It brings a lot of new features and improvements. The main focus of this release was to standardize the log format across all Mockoon applications and packages. We also took the opportunity to refactor the CLI to remove the PM2 dependency and make it more lightweight. Finally, we added a few new features and fixed some bugs.",
    "link": "/releases/4.0.0/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 8,
    "groupScore": 0
  },
  {
    "objectID": "/releases/4.0.0/#our-platinum-sponsors",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "GitHub Localazy Peakcrypto  Mockoon is an open-source project built by volunteer maintainers. If you like our application, please consider sponsoring us and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/releases/4.0.0/",
    "sectionTitle": "Our platinum sponsors",
    "sectionAnchor": "our-platinum-sponsors",
    "score": 8,
    "groupScore": 1
  },
  {
    "objectID": "/releases/4.0.0/#Ô∏è-breaking-changes",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "We introduced two breaking changes in this major release:  The logs format changed to be standardized across all Mockoon applications and packages. See the logs standardization section below for more details. The CLI was refactored to remove the PM2 dependency and is now running as a foreground process by default. See the CLI section below for more details.",
    "link": "/releases/4.0.0/",
    "sectionTitle": "‚ö†Ô∏è Breaking changes",
    "sectionAnchor": "Ô∏è-breaking-changes",
    "score": 8,
    "groupScore": 2
  },
  {
    "objectID": "/releases/4.0.0/#logs-standardization-and-credentials-filtering",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "Logging has been standardized across all Mockoon applications and packages. This means that the logs will now be formatted the same way in the desktop application log file, the CLI's console and log file, and the serverless package's console logging. This will make it easier to read and parse the logs. As part of this change, we also added a new setting to enable full transaction logging to both the desktop application and the serverless package. It is the equivalent of the CLI's --log-transaction flag.  Some events' logging formats changed. If you are using the logs in your scripts, you need update them to match the new format. The new format is the following:  Server start event:  Before:  {   \"level\": \"info\",   \"message\": \"Server started on port 3000\",   \"timestamp\": \"YYYY-MM-DDTHH:mm:ss.sssZ\",   \"mockName\": \"mockoon-demo-api\" }   After:  {   \"level\": \"info\",   \"message\": \"Server started on port 3010\",   \"timestamp\": \"YYYY-MM-DDTHH:mm:ss.sssZ\",   \"app\": \"mockoon-server\",   \"environmentName\": \"mockoon-demo-api\",   \"environmentUUID\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\" }  Transaction:  Before:  {   \"level\": \"info\",   \"message\": \"GET /test | 200\",   \"timestamp\": \"YYYY-MM-DDTHH:mm:ss.sssZ\",   \"mockName\": \"mockoon-demo-api\",   \"transaction\": {...} }   After:  {   \"level\": \"info\",   \"message\": \"Transaction recorded\",   \"timestamp\": \"YYYY-MM-DDTHH:mm:ss.sssZ\",   \"app\": \"mockoon-server\",   \"environmentName\": \"mockoon-demo-api\",   \"environmentUUID\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",   \"requestMethod\": \"GET\",   \"requestPath\": \"/testheader\",   \"requestProxied\": false,   \"responseStatus\": 200,   \"transaction\": {...} }  (Issue #1063)  Finally, the new logging format automatically filters out credentials from the logs. It means that if you are using the --log-transaction flag or the full transaction logging settings, the authentication keys present in the Authorization or Proxy-Authorization headers are anonymized. (Issue #688)",
    "link": "/releases/4.0.0/",
    "sectionTitle": "Logs standardization and credentials filtering",
    "sectionAnchor": "logs-standardization-and-credentials-filtering",
    "score": 8,
    "groupScore": 3
  },
  {
    "objectID": "/releases/4.0.0/#desktop-application",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "The logs are now formatted the same way as the CLI and the serverless package (JSON). See logs standardization section above for more details. (Issue #1063)   A new setting is available to enable full transaction logging. (Issue #1063)  enable full transaction logging in the settings dialog  A new context menu item is available to move an environment's data file to a new location without having to close and reopen it. (Issue #1062)  move environment file to a new folder  The id property used to manipulate data in single resource routes (GET /res/:id, PUT /res/:id, etc.) in a CRUD endpoint can now be set to something else like \"uuid\", \"custom_id\", etc. (Issue #1041)  customize the crud id property   You can now search for routes in collapsed folders. (Issue #960)",
    "link": "/releases/4.0.0/",
    "sectionTitle": "Desktop application",
    "sectionAnchor": "desktop-application",
    "score": 8,
    "groupScore": 4
  },
  {
    "objectID": "/releases/4.0.0/#openapi",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "A bug was fixed where OpenAPI export was crashing due to an incompatibility with CRUD routes. (Issue #1066) When exporting to OpenAPI format, inline bodies are now used to populate the example property (Issue #352):  {   \"paths\": {     \"/test\": {       \"get\": {         \"responses\": {           \"200\": {             \"description\": \"\",             \"content\": {               \"application/json\": {                 \"example\": \"{\\\"response\\\": \\\"success\\\"}\"               }             }           }         }       }     }   } }",
    "link": "/releases/4.0.0/",
    "sectionTitle": "OpenAPI",
    "sectionAnchor": "openapi",
    "score": 8,
    "groupScore": 5
  },
  {
    "objectID": "/releases/4.0.0/#changes-to-templating-helpers",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "The data and dataRaw helpers are now compatible with values coming from other helpers like queryParam. (Issues #1069) We added a new boolean parameter to the oneOf helper to allow the user to stringify the result of the helper. (Issues #1074) The faker helper is now compatible with Faker.js methods containing a number (internet.ipv4 and internet.ipv6). (Issues #1078)",
    "link": "/releases/4.0.0/",
    "sectionTitle": "Changes to templating helpers",
    "sectionAnchor": "changes-to-templating-helpers",
    "score": 8,
    "groupScore": 6
  },
  {
    "objectID": "/releases/4.0.0/#cli",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "The logs format changed to match the desktop application and the serverless package. See logs standardization section above for more details. (Issue #1063)   We refactored the CLI to remove the dependency to PM2, which was subject to some security vulnerabilities. Another reason for this refactoring, was that, having multiple other ways to manage running CLI instances (i.e. containers), embedding a process manager felt a bit outdated and overkill. The CLI is now easier to maintain and more lightweight. As a consequence, the following changes were made:  The list and stop commands were removed together with the --pname flag which was used to customize PM2's process name. The --daemon-off flag was removed and running the CLI as a foreground process is now the default. To run the CLI in the background, you can use the & operator in your terminal: mockoon-cli start -d ./data-file.json &. The dockerize command was simplified and reduced to its core promise: it will now only generate the Dockerfile and copy (or download) the provided data files next to it. Head over to the CLI documentation for more details.  (Issue #1081)",
    "link": "/releases/4.0.0/",
    "sectionTitle": "CLI",
    "sectionAnchor": "cli",
    "score": 8,
    "groupScore": 7
  },
  {
    "objectID": "/releases/4.0.0/#serverless-package",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "The package now logs all events and transactions to stdout (console) in the same logging format used by the desktop application and the CLI. (Issues #1063 and #978) A new option is available to enable full transaction logging. (Issue #1063)",
    "link": "/releases/4.0.0/",
    "sectionTitle": "Serverless package",
    "sectionAnchor": "serverless-package",
    "score": 8,
    "groupScore": 8
  },
  {
    "objectID": "/releases/4.0.0/#thank-you",
    "title": "Mockoon release v4.0.0",
    "category": "releases",
    "content": "A big thank you to the following people that helped to make Mockoon better:  @ajatkj: Faker.js methods containing numbers. (Issue #1078) @martin-bucinskas: CLI refactoring and PM2 removal. (Issue #1081) @n1ce1041: CRUD id property. (Issue #1041)",
    "link": "/releases/4.0.0/",
    "sectionTitle": "Thank you",
    "sectionAnchor": "thank-you",
    "score": 8,
    "groupScore": 9
  },
  {
    "objectID": "/releases/3.1.0/#0",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "Welcome to this new release of Mockoon. There are several bug fixes and new features in this version that we hope you will like.",
    "link": "/releases/3.1.0/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 8,
    "groupScore": 0
  },
  {
    "objectID": "/releases/3.1.0/#our-platinum-sponsors",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "GitHub Peakcrypto  Mockoon is an open-source project built by volunteer maintainers. If you like our application, please consider sponsoring us and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Our platinum sponsors",
    "sectionAnchor": "our-platinum-sponsors",
    "score": 8,
    "groupScore": 1
  },
  {
    "objectID": "/releases/3.1.0/#mockoon-pro-plan-announcement",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "We are happy to announce that Mockoon Pro plans are now available. The first feature available in this plan is the ability to generate mock endpoints using our AI assistant alongside access to dozens of templates. It is the perfect companion for quick prototyping and teaching API concepts!  animation showing a prompt being entered and realistic JSON being generated  The Pro plan is available for solo developers and teams. The Team and Enterprise tiers also include priority support and a welcome training.  Subscribing to the Pro plan is also a good way to support this open-source project and contribute to its sustainability.  get pro plan button  We will add more features to the Pro plan in the future. You can subscribe to our newsletter on the Pro plan page to be notified when they are available.",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Mockoon Pro plan announcement",
    "sectionAnchor": "mockoon-pro-plan-announcement",
    "score": 8,
    "groupScore": 2
  },
  {
    "objectID": "/releases/3.1.0/#new-recording-mode-in-the-logs-view",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "A new recording mode is available in the logs view. It allows you to automatically create endpoints from the entering requests and proxied responses (documentation).  Enable recording mode by clicking on the record button in the logs view  (Issue #722)",
    "link": "/releases/3.1.0/",
    "sectionTitle": "New recording mode in the logs view",
    "sectionAnchor": "new-recording-mode-in-the-logs-view",
    "score": 8,
    "groupScore": 4
  },
  {
    "objectID": "/releases/3.1.0/#status-code-shown-in-logs-entries",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "The status code is now shown in the logs entries:  screenshot showing logs entries with a badge  (Issue #1031)",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Status code shown in logs entries",
    "sectionAnchor": "status-code-shown-in-logs-entries",
    "score": 8,
    "groupScore": 5
  },
  {
    "objectID": "/releases/3.1.0/#zoom",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "You can now zoom in and out using the Ctrl + + and Ctrl + - shortcuts. The zoom can also be reset using Ctrl 0.  screenshot showing the zoom shortcuts",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Zoom",
    "sectionAnchor": "zoom",
    "score": 8,
    "groupScore": 6
  },
  {
    "objectID": "/releases/3.1.0/#misc",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "The default data folder for Snap installations is now ~/snap/mockoon/common/.mockoon instead of the current Snap version folder. This will prevent losing data during application updates. (Issue #1026)",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Misc",
    "sectionAnchor": "misc",
    "score": 8,
    "groupScore": 7
  },
  {
    "objectID": "/releases/3.1.0/#cli",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "tzdata was added to the Docker image to enable timezone configuration. (Issue #865)",
    "link": "/releases/3.1.0/",
    "sectionTitle": "CLI",
    "sectionAnchor": "cli",
    "score": 8,
    "groupScore": 8
  },
  {
    "objectID": "/releases/3.1.0/#serverless-package",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "The package and its documentation was updated to help you deploy your mock API to Netlify's serverless functions. (Issue #1060)",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Serverless package",
    "sectionAnchor": "serverless-package",
    "score": 8,
    "groupScore": 9
  },
  {
    "objectID": "/releases/3.1.0/#thank-you",
    "title": "Mockoon release v3.1.0",
    "category": "releases",
    "content": "A big thank you to the following people that helped to make Mockoon better:  @roybarber: Serverless instructions for Netlify. (Issue #1060) @vishwasganatra: status code in logs. (Issue #1031)",
    "link": "/releases/3.1.0/",
    "sectionTitle": "Thank you",
    "sectionAnchor": "thank-you",
    "score": 8,
    "groupScore": 10
  },
  {
    "objectID": "/releases/3.0.0/#0",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Welcome to this new release of Mockoon. There are several bug fixes and new features in this version that we hope you will like.  First, we have some exciting news to share. Mockoon has been accepted to be part of the first-ever GitHub Accelerator cohort among 20 other open-source projects! You can read more on our blog.",
    "link": "/releases/3.0.0/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 8,
    "groupScore": 0
  },
  {
    "objectID": "/releases/3.0.0/#our-platinum-sponsors",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "GitHub Appwrite Peakcrypto  Mockoon is an open-source project built by volunteer maintainers. If you like our application, please consider sponsoring us and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/releases/3.0.0/",
    "sectionTitle": "Our platinum sponsors",
    "sectionAnchor": "our-platinum-sponsors",
    "score": 8,
    "groupScore": 1
  },
  {
    "objectID": "/releases/3.0.0/#unified-versioning",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "We are now using unified versioning across all our packages. This means that the desktop application, the CLI, and the serverless package will all be released with the same version number. This will make it easier to know which version of the CLI or the serverless package is compatible with the latest features of the desktop application. In practical terms, these changes mean that the desktop application will now follow semver and will be released with the same minor or major version number alongside the CLI and serverless package. This starts today with the release of v3.0.0.",
    "link": "/releases/3.0.0/",
    "sectionTitle": "Unified versioning",
    "sectionAnchor": "unified-versioning",
    "score": 8,
    "groupScore": 2
  },
  {
    "objectID": "/releases/3.0.0/#Ô∏è-breaking-changes",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Mockoon's desktop application is no longer compatible with Windows 7 and 8. We dropped support for Node.js v14. The CLI and the serverless package now require at least Node.js 16. The Docker image is now built using node:18-alpine.",
    "link": "/releases/3.0.0/",
    "sectionTitle": "‚ö†Ô∏è Breaking changes",
    "sectionAnchor": "Ô∏è-breaking-changes",
    "score": 8,
    "groupScore": 3
  },
  {
    "objectID": "/releases/3.0.0/#desktop-application",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Breaking change: We updated the application to the latest version of Electron. Thus, it is no longer compatible with Windows 7 and 8. (Issue #977) The custom URL scheme (mockoon://) was temporarily deactivated on Linux due to a bug causing association of HTML files with Mockoon. (Issue #997) We fixed a bug were the next route wasn't made active when the first one was deleted. (Issue #1014)",
    "link": "/releases/3.0.0/",
    "sectionTitle": "Desktop application",
    "sectionAnchor": "desktop-application",
    "score": 8,
    "groupScore": 4
  },
  {
    "objectID": "/releases/3.0.0/#cli",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Breaking change: The CLI's Docker image is now using node:18-alpine. (Issue #959) Breaking change: We dropped support for Node.js v14. The CLI now requires Node.js 16 at least. (Issue #959) A new flag --disable-log-to-file is available to disable the file logging. It is now the default for the Docker image. (Issue #868) Our CLI's Docker image is now multi-architecture and compatible with Arm64. (Issue #670) Curl was added to the Docker image to enable health checks. (Issue #945) We migrated the Oclif dependency for the CLI to the latest versions. The message stating that \"cli-ux\" is deprecated is not present anymore. (Issue #997)",
    "link": "/releases/3.0.0/",
    "sectionTitle": "CLI",
    "sectionAnchor": "cli",
    "score": 8,
    "groupScore": 5
  },
  {
    "objectID": "/releases/3.0.0/#serverless-package",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Breaking change: We dropped support for Node.js v14. The package is now requiring Node.js 16 at least. (Issue #959)",
    "link": "/releases/3.0.0/",
    "sectionTitle": "Serverless package",
    "sectionAnchor": "serverless-package",
    "score": 8,
    "groupScore": 6
  },
  {
    "objectID": "/releases/3.0.0/#new-templating-helpers",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Multiple helpers were added:  padStart and padEnd mimicking the native JavaScript String methods. (Issue #855) getVar to access variable created with setVar dynamically. (Issue #885)  We also made the following improvements:  dateFormat is now compatible with Date objects returned by helpers such as Faker's date.recent: {{dateFormat (faker 'date.recent') 'yyyy-MM-dd'}} (Issue #1012)",
    "link": "/releases/3.0.0/",
    "sectionTitle": "New templating helpers",
    "sectionAnchor": "new-templating-helpers",
    "score": 8,
    "groupScore": 8
  },
  {
    "objectID": "/releases/3.0.0/#chores",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "Dropping Node.js 14 support allowed us to remove the uuid dependency across all the packages. (Issue #1003)",
    "link": "/releases/3.0.0/",
    "sectionTitle": "Chores",
    "sectionAnchor": "chores",
    "score": 8,
    "groupScore": 9
  },
  {
    "objectID": "/releases/3.0.0/#thank-you",
    "title": "Mockoon release v3.0.0",
    "category": "releases",
    "content": "A big thank you to the following people that helped to make Mockoon better:  @gerwazy102: Docker image Arm64 arch. (Issue #670) @likileads: Node.js 14 end of support. (Issue #959) @martin-bucinskas: New --disable-log-to-file CLI's flag. (Issue #868) @m-roberts: Docker image healthcheck. (Issue #945)",
    "link": "/releases/3.0.0/",
    "sectionTitle": "Thank you",
    "sectionAnchor": "thank-you",
    "score": 8,
    "groupScore": 10
  },
  {
    "objectID": "/docs/latest/gui-cheat-sheet/#mockoon-gui-cheat-sheet",
    "title": "Mockoon GUI cheat sheet",
    "category": "docs",
    "content": "Are you discovering Mockoon's GUI or forgot what this button is used for? These cheat sheets are for you!  The GUI cheat sheet is also available in PDF version &nbsp;Download",
    "link": "/docs/latest/gui-cheat-sheet/",
    "sectionTitle": "Mockoon GUI cheat sheet",
    "sectionAnchor": "mockoon-gui-cheat-sheet",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/gui-cheat-sheet/#main-endpoints-view",
    "title": "Mockoon GUI cheat sheet",
    "category": "docs",
    "content": "The main view (below) contains your environments (or mock API) list, the environment's endpoints, and the currently selected endpoint and response. It's the view where you will spend the most time.  Mockoon routes view  The endpoint's responses configuration (below) lets you manage each endpoint responses list and each response parameter: serving a file, a body, or a data bucket, with rules or not, etc.  Mockoon responses view  At the top of the window, you can access other environment related views: the environment's headers, the data buckets, the requests logs, the environment's proxy parameters, and the environment's settings.",
    "link": "/docs/latest/gui-cheat-sheet/",
    "sectionTitle": "Main endpoints view",
    "sectionAnchor": "main-endpoints-view",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/gui-cheat-sheet/#data-buckets-view",
    "title": "Mockoon GUI cheat sheet",
    "category": "docs",
    "content": "The data buckets view let you create and modify key-value stores that can be linked to route responses or used with the data helper. They are persisting between calls and can be regenerated by restarting the server.  Mockoon data buckets view",
    "link": "/docs/latest/gui-cheat-sheet/",
    "sectionTitle": "Data buckets view",
    "sectionAnchor": "data-buckets-view",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/gui-cheat-sheet/#environments-requests-logs-view",
    "title": "Mockoon GUI cheat sheet",
    "category": "docs",
    "content": "The request logging view is especially useful to debug the entering calls and how Mockoon responded to them. For each, you will find the usual information: path, headers, body, etc. You can also see if the call has been caught or forwarded through the proxy (if enabled) and automatically mock entering requests that were not caught. Each environment (or mock API) has its own entering requests recording.  Mockoon logs view",
    "link": "/docs/latest/gui-cheat-sheet/",
    "sectionTitle": "Environment's requests logs view",
    "sectionAnchor": "environments-requests-logs-view",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/gui-cheat-sheet/#environments-proxy-parameters-view",
    "title": "Mockoon GUI cheat sheet",
    "category": "docs",
    "content": "This view allows you to enable the proxy mode and modify its behavior: removing the API prefix, adding specific headers to the proxied server request or response, etc.  Mockoon proxy view",
    "link": "/docs/latest/gui-cheat-sheet/",
    "sectionTitle": "Environment's proxy parameters view",
    "sectionAnchor": "environments-proxy-parameters-view",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/gui-cheat-sheet/#environments-settings-view",
    "title": "Mockoon GUI cheat sheet",
    "category": "docs",
    "content": "This view is the place where you can set up global settings for each environment. Changing the environment name, port, or API prefix, enabling HTTPS and using a custom certificate, handling OPTIONS pre-flight requests automatically, etc.  Mockoon settings view",
    "link": "/docs/latest/gui-cheat-sheet/",
    "sectionTitle": "Environment's settings view",
    "sectionAnchor": "environments-settings-view",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/about/#about-the-documentation",
    "title": "About the documentation",
    "category": "docs",
    "content": "This documentation covers Mockoon's most used features and options to help you create the best mock APIs. These topics apply to the desktop application, CLI, and serverless package which supports the same features. We maintain a documentation for the five latest desktop versions. Head over to our releases section for more details about the changes in each version.  If you find a mistake in the documentation, you can open an issue on the website's repository.",
    "link": "/docs/latest/about/",
    "sectionTitle": "About the documentation",
    "sectionAnchor": "about-the-documentation",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/about/#cli-documentation",
    "title": "About the documentation",
    "category": "docs",
    "content": "You will find the CLI documentation in its dedicated readme file on the repository. It covers the CLI's specific features, like the available flags or how to use the Docker file.",
    "link": "/docs/latest/about/",
    "sectionTitle": "CLI documentation",
    "sectionAnchor": "cli-documentation",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/about/#serverless-documentation",
    "title": "About the documentation",
    "category": "docs",
    "content": "You will find the serverless package documentation in its dedicated readme file on the repository. It covers the package usage instructions and specific features.  üéì Discover our official online course designed to help you get started with API mocking and API design. Coming soon! Learn more",
    "link": "/docs/latest/about/",
    "sectionTitle": "Serverless documentation",
    "sectionAnchor": "serverless-documentation",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/blog/windows-portable-gzip-rules-reordering/#0",
    "title": "New Windows portable version and more in v1.15.0",
    "category": "blog",
    "content": "This new release comes with the usual load of bug fixes and minor improvements you can check on the v1.15.0 release page.  You will find below some new features that we would like to highlight:",
    "link": "/blog/windows-portable-gzip-rules-reordering/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/windows-portable-gzip-rules-reordering/#windows-portable-version",
    "title": "New Windows portable version and more in v1.15.0",
    "category": "blog",
    "content": "A portable version for Windows is now available. Head over to our download page to download it. When using the portable version, the data folder will be located next to the executable. It will contain Mockoon's application files, your settings, and environments in ./mockoon-data/storage/environments|settings.json. In the non-portable application, these data files are usually stored in your use data folder in c:/Users/xxx/AppData/Roaming/mockoon/storage:  windows portable version",
    "link": "/blog/windows-portable-gzip-rules-reordering/",
    "sectionTitle": "Windows portable version",
    "sectionAnchor": "windows-portable-version",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/windows-portable-gzip-rules-reordering/#rules-reordering",
    "title": "New Windows portable version and more in v1.15.0",
    "category": "blog",
    "content": "Rules can now be reordered with a simple drag and drop. It allows you to influence the order in which the rules are interpreted. You can check our documentation for more information on rules order interpretation.  Drag and drop rules to reorder them",
    "link": "/blog/windows-portable-gzip-rules-reordering/",
    "sectionTitle": "Rules reordering",
    "sectionAnchor": "rules-reordering",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/windows-portable-gzip-rules-reordering/#listen-to-localhost-only",
    "title": "New Windows portable version and more in v1.15.0",
    "category": "blog",
    "content": "A new option is available that allows your mocks API to listen to localhost (and 127.0.0.1) only, instead of all network adapters (0.0.0.0). This feature can be easily enabled for each environment in the settings:  tick the localhost only checkbox  This option is also available in the CLI's latest version but is even more customizable. You can pass any hostname at runtime mockoon-cli ... --hostname 192.168.x.x. to listen on a specific network adapter on your machine.",
    "link": "/blog/windows-portable-gzip-rules-reordering/",
    "sectionTitle": "Listen to localhost only",
    "sectionAnchor": "listen-to-localhost-only",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/windows-portable-gzip-rules-reordering/#404-fallback",
    "title": "New Windows portable version and more in v1.15.0",
    "category": "blog",
    "content": "A new option has been added to the route response to automatically send a 404 status when a file was not found. This option only overrides the status code and will revert to serving the body present in the editor instead of the file.  tick the 404 fallback checkbox",
    "link": "/blog/windows-portable-gzip-rules-reordering/",
    "sectionTitle": "404 fallback",
    "sectionAnchor": "404-fallback",
    "score": 6,
    "groupScore": 4
  },
  {
    "objectID": "/blog/windows-portable-gzip-rules-reordering/#gzip-decoding",
    "title": "New Windows portable version and more in v1.15.0",
    "category": "blog",
    "content": "To make debugging easier, compressed bodies received from proxied APIs are now automatically decompressed and displayed in clear in the logs page:  gzip is decoded  This feature currently supports gzip, brotli and deflate.",
    "link": "/blog/windows-portable-gzip-rules-reordering/",
    "sectionTitle": "Gzip decoding",
    "sectionAnchor": "gzip-decoding",
    "score": 6,
    "groupScore": 5
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#0",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "We are happy to share with you a new version of Mockoon (v1.17.0) and the CLI (v1.3.0), fixing many bugs and bringing some exciting new features.  We hope you will enjoy them! Do not hesitate to give us your feedback üòÉ",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#partial-ui-redesign-and-improvements",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "To improve some features' discoverability and to declutter the interface a bit, we redesigned the main header. We also polished the interface here and there to give you a more streamlined and uniform experience. Here are the most significant changes:",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "Partial UI redesign and improvements",
    "sectionAnchor": "partial-ui-redesign-and-improvements",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#new-header-design",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "We removed multiple inputs from the main header and added a new tabs menu to make the proxy mode and logs more easily discoverable. We also split the environment settings into three views: the environment headers, the proxy options, and the environment settings.  new header design  The environment's inputs previously available in the header (name, port, prefix, and latency) are now in the \"Settings\" tab. To make it more convenient, you can edit the environment's name in both the \"Settings\" page and the environment menu (see below).",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "New header design",
    "sectionAnchor": "new-header-design",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#environments-menu-improvements",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "Following the header redesign, we made some modifications to the environment menu:  You can edit the environment's name directly in the menu. We removed the \"CORS\" icon as the option is mostly always enabled and moved the \"HTTPS\" icon next to the URL. The \"Truncate long paths\" option in the application settings (ctrl+comma) that apply to the long endpoint paths also applies now to the environment address. If enabled, environment URLs won't be truncated anymore.  new environment menu design",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "Environment's menu improvements",
    "sectionAnchor": "environments-menu-improvements",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#headers-and-rules-delete-button",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "All the headers and rules lists now use a \"click-to-confirm\" delete button that requires two click to effectively delete an item:  click and confirm",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "Headers and rules delete button",
    "sectionAnchor": "headers-and-rules-delete-button",
    "score": 6,
    "groupScore": 4
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#responses-list-improvements",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "The route responses menu is now split into two lines as it was becoming too cluttered and could cause visual bugs on smaller screens. We also added more information to the response menu:  responses dropdown menu",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "Responses list improvements",
    "sectionAnchor": "responses-list-improvements",
    "score": 6,
    "groupScore": 5
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#file-and-body-information-display-improvements",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "We removed the redundant Content-Type information in the \"Status & body\" tab that could be confusing and replaced it with a small \"footer\" under the body editor. This footer will always display the effective Content-Type taking the following order of precedence into account: environment headers ‚Üí file mime type ‚Üí route headers  file body information",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "File and body information display improvements",
    "sectionAnchor": "file-and-body-information-display-improvements",
    "score": 6,
    "groupScore": 6
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#custom-tls-certificate",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "You can now provide a custom TLS certificate to serve your mocks over HTTPS in PKCS12 or PEM format. Mockoon still uses the same self-signed certificate as before if you don't provide a custom one. Head over to the documentation for more information about the TLS configuration.  add custom TLS certificate",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "Custom TLS certificate",
    "sectionAnchor": "custom-tls-certificate",
    "score": 6,
    "groupScore": 7
  },
  {
    "objectID": "/blog/ui-redesign-custom-tls-cert/#new-response-rules-for-cookies",
    "title": "UI redesign and custom TLS certificates",
    "category": "blog",
    "content": "A new type of response rule is available to check a cookie's value or presence:  cookie response rules choice   Be sure to check the full changelog to discover all the improvements and fixes.",
    "link": "/blog/ui-redesign-custom-tls-cert/",
    "sectionTitle": "New response rules for cookies",
    "sectionAnchor": "new-response-rules-for-cookies",
    "score": 6,
    "groupScore": 8
  },
  {
    "objectID": "/blog/sequential-responses-custom-status-codes/#0",
    "title": "Sequential responses, custom status codes, and out-of beta CLI!",
    "category": "blog",
    "content": "This new release comes with the usual load of bug fixes and minor improvements you can check on the v1.14.0 release page.  We also decided to take the CLI out of beta with a new v1.0.0 üéâ. There is still space for improvements, but it is now stable enough thanks to the feedback and contributions from our great community!  Here are some new features that we would like to highlight in this blog post:",
    "link": "/blog/sequential-responses-custom-status-codes/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/sequential-responses-custom-status-codes/#sequential-responses",
    "title": "Sequential responses, custom status codes, and out-of beta CLI!",
    "category": "blog",
    "content": "You can now configure Mockoon to serve your responses sequentially. When enabled, your responses will be served in the order, repeating from the beginning indefinitely. With three responses 200, 201, 202, you would get the following sequence: 200 ‚Üí 201 ‚Üí 202 ‚Üí 200 ‚Üí 201... and so on. Restarting the server will reset this sequence.  enable sequential responses  Similar to the random responses feature, this option disables the rules temporarily.",
    "link": "/blog/sequential-responses-custom-status-codes/",
    "sectionTitle": "Sequential responses",
    "sectionAnchor": "sequential-responses",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/sequential-responses-custom-status-codes/#new-request-number-rule",
    "title": "Sequential responses, custom status codes, and out-of beta CLI!",
    "category": "blog",
    "content": "A new type of rule has been created to allow you to serve a specific response depending on the entering request number. In the following example, a 404 would be served at the first request only.  request number rule  The entering requests counter is on a per route basis and gets reset when the server is restarted.",
    "link": "/blog/sequential-responses-custom-status-codes/",
    "sectionTitle": "New \"request number\" rule",
    "sectionAnchor": "new-request-number-rule",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/sequential-responses-custom-status-codes/#custom-status-codes",
    "title": "Sequential responses, custom status codes, and out-of beta CLI!",
    "category": "blog",
    "content": "For this update, we worked on revamping the status code dropdown to offer more suggestions, organized by categories. Even if not standards, you can also provide custom status codes from 100 to 999.  enter a custom status code",
    "link": "/blog/sequential-responses-custom-status-codes/",
    "sectionTitle": "Custom status codes",
    "sectionAnchor": "custom-status-codes",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/september-2023-news/#0",
    "title": "September 2023 news",
    "category": "blog",
    "content": "Welcome to our first blog quarterly news! Usually sent in the form of a newsletter, we decided to publish it on our blog too.  In this update, we have a lot to share since June, including exciting new features, upcoming developments, and our commitment to privacy. Read on to discover what's been happening in the world of Mockoon.  üéÇ Also, Mockoon just turned 6 years old. The MVP was released in September 2017. Time flies...",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/september-2023-news/#-new-releases",
    "title": "September 2023 news",
    "category": "blog",
    "content": "We have released three new versions since the last June newsletter, as we have moved to a monthly release schedule. 4.0.0 (July), 4.1.0 (August) and 5.0.0 (September). Among the new features and changes:  JSONPath support: Mockoon now supports JSONPath alongside object-path everywhere a path to an object property can be provided: in templating helpers like data, body and queryParam, in the response rules path, etc. üìò&nbsp;Read more Logging: Logging has been standardized across all Mockoon applications and packages. The logs will now be formatted the same way in the desktop application log file, the CLI's console and log file, and the serverless package's console logging. üìò&nbsp;Read more CLI changes: We refactored the CLI to remove the dependency to PM2, which was subject to some security vulnerabilities. Another reason for this refactoring, was that, having multiple other ways to manage running CLI instances (i.e. containers), embedding a process manager felt a bit outdated and overkill. The CLI is now easier to maintain and more lightweight. As a consequence multiple flags and options disappeared, and running the CLI as a foreground process is now the default. üìò&nbsp;Read more Response fallback mode: A new response mode has been added. It allows you to fallback to the next route and ultimately the proxied server when no response rules match instead of serving the default response. üìò&nbsp;Read the documentation HTTP methods: It is now possible to create routes that will match any HTTP method by selecting \"All methods\" in the routes method dropdown. üìò&nbsp;Read more OpenAPI support improvements: When exporting to OpenAPI format, inline bodies are now used to populate the example property. üìò&nbsp;Read more And more: templating support in rules, new array filtering templating helper.",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "üì¶ New releases",
    "sectionAnchor": "-new-releases",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/september-2023-news/#-global-rules",
    "title": "September 2023 news",
    "category": "blog",
    "content": "Thanks to the response fallback mode introduced in v4.1.0, it is now possible to create wildcard routes containing global rules, such as validating the presence of an Authorization header or verifying that the request body contains a specific property. Head over to our new Global routes with rules documentation section to learn how to create reusable responses and rules and apply them to all your routes.  application screenshot with a wildcard route",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "üìè Global rules",
    "sectionAnchor": "-global-rules",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/september-2023-news/#-new-github-action",
    "title": "September 2023 news",
    "category": "blog",
    "content": "We have officially launched a GitHub Action for the CLI, allowing you to effortlessly run your mocks within your GitHub CI environment.  screenshot of mockoon github action code  No complex setup is required. Simply add the action to your workflow and provide a path to a local data file, or a URL, and you're good to go.",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "üé¨ New GitHub Action",
    "sectionAnchor": "-new-github-action",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/september-2023-news/#-mockoon-pro-data-synchronization",
    "title": "September 2023 news",
    "category": "blog",
    "content": "The development of Mockoon's Pro data synchronization feature for solo developers is progressing smoothly. We anticipate releasing this feature as part of the Pro Solo plan by the end of this year. Concurrently, we have also begun working on the team collaboration feature, which shares similarities with the solo data synchronization. You can look forward to this feature being available in the Team and Enterprise plans in the first quarter of next year.",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "üë∑ Mockoon Pro data synchronization",
    "sectionAnchor": "-mockoon-pro-data-synchronization",
    "score": 6,
    "groupScore": 4
  },
  {
    "objectID": "/blog/september-2023-news/#-ditching-google-analytics-for-the-website",
    "title": "September 2023 news",
    "category": "blog",
    "content": "We have recently removed Google Analytics from our website as part of our commitment to enhancing privacy. We now exclusively track the number of page views and referrals, using a somewhat old-school approach similar to a simple visit counter. We've come to realize that many metrics provided by traditional analytics tools are not the actionable insights we are looking for. So, why not keep it simple?",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "üìä Ditching Google Analytics for the website",
    "sectionAnchor": "-ditching-google-analytics-for-the-website",
    "score": 6,
    "groupScore": 5
  },
  {
    "objectID": "/blog/september-2023-news/#-oss-friends",
    "title": "September 2023 news",
    "category": "blog",
    "content": "We have partnered with several other open-source projects that we admire and wish to support. Feel free to explore them!  ",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "ü§ù OSS friends",
    "sectionAnchor": "-oss-friends",
    "score": 6,
    "groupScore": 6
  },
  {
    "objectID": "/blog/september-2023-news/#Ô∏è-custom-services",
    "title": "September 2023 news",
    "category": "blog",
    "content": "We now offer custom services to help you get started with Mockoon through training, support, and custom development. Contact us for more information.",
    "link": "/blog/september-2023-news/",
    "sectionTitle": "üõ†Ô∏è Custom services",
    "sectionAnchor": "Ô∏è-custom-services",
    "score": 6,
    "groupScore": 7
  },
  {
    "objectID": "/blog/new-unified-versioning/#-semantic-versioning-sort-of",
    "title": "New unified versioning v3.0.0",
    "category": "blog",
    "content": "Mockoon has been employing semantic versioning throughout all its applications since the start. However, the desktop application, the CLI, and later the serverless package, were not published under the same version.  It could cause some confusion when trying to know which version of the CLI was compatible with the desktop application. In practice, the latest CLI v2.4.0 was compatible with the desktop application v1.23.0. Not very intuitive.  Moreover, the desktop application was not really following semantic versioning and was not released with a major version number when there were breaking changes (i.e. data migrations). Same for the CLI and serverless package which were following semantic versioning but only taking into account their own features (e.g. a new flag for the CLI).  As a result, the CLI could be upgraded automatically without requiring any action from the user if a new release only incremented the minor version. However, if the user continued to use the previous version of the desktop application, it could potentially disrupt automated workflows if a data migration was part of the release.",
    "link": "/blog/new-unified-versioning/",
    "sectionTitle": "üî¢ Semantic versioning, sort of",
    "sectionAnchor": "-semantic-versioning-sort-of",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/new-unified-versioning/#Ô∏è-unified-versioning",
    "title": "New unified versioning v3.0.0",
    "category": "blog",
    "content": "Starting with release v3.0.0, we unified the versioning across all our packages. The desktop application, the CLI, and the serverless package will all be released with the same version number. Our intention with this change is to simplify your experience and provide clarity regarding the compatibility of the CLI or serverless package version with the latest functionalities of the desktop application.  In practical terms, this means that:  The desktop application will now follow semantic versioning and will be released with a major version number when there are breaking changes (i.e. data migrations). Its version was bumped to v3.0.0 to reflect this change and to be in sync with the CLI. Each application will now take into account the other applications' versions when incrementing its version number. For example, the CLI v4.0.0 will be released when the desktop application v4.0.0 is released, even if there are no new features or breaking changes in the CLI, and vice versa.  We hope this change will make your experience with Mockoon even better. As always, feel free to reach out if you have any questions or feedback.",
    "link": "/blog/new-unified-versioning/",
    "sectionTitle": "üè∑Ô∏è Unified versioning",
    "sectionAnchor": "Ô∏è-unified-versioning",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#0",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "We are happy to share with you a new version of Mockoon (v1.16.0) and the CLI (v1.2.0), fixing many bugs and bringing some exciting new features.  We hope you will enjoy them! Do not hesitate to give us your feedback üòÉ",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#new-storage-system",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "For this release, we revamped how Mockoon stores its data. As a result, Mockoon is now easier to use and more in line with the industry standards. It took us lots of time, but we are proud of the result. This change brings multiple benefits: more flexibility, easier API mock sharing, relative file resolving, etc.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "New storage system",
    "sectionAnchor": "new-storage-system",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#the-old-system",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "Until now, Mockoon was storing its data, the API mock you create in the interface, in a basic way inherited from Mockoon's early days in 2017. All of your environments were stored in the same environments.json file in the application data folder. It was lost in your operating system user folder: c:/Users/username/AppData/Roaming/mockoon/storage on Windows or ~/.config/mockoon/storage on Linux.  The new system aligns with how file editors work. It stores each environment separately and lets you open them from anywhere on your hard drive.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "The old system",
    "sectionAnchor": "the-old-system",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#what-happened-to-my-environmentsjson-file",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "When updating to version 1.16.0, Mockoon automatically migrated the old environments.json file and split it into as many files as you had environments. These files were created in the same storage folder with incremental names: environment-0.json, environment-1.json, etc.  one file vs multiple files after the migration  You can now move these files anywhere on your hard drive and open them from there.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "What happened to my `environments.json` file?",
    "sectionAnchor": "what-happened-to-my-environmentsjson-file",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#new-buttons-menu-entries-and-behaviors",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "As a consequence of this change, when creating, duplicating, or importing a new API (in Mockoon or OpenAPI format), you will now be prompted to choose a folder and filename to save your new mock. We also added new buttons and menu options to allow you to manage your environment files. You can create a new environment or open an existing one using the two buttons at the top of the environment menu:  open environment button  You can now close one environment using the context menu:  context menu close environment  Finally, there is a new context menu entry you can use to locate the environment file on your computer:  context menu show in folder",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "New buttons, menu entries, and behaviors",
    "sectionAnchor": "new-buttons-menu-entries-and-behaviors",
    "score": 6,
    "groupScore": 4
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#easier-sharing",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "With this update, you can now share your environments with your coworkers by saving them in a Git-tracked folder. Before, you would have to use the import/export feature or set up a git repository in the storage folder, which wasn't practical. We also decided to save your environment JSON files pretty-printed by default. It will make working with merge conflicts and highlighting changes easier when using Git. You can disable this option in the settings:  Disable storage pretty printing in the settings",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "Easier sharing",
    "sectionAnchor": "easier-sharing",
    "score": 6,
    "groupScore": 5
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#file-path-resolving",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "Some long-awaited changes were made to the body files path resolving. From now on, Mockoon will try to resolve your body files from the environment's file directory. It allows you to store an environment's body files alongside the main file and share them with your coworkers without having relative or absolute path issues.  body file path  This is also true with the CLI v1.2.0 which will resolve the files relatively to the environment or export file that was passed as an argument.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "File path resolving",
    "sectionAnchor": "file-path-resolving",
    "score": 6,
    "groupScore": 6
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#environment-schema-validation",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "Behind the scene, we also added an environment schema validation to ensure that the environment you load is valid and do not break the application behavior. This system can repair environment files should they miss any property. It will also ensure that all the UUIDs present in the environment files are unique. As part of your workflows, you can now edit or duplicate environment files outside Mockoon without encountering erroneous states in the application.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "Environment schema validation",
    "sectionAnchor": "environment-schema-validation",
    "score": 6,
    "groupScore": 7
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#importexport-deprecation",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "Before this change, many of you relied on the import/export feature to share their environments with their coworkers. As you can now directly open environment files from anywhere and share them as-is, the import/export (in Mockoon's format) option seems redundant and does not offer any advantage. This feature may be deprecated and removed in a future version. It's even truer considering that the CLI is now fully compatible with single environment files and does not require export files to work. The import/export feature in the OpenAPI format is, of course, still relevant.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "Import/export \"deprecation\"?",
    "sectionAnchor": "importexport-deprecation",
    "score": 6,
    "groupScore": 8
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#new-mock-samples",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "We added more API samples to help you start working in no time with your favorite APIs: Buffer, Notion, GitHub, etc. You can find them on our website mock samples page. Starting with this version, you can load them directly in Mockoon by clicking on the \"Open\" buttons present on the page.  mock api samples page",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "New mock samples",
    "sectionAnchor": "new-mock-samples",
    "score": 6,
    "groupScore": 9
  },
  {
    "objectID": "/blog/new-storage-system-git-data-sharing/#xml-support",
    "title": "New storage system and improved data sharing",
    "category": "blog",
    "content": "Last but not least, we added support for the XML format. It means that you can now reuse part of the entering XML bodies with various templating helpers (body, etc.) and define rules to serve different responses depending on the XML content.",
    "link": "/blog/new-storage-system-git-data-sharing/",
    "sectionTitle": "XML support",
    "sectionAnchor": "xml-support",
    "score": 6,
    "groupScore": 10
  },
  {
    "objectID": "/blog/mockoon-cli-now-available/#0",
    "title": "Mockoon CLI is now available ü•≥",
    "category": "blog",
    "content": "After months of work, Mockoon CLI is available in beta üöÄ. You can now deploy your mock APIs in all your headless and automated environments. A server, your favorite CI environment, in a GitHub Action, in the Windows Subsystem Linux, you name it!  Like the main application, the CLI is free and open-source. It supports all of Mockoon features, and we tried to make it as fast as possible.  You are one command away to using it. Check the installation instructions, and most of all, let us know what you think and what we could improve on the official forum.",
    "link": "/blog/mockoon-cli-now-available/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/mockoon-cli-now-available/#how-does-it-work",
    "title": "Mockoon CLI is now available ü•≥",
    "category": "blog",
    "content": "The CLI can directly run a Mockoon environment file. You can either provide the data as a local file or a URL where you host it.  Mockoon CLI start command output  You can also list the running mock API processes to get some information about them (port, PID, CPU, memory, etc.) or stop them completely.  Mockoon CLI list command output  Mockoon CLI supports all of Mockoon's features: templating system, proxy mode, route response rules, etc.  It's also compatible with your data files in an older format as it automatically migrates them before running the mock.",
    "link": "/blog/mockoon-cli-now-available/",
    "sectionTitle": "How does it work",
    "sectionAnchor": "how-does-it-work",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/mockoon-cli-now-available/#implementation-details",
    "title": "Mockoon CLI is now available ü•≥",
    "category": "blog",
    "content": "We chose to create an NPM package as it is a widely used and well-known format. It's also the technology we know best, and we wanted to be sure to create something simple to use, fast and lightweight.  Before actually working on the CLI, we needed first to extract a lot of code from the main application into a new library. Luckily, this part of the main application was already relatively independent. But we still had some challenges and learned a lot about creating a Typescript library üòÑ.  Under the hood, we used Typescript (as for the main application and the library), Oclif to create the command-line tool, and PM2 to manage your mock API processes. It means that, while we wrap our CLI around all of PM2 commands, you can leverage everything PM2 has to offer if you are used to it!",
    "link": "/blog/mockoon-cli-now-available/",
    "sectionTitle": "Implementation details",
    "sectionAnchor": "implementation-details",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/mockoon-cli-now-available/#closing-thoughts",
    "title": "Mockoon CLI is now available ü•≥",
    "category": "blog",
    "content": "The CLI was our small 2020 challenge. The biggest struggle was to achieve this while having a full-time job and an infinite list of things to work on for this project: content, features, support, etc. But we like challenges üòÖ.  We were initially planning a beta release for November. It seems the initial estimation wasn't that off!  We hope that you will love using this tool as much as we loved creating it!  One of the oldest requests from our users (September 2018! üò±) is now closed, but this is just the beginning! More improvements are already in the pipe. Stay tuned!",
    "link": "/blog/mockoon-cli-now-available/",
    "sectionTitle": "Closing thoughts",
    "sectionAnchor": "closing-thoughts",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/introducing-mockoon-ai-assistant-pro-plans/#-announcing-the-pro-plans",
    "title": "Introducing AI assistant and Pro plans",
    "category": "blog",
    "content": "We are excited to announce the launch of Mockoon Pro plans, marking a significant milestone in our journey as an open-source project. At Mockoon, we have always been dedicated to providing powerful and user-friendly tools for API mocking and testing, made available freely under an open-source license to the developers' community.  Introducing Mockoon Pro plans stems from our commitment to expanding the project's scope while ensuring its long-term viability. By offering paid products and services, we aim to find a balance between an open-source core and providing advanced features and enterprise-level services for those who desire an even more powerful API mocking and prototyping experience.  This significant step will allow us to secure the project's sustainability and continue serving developers worldwide with the same dedication.",
    "link": "/blog/introducing-mockoon-ai-assistant-pro-plans/",
    "sectionTitle": "üì¢ Announcing the Pro plans",
    "sectionAnchor": "-announcing-the-pro-plans",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/introducing-mockoon-ai-assistant-pro-plans/#-ai-assistant-and-templates",
    "title": "Introducing AI assistant and Pro plans",
    "category": "blog",
    "content": "The first feature part of our Pro plans is an AI assistant that helps you generate realistic templates for your endpoints, accompanied by a range of hand-curated JSON templates. This functionality empowers solo developers and teams to accelerate the prototyping process.  This feature is not only designed to enhance API prototyping but also serves as an invaluable tool for teaching and learning API concepts. It makes Mockoon Pro the perfect companion for educators, trainers, and anyone seeking to teach or grasp the intricacies of APIs.  animation showing prompts being written and JSON content appearing  Behind the scenes, our AI assistant leverages OpenAI's Chat GPT. We have fine-tuned the prompt specifically for Mockoon, enabling the generation of complex and realistic JSON structures using Handlebars templating and Faker.js helpers. This integration empowers developers to effortlessly create realistic and dynamic mock endpoints, reducing development time and simplifying the process of prototyping their APIs.",
    "link": "/blog/introducing-mockoon-ai-assistant-pro-plans/",
    "sectionTitle": "ü§ñ AI assistant and templates",
    "sectionAnchor": "-ai-assistant-and-templates",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/introducing-mockoon-ai-assistant-pro-plans/#-priority-support-and-welcome-training",
    "title": "Introducing AI assistant and Pro plans",
    "category": "blog",
    "content": "By subscribing to Mockoon Pro's Team and Enterprise plans, you also benefit from our priority support with a dedicated support channel where we promptly address any questions or concerns you may have. This advanced support ensures that your API development and testing workflows remain uninterrupted.  In addition to priority support, our Enterprise plan includes comprehensive welcome training. We understand that transitioning to a new platform can sometimes be daunting. It is why we offer personalized onboarding to help your team quickly get up to speed with Mockoon. This training covers all the ins and outs of our tools, guiding your team through its advanced features and best practices. By providing this training, we want to ensure a smooth and successful integration of Mockoon into your API development processes.",
    "link": "/blog/introducing-mockoon-ai-assistant-pro-plans/",
    "sectionTitle": "üí¨ Priority support and welcome training",
    "sectionAnchor": "-priority-support-and-welcome-training",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/introducing-mockoon-ai-assistant-pro-plans/#Ô∏è-future-roadmap",
    "title": "Introducing AI assistant and Pro plans",
    "category": "blog",
    "content": "At Mockoon, we strive to innovate and constantly bring new features to our users. The future roadmap for Mockoon Pro is full of exciting possibilities that will further enrich your API prototyping experience. We provide a public roadmap page where you can get a glimpse of the developments on the horizon. You can also subscribe to our newsletter below, or on the Pro page product updates to get informed of any new features and updates.   By subscribing to Mockoon Pro, you will enhance your API development capabilities and also contribute to the sustainability of the open-source project. Join us on this exciting journey and subscribe to Mockoon Pro today!  get mockoon pro button",
    "link": "/blog/introducing-mockoon-ai-assistant-pro-plans/",
    "sectionTitle": "üõ£Ô∏è Future roadmap",
    "sectionAnchor": "Ô∏è-future-roadmap",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/github-accelerator/#-mockoon-joins-github-accelerator",
    "title": "Mockoon is part of the first GitHub Accelerator cohort üöÄ",
    "category": "blog",
    "content": "We are excited to announce that we have been accepted to the first GitHub Accelerator cohort. This is a major milestone for our project and we are honored to be a part of such an amazing community of developers.  In addition to Mockoon, 19 other awesome open-source projects have been selected. We look forward to collaborating with them throughout the program.  Project Purpose Analog Analog is a fullstack meta-framework to build applications and websites with Angular Atri The Python web framework to build production-grade apps htmx Makes AJAX, Web Sockets, etc. available directly in HTML Code Hike Tools for building all types of code walkthroughs: blogs, docs, slides, tutorials, etc. Dioxus Friendly React-like GUI library for desktop, web, mobile, and more, written in Rust. LinkFree Connecting with your audience with a single link, showcasing your content and projects. Seamly2D Design CAD to democratize and de-centralize fashion design & production. nbdev Increase developer productivity by 10x with a new exploratory programming workflow. Formbricks Open-source Qualtrics alternative Sniffnet Cross-platform application to comfortably monitor and analyse network traffic pypandoc Pypandoc provides a thin wrapper for pandoc, a universal document converter. Nuxt An intuitive framework for building web applications, built for the edge. Responsively A dev-tool for web developers that aid in faster responsive web page development. Datasette An open source multi-tool for exploring and publishing data Spyder The scientific Python development environment Strawberry GraphQL A GraphQL library for Python that leverages type annotations üçì Termux A terminal emulator for Android that provides 2000+ linux packages to code on phone Poly Poly is a fast, well tested Go package for engineering organisms. tRPC End-to-end typesafe APIs made easy. Never write another API contract again.  Through the mentorship, resources, and support provided by the GitHub Accelerator, we will be able to explore new opportunities to secure the future of the project and find ways to sustain ourselves in the long term. Our commitment to open-source is stronger than ever, and we are thrilled to take Mockoon to the next level with the help of our awesome community.  We are excited to see what the future holds, and we would like to thank GitHub for this opportunity!",
    "link": "/blog/github-accelerator/",
    "sectionTitle": "üöÄ Mockoon joins GitHub Accelerator",
    "sectionAnchor": "-mockoon-joins-github-accelerator",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/github-accelerator/#Ô∏è-sponsoring-and-pro-plans",
    "title": "Mockoon is part of the first GitHub Accelerator cohort üöÄ",
    "category": "blog",
    "content": "Because developing open-source softwares is not free, we (still) need your help to guarantee a bright future for our favorite raccoon. If you like our work, you can support us in multiple ways:  Spread the word! The more, the merrier üôÇ. Sponsor us and join all the Sponsors and Backers who helped this project over time. It's a great way to support us and show your brand in front of thousands of developers interested in APIs. Subscribe to our new Pro plans: AI-powered API mocks generation, enterprise-grade support, and more!  We are also working on a Pro plan available later this year. It will offer exciting features such as data synchronization and AI-powered API mocks generation. Stay tuned!",
    "link": "/blog/github-accelerator/",
    "sectionTitle": "üíÅ‚Äç‚ôÇÔ∏è Sponsoring and pro plans",
    "sectionAnchor": "Ô∏è-sponsoring-and-pro-plans",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/five-years-2022-retrospective/#0",
    "title": "2022 retrospective and Mockoon 5th anniversary",
    "category": "blog",
    "content": "Happy New Year from the Mockoon team! The new year is a great occasion to reflect on what we did during the past months. We also celebrated (quietly) Mockoon's 5th anniversary at the end of 2022 üéâ",
    "link": "/blog/five-years-2022-retrospective/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/five-years-2022-retrospective/#new-and-upcoming",
    "title": "2022 retrospective and Mockoon 5th anniversary",
    "category": "blog",
    "content": "Since the last blog post, we've released several major updates and new features that we're excited to share with you.  üìÅ One of the most popular updates is the ability to organize routes into folders, making it easier for users to keep track of their API endpoints, and regroup or hide some of them. It was one of the oldest opened issues, and we are glad it is now generally available.  ‚òÅÔ∏è We also released a new serverless package, allowing users to use their mock APIs in serverless environments (Firebase Functions, AWS Lambda, etc.).  ü™£ Finally, we introduced data buckets, a powerful key-value store available in each environment. Data buckets are persistent and generated when the server starts. This feature will make the development of CRUD and GraphQL routes easier in the future.",
    "link": "/blog/five-years-2022-retrospective/",
    "sectionTitle": "New and upcoming",
    "sectionAnchor": "new-and-upcoming",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/five-years-2022-retrospective/#-and-after",
    "title": "2022 retrospective and Mockoon 5th anniversary",
    "category": "blog",
    "content": "As we look ahead to the new year, we're excited to announce several upcoming features that we think you'll love:  First, we will soon start working on CRUD endpoints, which will make it easier for users to create routes that automatically create, read, update, and delete data within their data buckets. This feature is by far the most requested, and many newcomers expect Mockoon's route to work this way. We will tackle the GraphQL mocking feature that we started last year.  We're also planning to launch a new cloud offering later this year. It will allow solo developers to synchronize their data between their devices and later collaborate with a team. In the longer term, we would like to offer cloud deployments and remote CLI management. But one step at a time.",
    "link": "/blog/five-years-2022-retrospective/",
    "sectionTitle": "üÜï And after?",
    "sectionAnchor": "-and-after",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/five-years-2022-retrospective/#five-years-",
    "title": "2022 retrospective and Mockoon 5th anniversary",
    "category": "blog",
    "content": "Five years ago, in 2017, our founder Guillaume created a small API mocking desktop application for his use. After sustained years of growth and positive feedback, he left his job and went full-time on the project somewhere in 2021. And here we are, five years later and 300&nbsp;000 downloads and counting! We're humbled by the continuous trust and support of our users and are constantly working to improve and innovate to make Mockoon better.  And after all this time, Mockoon is still an open-source tool built by volunteer maintainers. To continue working on this project and sustain ourselves, we are looking for sponsors. If you like our application, please consider sponsoring us too and join all the Sponsors and Backers who helped this project over time!  sponsor button  As part of this search for sustainability, we now have Pro plans including, AI-powered API mocks generation, enterprise-grade support, and more!   We're so grateful for the support and feedback of our users, and we're excited to continue to improve and innovate in the coming year. Thank you for choosing Mockoon, and here's to an amazing 2023!",
    "link": "/blog/five-years-2022-retrospective/",
    "sectionTitle": "Five years üéÇ",
    "sectionAnchor": "five-years-",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#0",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "We are happy to share some highlights from the two last versions of Mockoon desktop and CLI (v1.18.0 and v1.19.0).  We hope you will enjoy them! Do not hesitate to give us your feedback üòÉ Check the changelogs for a list of the other improvements and bug fixes.",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#file-monitoring",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "Mockoon can now monitor environment files external changes and automatically reload the interface with the new data. You can activate this option in the settings:  Mockoon settings view with file monitoring option  After a change is detected, your mock setup will be automatically updated or after validating a confirmation prompt:  Mockoon file monitoring reload prompt",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "File monitoring",
    "sectionAnchor": "file-monitoring",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#mock-api-sample",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "To help you mock third-party APIs in no time, we added more than 2000 new mock samples: 1Password, AWS, Giphy, Mastercard, Slack, etc. You can run them directly in the application or the CLI with one click. Discover all the mock samples  mock sample page from mockoon website",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "Mock API sample",
    "sectionAnchor": "mock-api-sample",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#mockoon-button",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "We added a button that you can add to your website to offer your users a convenient way to launch your API mocks in one click. It uses Mockoon's custom protocol mockoon:// to open your mock API directly in the desktop application. You can also provide your user with a ready-to-use CLI command (see below). interface for creating a mockoon button",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "Mockoon button",
    "sectionAnchor": "mockoon-button",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#importexport-deprecation",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "We removed the options to import/export your mock data in Mockoon's proprietary format. Since v1.16.0, importing and exporting in Mockoon's format was mostly useless. Environment files are now easier to share \"as-is\", and are supported out of the box by the CLI. Also, user feedback indicated that keeping this export option was confusing. Exporting environments and routes to the clipboard (in the right-click context menu) now copy the regular JSON data without wrapping them in the old export format. The application and the CLI are still able to open old export files, but you won't be able to create them anymore.  On a side note, we updated the OpenAPI documentation to explain the discrepancies between the specification and Mockoon's features.",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "Import/export deprecation",
    "sectionAnchor": "importexport-deprecation",
    "score": 6,
    "groupScore": 4
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#easier-default-response-selection",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "We made it easier to define the default response. Before this change, the default response was always the first in the list. Now, the blue flag indicates the default response, and you can change it by clicking on the grey flag:  default route response marked by a blue flag change default route response by clicking grey flags",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "Easier default response selection",
    "sectionAnchor": "easier-default-response-selection",
    "score": 6,
    "groupScore": 5
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#new-templating-helpers-and-fixes",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "We added some new templating helpers (lowercase, uppercase, and base64Decode) and fixed many of them.  We also updated Faker.js to version 6. It offers some new helpers and locales.",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "New templating helpers and fixes",
    "sectionAnchor": "new-templating-helpers-and-fixes",
    "score": 6,
    "groupScore": 6
  },
  {
    "objectID": "/blog/file-monitoring-mock-api-samples/#google-analytics-removal",
    "title": "File monitoring and 2000+ new mock samples",
    "category": "blog",
    "content": "Following the introduction of a custom privacy-friendly telemetry system last year (you can opt-out of this telemetry system in the application settings), we removed Google Analytics from the desktop application. As before, we collect no data or telemetry in the CLI.",
    "link": "/blog/file-monitoring-mock-api-samples/",
    "sectionTitle": "Google Analytics removal",
    "sectionAnchor": "google-analytics-removal",
    "score": 6,
    "groupScore": 7
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#0",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "Mockoon reached 4000 stargazers on GitHub üéâ. We would like to thank our awesome community for following us since the beginning and recommending Mockoon to their friends and coworkers!  We will use this fantastic milestone to recap some of Mockoon's news of the past year.",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#sustained-user-growth",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "There are thousands of users using Mockoon every day. We also crossed the 250k downloads mark several months ago, and it shows no sign of stopping. From solo developers to teams at Fortune 500 companies, you all find something in Mockoon that you like. We are thrilled and proud that our work is helping you work better and faster. It's also rewarding to randomly meet more and more people (IRL!) using our tools.",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "Sustained user growth",
    "sectionAnchor": "sustained-user-growth",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#lots-of-new-features",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "Last year, we added many features for the desktop application and the CLI. It's impossible to list all of them here, but here is some major ones:  We switched to a new way of storing your mocks to make them easily shareable over git and directly launch them with the CLI without relying anymore on an import/export feature. We added a file monitoring option for the desktop application to automatically reload the application when an external change to a mock file is detected. Mockoon now supports custom TLS certificates to serve your mock securely without relying on Mockoon's self-signed certificate. We improved the system of rules by adding a lot of features: support for cookies, reordering, rule inversion (coming soon!), rule disabling (coming soon!), multipart/form-data support (coming soon!) We removed Google Analytics from the desktop application to increase your privacy. We added XML support for both templating helpers and rules. We added more binaries formats: Apple Silicon, Windows portable, and Microsoft Store. The CLI can now run multiple mocks at once, log the complete HTTP transaction (--log-transaction flag), and run as a foreground process (--daemon-off flag).  We also started working on a GraphQL mocking feature. It's progressing well, and we are satisfied with the Proof of Concept. However, it is a complex feature with a different approach than the HTTP endpoints. So, we want to take our time to do it right and build something useful. Stay tuned, as it will probably be released later this year.",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "Lots of new features",
    "sectionAnchor": "lots-of-new-features",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#thousands-of-mock-samples-and-mockoons-embedded-button",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "We added thousands of mock samples to help you get started with mocking your favorite API. If you have installed the application, you can run the mock API in one click. You can also embed a Mockoon button in your API documentation if you want to offer the same feature to your users.",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "Thousands of mock samples and Mockoon's embedded button",
    "sectionAnchor": "thousands-of-mock-samples-and-mockoons-embedded-button",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#more-content-creation",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "After years of close to zero content writing, we made it one of our priority. After years of user support, it became clear that we needed more content to help our users getting started. So we worked hard to improve our documentation and FAQ and cover more topics.  We also have many tutorials and articles to help you get started with API mocking or tutorials specific to Mockoon. We also started covering simple API calls or creation with popular frameworks and languages. Two examples to illustrate this: Python/Flask API creation and Node.js API call using node-fetch.",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "More content creation",
    "sectionAnchor": "more-content-creation",
    "score": 6,
    "groupScore": 4
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#open-source-and-sponsorship",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "Mockoon is still, after five years, an open-source tool built by volunteer maintainers. In 2021, our main maintainer @255kb quit his job and decided to dedicate his whole time to Mockoon. We have long-term plans for Mockoon, but none of them are putting into question the open-source nature of the project.  So, to continue working on this project, we recently started looking for sponsors. And we were excited to announce in July that Mockoon was chosen by AppWrite as the first sponsored open-source project in their OSS Fund. AppWrite is now our first Platinum sponsor üí™  Appwrite logo  If you like our application, please consider sponsoring us too and join all the Sponsors and Backers who helped this project over time!  sponsor button",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "Open-source and sponsorship",
    "sectionAnchor": "open-source-and-sponsorship",
    "score": 6,
    "groupScore": 5
  },
  {
    "objectID": "/blog/celebrating-4000-github-stars/#new-enterprise-services",
    "title": "Celebrating 4000 GitHub stars üéâ",
    "category": "blog",
    "content": "As part of this search for sustainability, you may have noticed that we are now offering enterprise services: live support, applications deployment, bug prioritization, custom development, etc. Do not hesitate to reach out if your company needs such services.",
    "link": "/blog/celebrating-4000-github-stars/",
    "sectionTitle": "New enterprise services",
    "sectionAnchor": "new-enterprise-services",
    "score": 6,
    "groupScore": 6
  },
  {
    "objectID": "/blog/api-endpoints-filtering-improved-security/#0",
    "title": "New release with endpoints filtering and improved security",
    "category": "blog",
    "content": "Spring is here, and a new release of Mockoon üåª. It comes with a usual batch of bug fixes and minor improvements you can check on the GitHub release page.  There are also three new features and improvements that we want to share with you today.",
    "link": "/blog/api-endpoints-filtering-improved-security/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 6,
    "groupScore": 0
  },
  {
    "objectID": "/blog/api-endpoints-filtering-improved-security/#new-api-endpoints-filtering-feature",
    "title": "New release with endpoints filtering and improved security",
    "category": "blog",
    "content": "In this iteration, we worked on a long-awaited feature. Nothing big or complex, but one of those improvements that make developers' life easier: endpoints filtering. It was requested a lot as many of you have to scroll among many mock endpoints. Only one step to use it, start typing some text in the filtering input, and it will filter the API endpoints by path or documentation.  api endpoints filtering  We are already planning to improve this feature in the future, notably by adding keyboard shortcuts.",
    "link": "/blog/api-endpoints-filtering-improved-security/",
    "sectionTitle": "New API endpoints filtering feature",
    "sectionAnchor": "new-api-endpoints-filtering-feature",
    "score": 6,
    "groupScore": 1
  },
  {
    "objectID": "/blog/api-endpoints-filtering-improved-security/#improved-security",
    "title": "New release with endpoints filtering and improved security",
    "category": "blog",
    "content": "Even if invisible, the main focus of this release was the application security and Electron's best practices. After several weeks of work, Mockoon is now more secure by a combination of enabling Chrome sandboxing and Electron context isolation. Node.js integration has also been disabled, and we stopped relying on Electron's remote module in the renderer process.  These changes have been pushed by Electron's team, and some of them were enabled default in recent Electron releases. We took it on ourselves to follow all these best practices and rewrote a big part of the application architecture. The main idea was to stop using Node.js libraries and features like fs directly from the renderer and instead communicate with the main process through the Inter-Process Communication (IPC). The main process would then perform the requested task and send the result to the renderer process. This was not a small change and required a lot of testing.  Aside from the improved security and prevention of future vulnerabilities like XSS and RCE, we also saw slightly better performances overall.",
    "link": "/blog/api-endpoints-filtering-improved-security/",
    "sectionTitle": "Improved security",
    "sectionAnchor": "improved-security",
    "score": 6,
    "groupScore": 2
  },
  {
    "objectID": "/blog/api-endpoints-filtering-improved-security/#revamped-documentation",
    "title": "New release with endpoints filtering and improved security",
    "category": "blog",
    "content": "Lastly, we spent time rewriting the templating documentation to better explain how and where to use all the available helpers. We also documented all the helpers, including hidden ones as ipv4, tld, hexColor, etc.  Templating documentation is now split in four parts:  a global overview (how and where). the list of Mockoon's helpers. the list of Mockoon's request helpers. more information on how to use Faker.js library helpers.  On a lower level, we also split the route responses documentation to better surface the rules documentation. Again, this section is now split into two parts:  how to configure multiple responses. how to add rules with a slightly improved explanation on how rules are interpreted.",
    "link": "/blog/api-endpoints-filtering-improved-security/",
    "sectionTitle": "Revamped documentation",
    "sectionAnchor": "revamped-documentation",
    "score": 6,
    "groupScore": 3
  },
  {
    "objectID": "/articles/what-is-api-mocking/#0",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Designing, building, and testing applications consuming internal or third-party APIs are not always easy. You may hit some bottlenecks, like dependencies between teams, external API unavailable for testing, etc. Fortunately, API mocking is a technique that helps overcome these issues and speeds up development, accelerates third parties API integration, makes testing more flexible, and more.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 7,
    "groupScore": 0
  },
  {
    "objectID": "/articles/what-is-api-mocking/#what-is-api-mocking",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "API mocking is the action of simulating or imitating actual APIs by answering fake realistic responses to requests. It replaces APIs you cannot currently use because they are unavailable, down, or still under development. APIs could also be unavailable due to the context: like a restricted testing environment. It is also a fast and easy way to test your applications with the APIs you are integrating, without the hassles.  API mocking should strive to mimic the original API as close as possible. It also lets you go the extra mile by simulating more complex scenarios like failures or experimenting with new features.  client communicating with an API or a mock",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "What is API mocking?",
    "sectionAnchor": "what-is-api-mocking",
    "score": 7,
    "groupScore": 1
  },
  {
    "objectID": "/articles/what-is-api-mocking/#use-cases-why-do-we-need-mock-apis",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "API mocking is handy in a lot of scenarios:  during development to reduce dependencies between teams. to accelerate third parties API integration. during functional and integration testing. to test various advanced scenarios more easily. for demonstration purposes.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "Use cases: why do we need mock APIs?",
    "sectionAnchor": "use-cases-why-do-we-need-mock-apis",
    "score": 7,
    "groupScore": 2
  },
  {
    "objectID": "/articles/what-is-api-mocking/#api-mocking-during-development",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Mocking internal or third-parties APIs helps you accelerate your development lifecycles. For internal APIs that may still be under development, it helps reduce the dependencies between your development teams, like between front-end and back-end. You can also avoid relying on external APIs that can be subject to downtimes or require security credentials unpracticable during development.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "API mocking during development",
    "sectionAnchor": "api-mocking-during-development",
    "score": 7,
    "groupScore": 3
  },
  {
    "objectID": "/articles/what-is-api-mocking/#accelerating-third-party-apis-integration",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Thanks to API mocking, you can start working with third-party APIs in no time. Instead of registering for an account, configuring accesses, and provisioning tokens, you can mock the needed API endpoints and start using them in your front-end or back-end applications right away.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "Accelerating third-party APIs integration",
    "sectionAnchor": "accelerating-third-party-apis-integration",
    "score": 7,
    "groupScore": 4
  },
  {
    "objectID": "/articles/what-is-api-mocking/#api-mocking-for-integration-testing",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Some APIs may be unavailable or not easy to use in a testing environment. They may require extra setups or be limited to production environments.  API mocking gives you the flexibility you need to run complex integration tests for interconnected systems, microservices, or third-party APIs integrations. It allows you to run faster and more comprehensive tests that avoid relying on third-party APIs. It also enables you to cover more edge cases: slower response time, random failures, etc.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "API mocking for integration testing",
    "sectionAnchor": "api-mocking-for-integration-testing",
    "score": 7,
    "groupScore": 5
  },
  {
    "objectID": "/articles/what-is-api-mocking/#testing-advanced-scenarios",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Testing advanced scenarios and edge cases may require complex setup and data preparation. Working with a mock API can accelerate this process and allow you to directly serve realistic fake data (JSON, CSV, etc.) or error messages.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "Testing advanced scenarios",
    "sectionAnchor": "testing-advanced-scenarios",
    "score": 7,
    "groupScore": 6
  },
  {
    "objectID": "/articles/what-is-api-mocking/#api-mocking-during-demonstration-and-api-design",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Sometimes you have to make your APIs available to clients or users before they commit to using them. With API mocking, you can provide a simulation of the actual API for testing purposes without the need to give access to your product or provision credentials. Internal or pre-sales demos can benefit from API mocking in the same way. The design phase of an API (API UX research) can also benefit from API mocking, especially when doing user experience research or focus groups with your potential users. It allows you to seamlessly and quickly change and refine the API contract without waiting for a server deployment or the development team's availability.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "API mocking during demonstration and API design",
    "sectionAnchor": "api-mocking-during-demonstration-and-api-design",
    "score": 7,
    "groupScore": 7
  },
  {
    "objectID": "/articles/what-is-api-mocking/#how-does-api-mocking-work",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "API mocking is quite simple to put in place. The easiest way to start with API mocking is to use an online or local API mocking tool like Mockoon. After installing the tool and setting up some fake API endpoints, it will expose the mock API locally on a specific port. You will use this mock server in your application in place of the original API. So, you may have to change the URL and port to which your frontend or backend application are connecting during development.  The variety of tools can give a different kind of mocking experience. Here is a list of the most common differences:",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "How does API mocking work?",
    "sectionAnchor": "how-does-api-mocking-work",
    "score": 7,
    "groupScore": 8
  },
  {
    "objectID": "/articles/what-is-api-mocking/#online-vs-local",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Among all the API mocking tools available, we can distinguish two approaches. The online or cloud one, where you register on a website and configure a mock API using a web interface. Then, the tool exposes the fake API on a subdomain (e.g. temp-api123.mocking-tool.com). The advantage is the immediate availability of the mock for coworkers. The disadvantage is that your mock data resides in a third-party database which may not be an option depending on your industry (banking, health, etc.). Other tools like Mockoon are local tools, or desktop applications, that ensure a high level of confidentiality. They are also easy to set up and may make the mocking experience faster as no registration or deployment is needed. Mockoon's approach is to offer a lightweight desktop application packed with features coupled with a CLI to give you complete control over your mock experience.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "Online vs local",
    "sectionAnchor": "online-vs-local",
    "score": 7,
    "groupScore": 9
  },
  {
    "objectID": "/articles/what-is-api-mocking/#static-vs-dynamic-data",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "One important thing to not overlook when setting up a mock API is the realisticness of the data. Some mocking tools offer limited capabilities in terms of data dynamism and only allow for static JSON (or other data format) to be served as a response when calling your fake API endpoints. A tool that allows for dynamic and realistic data to be served is a must and ensures that you are testing your application with a realistic mock, close to what you will have in your production environment. Mockoon embarks on a templating system with which you can generate dynamic and realistic data.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "Static vs dynamic data",
    "sectionAnchor": "static-vs-dynamic-data",
    "score": 7,
    "groupScore": 10
  },
  {
    "objectID": "/articles/what-is-api-mocking/#advanced-scenarios",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "Realistic mock APIs do not stop with the data. The way the tool serves the responses is also an important thing to consider if you want to be able to test advanced scenarios or edge cases. For example, you may want to test errors (403, 404, etc.), or serve different responses depending on the presence of headers or request's body. Mockoon's offers various ways to cover these edge cases. A rule system to serve different responses depending on the entering request, and different serving modes, like random or sequential, to test against unexpected errors or downtimes.  Head over to Mockoon's getting started tutorial to set up your first mock API in less than 5 minutes!",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "Advanced scenarios",
    "sectionAnchor": "advanced-scenarios",
    "score": 7,
    "groupScore": 11
  },
  {
    "objectID": "/articles/what-is-api-mocking/#api-mocking-challenges",
    "title": "Mockoon's guide to API mocking",
    "category": "articles",
    "content": "While API mocking is easy to set up, it comes with some challenges. The biggest one is to create accurate enough mock APIs and maintain them up-to-date feature after feature. Nothing is more useless than mock API endpoints that are completely outdated.  Fortunately, with Mockoon, it is easy to share mock API configurations JSON files and add them to a Git repository. They can then easily be shared among coworkers and updated whenever needed.",
    "link": "/articles/what-is-api-mocking/",
    "sectionTitle": "API mocking challenges",
    "sectionAnchor": "api-mocking-challenges",
    "score": 7,
    "groupScore": 12
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#definition-of-a-rest-or-restful-api",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "As we saw in the previous part of this guide, there are many types of web APIs. What interests us most is one of the most popular implementations, the REST, or RESTful, API. REST stands for REpresentational State Transfer. It's a software architectural style that defines a set of constraints used to create standardized APIs. Web APIs adhering to the REST architectural constraints are called RESTful APIs.  RESTful APIs must follow six constraints: client-server architecture, statelessness, cacheability, layered system, code on demand, and uniform interface. We will see four of them, perhaps the most important.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "Definition of a REST (or RESTful) API",
    "sectionAnchor": "definition-of-a-rest-or-restful-api",
    "score": 7,
    "groupScore": 0
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#client-server-architecture",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "REST APIs are designed with a client-server architecture in mind, thus enforcing the principle of separation of concerns: separating the user interface from the data storage. It has various benefits, but one of the most prominent is the portability of both the UI and the server. Many UI can be implemented for one server (or consume one API), and the server can scale and evolve independently from the UI.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "Client-server architecture",
    "sectionAnchor": "client-server-architecture",
    "score": 7,
    "groupScore": 1
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#uniform-interface",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "The uniform interface constraint aims at simplifying and decoupling the architecture to enable each part to evolve independently. This concept includes four principles:  Resource identification in requests: The request should identify each resource. For RESTful web services, URIs are usually responsible for identifying resources. Resource manipulation through representations: The client should have enough information regarding the resource to be able to modify or delete it. Self-descriptive messages: Each message should include enough information to describe how to process it. Hypermedia as the engine of application state (HATEOAS): A REST client should be able to use server-provided links to discover all the available and related resources. The client shouldn't need to have a hard-coded structure of the resources.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "Uniform interface",
    "sectionAnchor": "uniform-interface",
    "score": 7,
    "groupScore": 2
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#statelessness",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "Statelessness means that the server or the API should retain no session information. Each transaction between the client and the server will contain the necessary data to be understood in isolation without the context from previous communications. The best example is the necessity to be authenticated to perform any change in the API or the data storage: each communication will contain the necessary credentials to authenticate the consumer.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "Statelessness",
    "sectionAnchor": "statelessness",
    "score": 7,
    "groupScore": 3
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#cacheability",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "To improve the API server scalability and performance, it must inform the client if the resource or data is cacheable or not. It prevents the client from using stale data, but it also allows it to reuse existing data again if it is still up-to-date, thus reducing the volume transferred.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "Cacheability",
    "sectionAnchor": "cacheability",
    "score": 7,
    "groupScore": 4
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#overview-of-a-rest-api-call",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "We learned that a REST API follows a set of architectural constraints, but let's have a look at the anatomy of a REST API call between a client and a server. An API call is always composed of a request and a response.  The request is sent by the client and received by the server. The response will be sent back to the client by the server after it has processed the request.  REST APIs communicate over HTTP/HTTPS the same as web browsers do. API calls look very similar to navigating web pages, which are, in the end, only GET requests on specific URLs.  API call schema with a request and a response",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "Overview of a REST API call",
    "sectionAnchor": "overview-of-a-rest-api-call",
    "score": 7,
    "groupScore": 5
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#the-request",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "An API request contains the following components:  a base URL, or resource path an HTTP method or verb (GET, POST, etc.) [headers] [a payload or body]  An HTTP API request or message is formatted like this:  POST /api/v2/users HTTP/1.1 Accept: application/json Content-Type: application/json  {   \"name\": \"Peter\" }  Or, in other words:  METHOD URL HTTP_VERSION HEADER_KEY_1: HEADER_VALUE_1 HEADER_KEY_2: HEADER_VALUE_2 BLANK_LINE BODY  As we will see in the third part of this guide, the method and URL are always present and mandatory. They identify the target endpoint requested by the client on the API server. On the contrary, the headers and body are optional. However, it's rare to have a request (or a response) without headers.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "The request",
    "sectionAnchor": "the-request",
    "score": 7,
    "groupScore": 6
  },
  {
    "objectID": "/articles/api-guide-what-are-rest-api/#the-response",
    "title": "Mockoon's API guide part 2: REST(ful) APIs",
    "category": "articles",
    "content": "After processing the request, the API server will send back a response to the client. It will contain the following information:  a status code [headers] [a payload or body]  HTTP/1.1 201 Created Content-Type: application/json  {   \"id\": 123456 }  Or, in other words:  HTTP_VERSION STATUS_CODE STATUS_NAME HEADER_KEY: HEADER_VALUE BLANK_LINE BODY  The only mandatory part is the status code. As for the request, a response may or may not contain headers and a body. Again, you probably won't see a response without headers anytime soon.  You probably already noticed some differences between requests and responses. Some components are present in both, like the headers and the body. In the last part of our guide, we will detail all these components: the request's method and URL, the response's status code, the headers, and the body, present in both the request and the response.",
    "link": "/articles/api-guide-what-are-rest-api/",
    "sectionTitle": "The response",
    "sectionAnchor": "the-response",
    "score": 7,
    "groupScore": 7
  },
  {
    "objectID": "/articles/api-guide-what-are-api/#0",
    "title": "Mockoon's API guide part 1: What are APIs?",
    "category": "articles",
    "content": "You heard about APIs, but you do not know what they are or where to start? This guide is for you.  APIs are everywhere, and they power almost all the internet. From weather forecasts to financial market data, nearly everything transits through APIs. It allows to disseminate data like never before and help developers build applications with reuse in mind instead of reinventing the wheel.",
    "link": "/articles/api-guide-what-are-api/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 7,
    "groupScore": 0
  },
  {
    "objectID": "/articles/api-guide-what-are-api/#what-is-an-api",
    "title": "Mockoon's API guide part 1: What are APIs?",
    "category": "articles",
    "content": "API is the acronym for Application Programming Interface. In contrast to a User Interface (UI) that connects a person to a computer, it's a software-to-software interface, or intermediary, enabling two applications to talk to each other.  machine to machine communication  APIs are not designed to be used by a person other than the developer using or implementing them. APIs are a way to expose a simple interface, a layer of abstraction, to interact with a more complex system without knowing its internal way of working.  APIs power web and mobile applications, desktop applications, internet of things. They are behind:  your Instagram application loading the latest posts your Amazon Ring doorbell your car info system fetching real-time transit data ...",
    "link": "/articles/api-guide-what-are-api/",
    "sectionTitle": "What is an API?",
    "sectionAnchor": "what-is-an-api",
    "score": 7,
    "groupScore": 1
  },
  {
    "objectID": "/articles/api-guide-what-are-api/#benefits-of-using-apis",
    "title": "Mockoon's API guide part 1: What are APIs?",
    "category": "articles",
    "content": "Increased possibilities: When building an application, we usually distinguish between its core functionality, the core business, and the rest. You may provide stock market information, but providing useful CSV reports by email or push notification alerts may not be a priority. You can choose to delay or even exclude the development of such features, or you can integrate third-party API services that will provide each of them, opening a world of possibilities. Speed up development: An application is always full of secondary features that are not necessarily part of your core product. Also, you may not have the resources or skills to build them. A good example is user authentication, which involves many security concepts: salt rotation, two-factor authentication, etc. Instead of reinventing the wheel and developing everything internally, you can outsource and trust a service provider and use its APIs. You can then focus on your core feature and thus speed up the development of your product. increased product quality: Focusing on your core business and delegating secondary features to external APIs is not only a question of speeding up development time. A lot of these secondary features may require a whole set of different skills and knowledge. Relying on external, tested, and proven APIs can also make your business more reliable. reduced costs: Less development work can reduce the cost of an application. But aside from the reduced development costs, using APIs also reduce the maintenance, testing, or even training, required.  There are many other benefits of using APIs: enabling mobile applications, increased security, reduced outages, etc. But you probably got the idea. One last remark: it's always a matter of choice between speeding up development and being locked with third-party vendors, the dreaded vendor lock-in!",
    "link": "/articles/api-guide-what-are-api/",
    "sectionTitle": "Benefits of using APIs",
    "sectionAnchor": "benefits-of-using-apis",
    "score": 7,
    "groupScore": 2
  },
  {
    "objectID": "/articles/api-guide-what-are-api/#web-apis",
    "title": "Mockoon's API guide part 1: What are APIs?",
    "category": "articles",
    "content": "APIs can take various forms, but we are more interested in web APIs for this guide. Web APIs are the ones that can be accessed over the web, frequently using the HTTP protocol. They involve a client, your browser, and a server. The client initiates the request and waits for a response from the server. The response can take a lot of forms, mostly structured data, but also images, text, videos, etc.  Web-based APIs are the most widely available type of APIs. But inside this broad category, we can still distinguish many types of architectures: REST APIs, SOAP APIs, GraphQL APIs, XML-RPC, WebSocket, etc. One of the most popular is the REST API, and it's the one we will see in detail in the rest of this guide. GraphQL APIs are also very popular while more recent than REST APIs. They propose a completely different way to query the data server. WebSocket is also widely used for two-way interactive communication between a client and a server, like real-time chat applications.",
    "link": "/articles/api-guide-what-are-api/",
    "sectionTitle": "Web APIs",
    "sectionAnchor": "web-apis",
    "score": 7,
    "groupScore": 3
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#components-of-a-rest-api-request-and-response",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "After seeing how an API call works, with a request and a response, in the second part of this guide, we will now see what are the request's and response's components: the request's method and URL, the response's status code, and the headers and body, present in both the request and the response.  REST API call payload components",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "Components of a REST API request and response",
    "sectionAnchor": "components-of-a-rest-api-request-and-response",
    "score": 7,
    "groupScore": 0
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#resource-url-request",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "The request will be made to a specific URL, endpoint, or resource path, using a specific method. While the URL identifies the resource you want to interact with (users, invoices, posts, etc.), the method will indicate to the server which type of action you want to perform on it.  You will find different approaches to defining resource URLs. The most common will probably be to use a self-descriptive name in its plural form, prefixed with one or more path sections (the \"api\" keyword, the API version, etc.) and followed by optional URL parameters to interact with a specific resource (a user, a post, etc.):  http://company.com/api/v2/users: all the users http://company.com/api/v2/users/:id: one user with a specific id http://company.com/api/v2/invoices: all the invoices http://company.com/api/v2/posts: all the posts ...  A best practice is to avoid verbs or actions like \"get\" or \"list\" in the URL. It is better to let the HTTP method describe what you want to do. So instead of http://company.com/api/v2/getUsers, prefer http://company.com/api/v2/users using the GET method.  You will also often find nested resources. They help fetch related resources like a user's posts or a post's comments. These types of URL endpoints usually look like this:  http://company.com/api/v2/users/:id/posts: all the posts from the user with a specific id http://company.com/api/v2/posts/:id/comments: all the comments for a post with a specific id",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "Resource URL (request)",
    "sectionAnchor": "resource-url-request",
    "score": 7,
    "groupScore": 1
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#method-request",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "To indicate to the server what action to perform on a specific resource, this resource URL will always be coupled to an HTTP verb or method. There are many methods: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.  The most used one are the following:  POST: create new resource(s) GET: retrieve resource(s) PUT: update existing resource(s) DELETE: remove existing resource(s)  They map to the corresponding CRUD operations: Create, Read, Update, Delete. Each method used in combination with a specific URL will result in a different action performed on the data. Let's see some examples:  GET http://company.com/api/v2/users: retrieve all the users' data GET http://company.com/api/v2/users/:id: retrieve a specific user's data by its id POST http://company.com/api/v2/users: create a new user PUT http://company.com/api/v2/users/:id: update a specific user's data by its id DELETE http://company.com/api/v2/users/:id: delete a specific user by its id  As you can imagine, depending on the amount of resources, APIs can expose many endpoints.",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "Method (request)",
    "sectionAnchor": "method-request",
    "score": 7,
    "groupScore": 2
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#status-code-response",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "The response will contain an important piece of information: the status code. It informs the consumer (the client) if the action was performed correctly or not on the requested resource. It varies not only depending on the success of the action, but also depending on its nature. More concretely, it's a number with three digits (between 100 and 599) with a name, like 200 Success, or 404 Not Found. There are many status codes grouped into five main categories: informational responses (1xx), successes (2xx), redirections (3xx), client errors (4xx), and server errors (5xx).  Let's see some API call scenarios with the corresponding ideal status code:  GET /users:users were successfuly retrieved: 200 OK consumer is not authenticated: 401 Unauthorized server is down: 503 Service Unavailable   GET /users/1234:users with id 1234 was not found: 404 Not Found   POST /users:new user was successfuly created: 201 Created  Have you noticed the difference between a successful GET (200 OK) and a successful POST (201 Created)? 200 and 201 belong to the same status codes category, \"successes\", but they also inform on the nature of the action. With this variety of statuses, applications can give more precise feedback to their users instead of relying on generic success or error messages.",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "Status code (response)",
    "sectionAnchor": "status-code-response",
    "score": 7,
    "groupScore": 3
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#headers",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "Both the request and response can contain one or more headers. You can see headers as labels, or metadata, giving the recipient (client or server) more information about the request or response.  They are usually different between request and response, and some headers don't make sense in a request and vice-versa. Among the most well-known, we can enumerate Content-Type, Authorization, Accept, Content-Length, Cache-Control, etc.  Let's see a typical API call with some headers:  Request:  GET http://company.com/api/v2/users HTTP1.1 Accept: application/json Authorization: Bearer 1234567890abcdef  Two headers are present here:  Accept: Indicate to the server in which format the response's payload (or body) should be sent. Here, we requested the data to be in JSON format. Authorization: This header will usually contain the authentication information (here, a bearer token) necessary for the server to identify the consumer and verify if it has access to the specific resource.  Response:  HTTP/1.1 200 OK Content-Type: application/json Content-Length: 105  [   {     \"id\": 1,     \"username\": \"john45\"   },   {     \"id\": 2,     \"username\": \"mary12\"   } ]  Again, two headers are present here, but they are different and only make sense in a response:  Content-Type: indicate to the client in which format the payload (or body) has been sent. Here, in JSON format. Content-Length: Indicate the length of the response body.  HTTP headers is a vast topic, and there are many headers that you can explore.",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "Header(s)",
    "sectionAnchor": "headers",
    "score": 7,
    "groupScore": 4
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#body-or-payload",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "As you may have noticed in the previous examples, requests and responses may or may not include a payload or body. The body is the actual piece of information you want to fetch or store and use or display in your application. It will have a different meaning depending on the context. It could be a list of users returned by the server after a GET request. It may also be a new user sent to the server in the request during a POST request. You understand now, both request and response can contain a body, but it doesn't make sense in some cases. Sometimes it is even highly discouraged and not part of the HTTP specification. It is the case for a GET request which should not contain a body. However, you will find implementations contradicting this.  Nowadays, the most widely used format for sending payloads is the JSON format. You will also find a lot of APIs making data available in XML.  As we saw previously, the body follows a blank line and is sent as plain text:  HTTP/1.1 200 OK Content-Type: application/json Content-Length: 105  [   {     \"id\": 1,     \"username\": \"john45\"   },   {     \"id\": 2,     \"username\": \"mary12\"   } ]",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "Body or payload",
    "sectionAnchor": "body-or-payload",
    "score": 7,
    "groupScore": 5
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#how-to-test-api-calls",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "Many options exist to make API calls. Among the most famous you will find cURL, a command-line tool, or Postman, a desktop application.  You will also frequently find APIs described or documented using the OpenAPI specification, which often leads to a publication of the API documentation using Swagger UI. A famous one is their demo API, the Pet store. Swagger UI allows you to discover API endpoints and their parameters but also directly make test calls.  When designing an API, it is a good practice to use the OpenAPI specification and publish the API documentation using a well-known tool. It will help developers to integrate and work with your API.",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "How to test API calls?",
    "sectionAnchor": "how-to-test-api-calls",
    "score": 7,
    "groupScore": 6
  },
  {
    "objectID": "/articles/api-guide-rest-api-components/#api-mocking",
    "title": "Mockoon's API guide part 3: REST APIs components",
    "category": "articles",
    "content": "During development, you may encounter blockers that will slow you down. For example, you may want to start connecting your front-end application with an API that your back-end team is currently working on. Or you would like to work with a third-party API (authentication, payment, weather or financial data, etc.) without too much hassle like creating an account or provision authentication tokens. API mocking is a technique that will allow you to work with an API by faking it. It helps you integrate an API without registering with the provider, provisioning a token, or waiting for another team to develop it. Thus vastly improving your developer experience and reducing development time.  Mockoon is here to help you start integrating APIs in no time by quickly mocking them locally. Head over to our getting started tutorial to learn how to mock your first API.  To learn more about API mocking in general, you can read our API mocking guide.",
    "link": "/articles/api-guide-rest-api-components/",
    "sectionTitle": "API mocking",
    "sectionAnchor": "api-mocking",
    "score": 7,
    "groupScore": 7
  },
  {
    "objectID": "/articles/api-glossary/#table-of-content",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "API (Application Programming Interface) Body Cache Client CORS (Cross-Origin Resouce Sharing) CRUD (Create Read Update Delete) Endpoint External API Header Internal API JSON API Key Methods (HTTP methods) API Mocking Path Parameters Query Parameters Request Response Resource REST API Route Server Status code (HTTP) URL (Uniform Resource Locator) Web API",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Table of content",
    "sectionAnchor": "table-of-content",
    "score": 7,
    "groupScore": 0
  },
  {
    "objectID": "/articles/api-glossary/#api-application-programming-interface",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "API is the acronym for Application Programming Interface. In contrast to a User Interface (UI) that connects a person to a computer, it's a software-to-software interface, or intermediary, enabling two applications to talk to each other. ‚Üí Learn more in our API guide  See also: Web API, REST API",
    "link": "/articles/api-glossary/",
    "sectionTitle": "API (Application Programming Interface)",
    "sectionAnchor": "api-application-programming-interface",
    "score": 7,
    "groupScore": 2
  },
  {
    "objectID": "/articles/api-glossary/#body",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "The body refers to the data transmitted in an API transaction in the request or the response. Requests and responses do not always contain a body. JSON is one of the most popular data formats to transfer data in the body",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Body",
    "sectionAnchor": "body",
    "score": 7,
    "groupScore": 4
  },
  {
    "objectID": "/articles/api-glossary/#cache",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "In an API, a cache is a system for storing and retrieving responses to avoid reprocessing requests that are frequent and identical. Multiple cache systems may coexist at different levels: clients (browsers), API gateways or proxies, servers, etc. Servers usually indicate to the client the caching policy of a request using headers.",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Cache",
    "sectionAnchor": "cache",
    "score": 7,
    "groupScore": 6
  },
  {
    "objectID": "/articles/api-glossary/#client",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A client is a piece of hardware or software that access services or resources made available by servers in a client-server model. It usually sends a request to the server, which processes it and returns a response. The client may access the server using a network, especially when the server is not on the same computer system. For example, a web browser is a client that connects to web servers to display web pages.  See also: Server",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Client",
    "sectionAnchor": "client",
    "score": 7,
    "groupScore": 7
  },
  {
    "objectID": "/articles/api-glossary/#cors-cross-origin-resouce-sharing",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "Cross-Origin Resource Sharing is an HTTP mechanism that allows a server to indicate the origins from which a browser is allowed to load resources. By default, cross-origin requests (originating from a different host than the one serving the API) are restricted, and only same-origin requests are allowed. Practically, for all non-simple requests (based on multiple criteria, like the HTTP method used, the presence of a JSON body, etc.), browsers send a pre-flight request using the OPTIONS HTTP method and read the response's headers (Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, etc.) to check if the server allows requests emanating from this specific host.",
    "link": "/articles/api-glossary/",
    "sectionTitle": "CORS (Cross-Origin Resouce Sharing)",
    "sectionAnchor": "cors-cross-origin-resouce-sharing",
    "score": 7,
    "groupScore": 8
  },
  {
    "objectID": "/articles/api-glossary/#crud-create-read-update-delete",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "CRUD is an acronym for Create, Read, Update, and Delete, four basic operations of persistent storages. It is usually used in the REST API world to describe a group of resource endpoints and HTTP methods matching each of the operations:  POST /resource for an operation Creating a resource. GET /resource for an operation Reading a resource. PUT /resource for an operation Updating a resource. DELETE /resource for an operation Deleting a resource.",
    "link": "/articles/api-glossary/",
    "sectionTitle": "CRUD (Create Read Update Delete)",
    "sectionAnchor": "crud-create-read-update-delete",
    "score": 7,
    "groupScore": 9
  },
  {
    "objectID": "/articles/api-glossary/#endpoint",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "An endpoint is a communication channel or a location where an API will receive requests for a specific resource. For example, in a REST API, accessing or modifying information related to users or invoices would be available on multiple /users or /invoices routes.",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Endpoint",
    "sectionAnchor": "endpoint",
    "score": 7,
    "groupScore": 11
  },
  {
    "objectID": "/articles/api-glossary/#external-api",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "An external API usually exposes a company's internal resources outside of the organization letting third-party companies and developers use the data, for example, to create new applications. They are usually subject to restrictions and may require a paid subscription.  See also: Internal API",
    "link": "/articles/api-glossary/",
    "sectionTitle": "External API",
    "sectionAnchor": "external-api",
    "score": 7,
    "groupScore": 12
  },
  {
    "objectID": "/articles/api-glossary/#header",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "HTTP headers are used to pass additional information with HTTP requests and responses. They take the form of a list of key-value pairs. Among the most used request headers:  Authorization: Bearer xxxxxxx: contains the API key or token used to authenticate and identify the client. Content-Type: application/json: indicates the mime type of the data sent in the request's body (application/json, text/html, etc.). Accept-Encoding: gzip, deflate, br: indicates the types of data encoding supported by the client.  Some widely used response headers:  Content-Type: application/json: indicates the mime type of the data sent in the response's body (application/json, text/html, etc.). Cache-Control: max-age=604800: to indicate the duration after which the response should be refreshed. Last-Modified: Fri, 24 June 2022 08:00:00 GMT: indicate the data when the resource was last modified.  ‚Üí Learn how to setup headers with Mockoon",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Header",
    "sectionAnchor": "header",
    "score": 7,
    "groupScore": 14
  },
  {
    "objectID": "/articles/api-glossary/#internal-api",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "An internal API provides resources within an organization's software system. They are usually consumed by internal applications and back-ends and are often used in micro-services architectures. Internal APIs target in-house services and developers and are an efficient way to share departments' data within the organization.  See also: External API",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Internal API",
    "sectionAnchor": "internal-api",
    "score": 7,
    "groupScore": 16
  },
  {
    "objectID": "/articles/api-glossary/#json",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "JSON is a data format using human-readable text to transmit data objects consisting of key-value pairs. It is a popular data format for web APIs used in the bodies of requests and responses of API transactions. A JSON example:  {   \"response\": \"success\",   \"status\": 200 }  ‚Üí Learn how to generate fake JSON with Mockoon",
    "link": "/articles/api-glossary/",
    "sectionTitle": "JSON",
    "sectionAnchor": "json",
    "score": 7,
    "groupScore": 18
  },
  {
    "objectID": "/articles/api-glossary/#api-key",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "An API key is a unique identifier used to authenticate and identify a user or an application accessing an API. Most APIs require their consumers (companies, developers, etc.) to register and request an API key as they are often paid products subjected to restrictions: consumer identification, volume billing, etc. API keys are frequently sent by the client along with the request in an Authorization header.",
    "link": "/articles/api-glossary/",
    "sectionTitle": "API Key",
    "sectionAnchor": "api-key",
    "score": 7,
    "groupScore": 20
  },
  {
    "objectID": "/articles/api-glossary/#methods-http-methods",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A request is always targeting an API route which comprises an HTTP verb or method, and a path. It indicates to the server what action the client intends to perform on a specific resource. There are multiple methods available: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.  The most used ones are the following and embody specific meanings in REST APIs:  POST: create a new resource GET: retrieve a resource PUT: update an existing resource DELETE: remove an existing resource  ‚Üí Learn more in our REST API guide  See also: CRUD",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Methods (HTTP methods)",
    "sectionAnchor": "methods-http-methods",
    "score": 7,
    "groupScore": 22
  },
  {
    "objectID": "/articles/api-glossary/#api-mocking",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "API mocking is the action of simulating or imitating actual APIs by answering fake realistic responses to requests. It replaces APIs you cannot currently use because they are unavailable, down, or still under development. APIs could also be unavailable due to the context: like a restricted testing environment. It is a fast and easy way to test your applications with the APIs you are integrating, without the hassles.  ‚Üí Learn more in our API mocking guide",
    "link": "/articles/api-glossary/",
    "sectionTitle": "API Mocking",
    "sectionAnchor": "api-mocking",
    "score": 7,
    "groupScore": 23
  },
  {
    "objectID": "/articles/api-glossary/#path-parameters",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A path parameter is a non-optional section of the route's path used as a placeholder populated with a value during a request. It allows the client to indicate the target of the request to the server. They are usually represented in API documentations between curly braces or preceded by a colon. For example, in /users/{id} or /users/:id, id is a path parameter indicating that the action targets a user with a specific id: /users/123. It is up to the API server to define which query parameters are available and needed.  See also: Query parameters",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Path Parameters",
    "sectionAnchor": "path-parameters",
    "score": 7,
    "groupScore": 25
  },
  {
    "objectID": "/articles/api-glossary/#query-parameters",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A query parameter is an optional parameter added by a client, placed after the route's path, and sent with the request. It allows the client to add more parameters to its request. They are separated from the path by an interrogation mark and represented as key-value pairs separated by ampersands. For example, in /users?filter=active&sort=asc, two query parameters are sent: a filter parameter set to active, and a sort parameter set to asc. It is up to the API server to define which query parameters are available and needed.  See also: Path parameters",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Query Parameters",
    "sectionAnchor": "query-parameters",
    "score": 7,
    "groupScore": 27
  },
  {
    "objectID": "/articles/api-glossary/#request",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A request is usually sent by a client connecting to an API server which will process it and send a response back to the client.  See also: Response",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Request",
    "sectionAnchor": "request",
    "score": 7,
    "groupScore": 29
  },
  {
    "objectID": "/articles/api-glossary/#response",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A response is built by a server after processing a request sent by the client. It usually contains the data requested by the client and information related to the execution of the request, like the status code.  See also: Request",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Response",
    "sectionAnchor": "response",
    "score": 7,
    "groupScore": 30
  },
  {
    "objectID": "/articles/api-glossary/#resource",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "In REST APIs, a resource is an object with a type, associated data, and optional sub-resources. They are usually interacted with individually or in collections through endpoints. For example, an object of type User, which can be read individually on the GET /users/{id} endpoint.  See also: CRUD",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Resource",
    "sectionAnchor": "resource",
    "score": 7,
    "groupScore": 31
  },
  {
    "objectID": "/articles/api-glossary/#rest-api",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "REST stands for REpresentational State Transfer. It's a software architectural style that defines a set of constraints used to create standardized APIs. Web APIs adhering to the REST architectural constraints are called RESTful APIs. RESTful APIs must follow six constraints: client-server architecture, statelessness, cacheability, layered system, code on demand, and uniform interface.  ‚Üí Learn more in our REST API guide",
    "link": "/articles/api-glossary/",
    "sectionTitle": "REST API",
    "sectionAnchor": "rest-api",
    "score": 7,
    "groupScore": 32
  },
  {
    "objectID": "/articles/api-glossary/#route",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "In REST APIs, routes are couples of HTTP methods and paths of an API, usually representing a action to be performed on a specific resource. For example, accessing information about the users or invoices would be done on routes named after the resources using the GET method: GET company.com/api/users or GET company.com/api/invoices.  See also: CRUD",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Route",
    "sectionAnchor": "route",
    "score": 7,
    "groupScore": 33
  },
  {
    "objectID": "/articles/api-glossary/#server",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A server is a piece of hardware or software providing functionalities to other programs or devices called clients. In a client-server architecture, servers can provide different functionalities or services, such as providing resources or content. Client-server systems usually implement a request-response model where the client sends a request to the server, and the server returns a response to the client after performing a server-side action.  See also: Client",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Server",
    "sectionAnchor": "server",
    "score": 7,
    "groupScore": 35
  },
  {
    "objectID": "/articles/api-glossary/#status-code-http",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "An HTTP status code is added to the response by the server to indicate to the client the status of its request without having to further analyze the other response's components (headers, body, etc.). The status code varies depending on the success of the action but also on its nature. More concretely, it's a number with three digits (between 100 and 599) associated with a name: 200 Success, 404 Not Found, etc. There are many status codes grouped into five main categories: informational responses (1xx), successes (2xx), redirections (3xx), client errors (4xx), and server errors (5xx).  ‚Üí Learn more in our API guide",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Status code (HTTP)",
    "sectionAnchor": "status-code-http",
    "score": 7,
    "groupScore": 36
  },
  {
    "objectID": "/articles/api-glossary/#url-uniform-resource-locator",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "A URL is a reference to a web resource specifying its location on a network and a mechanism to retrieve this resource. A typical URL, like https://company.com/api/users, contains multiple information:  The protocol used to reach the resource: HTTPS. The hostname: company.com. A path to the resource: /api/users.",
    "link": "/articles/api-glossary/",
    "sectionTitle": "URL (Uniform Resource Locator)",
    "sectionAnchor": "url-uniform-resource-locator",
    "score": 7,
    "groupScore": 38
  },
  {
    "objectID": "/articles/api-glossary/#web-api",
    "title": "Mockoon's APIs glossary",
    "category": "articles",
    "content": "Web APIs are a specific type of APIs that can be accessed over the web, frequently using the HTTP protocol. They usually involve a client (your browser) and a server exposing resources publicly.  ‚Üí Learn more in our API guide  See also: REST API",
    "link": "/articles/api-glossary/",
    "sectionTitle": "Web API",
    "sectionAnchor": "web-api",
    "score": 7,
    "groupScore": 40
  },
  {
    "objectID": "/tutorials/vuejs-api-call-and-mocking/#0",
    "title": "Call a mock REST API from your Vue.js application",
    "category": "tutorials",
    "content": "This tutorial will show you how to call a REST API from a simple Vue.js application created with the create-vue scaffolding tool. If you already have an existing API that you want to call from your application, you can skip the first step, in which we will create a fake REST API using Mockoon.",
    "link": "/tutorials/vuejs-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/vuejs-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock REST API from your Vue.js application",
    "category": "tutorials",
    "content": "When working on your Vue.js single page application, you may need to mock an API that is still under development, or that is only partially available. The easiest way to start working without having to wait is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of fake blog posts with a single title. In Mockoon, create a GET /posts API route that returns an array of blog posts:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock API server will be available at the following URL: http://localhost:3000. It is the URL we will need to use in our Vue.js component.",
    "link": "/tutorials/vuejs-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/vuejs-api-call-and-mocking/#2-preparing-our-vuejs-component",
    "title": "Call a mock REST API from your Vue.js application",
    "category": "tutorials",
    "content": "For this tutorial, we created a new Vue.js application using the official scaffolding tool: npm init vue@latest. We answered \"no\" to all the questions to keep the setup simple.  In the rest of this tutorial, we will use the main ./src/App.vue file that was automatically created. First, let's \"clean\" the component a bit by removing the demo content. We will remove the imports and most of the HTML:  <script>   /* Remove imports */ </script>  <template>   <!-- <header>...</header> -->    <main>     <!-- Remove <TheWelcome /> -->   </main> </template>",
    "link": "/tutorials/vuejs-api-call-and-mocking/",
    "sectionTitle": "2. Preparing our Vue.js component",
    "sectionAnchor": "2-preparing-our-vuejs-component",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/vuejs-api-call-and-mocking/#3-make-a-call-to-the-api-endpoint-in-your-vuejs-component",
    "title": "Call a mock REST API from your Vue.js application",
    "category": "tutorials",
    "content": "After preparing our ./src/App.vue component and creating a mock REST API endpoint in Mockoon, you can now call it from your component.  To make an AJAX call to an API, we need to use a library or the browser's built-in window.fetch function. We will be using the fetch function as it is available in most browsers.  You will find below the minimal code needed to call our API endpoint with this function:  fetch('http://localhost:3000/posts')   .then((res) => res.json())   .then((posts) => {     // we received our list of posts     console.log(posts);   });  We need to integrate this code into our component. However, we need to first prepare the initial reactive state (data) for our posts, and a created method using Vue's Options API, in which we will fetch our data at component's creation time.  <script>   export default {     data() {       return {         posts: []       };     },     created() {       // we will fetch our posts here, when the component is created     }   }; </script>",
    "link": "/tutorials/vuejs-api-call-and-mocking/",
    "sectionTitle": "3. Make a call to the API endpoint in your Vue.js component",
    "sectionAnchor": "3-make-a-call-to-the-api-endpoint-in-your-vuejs-component",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/vuejs-api-call-and-mocking/#4-fetch-the-data-and-store-the-result-in-the-reactive-state",
    "title": "Call a mock REST API from your Vue.js application",
    "category": "tutorials",
    "content": "We can now add our fetch function to the created method and store the result in the component's state:  <script>   export default {     data() {       return {         posts: []       };     },     created() {       fetch('http://localhost:3000/posts')         .then((res) => res.json())         .then((posts) => {           // store the posts in the reactive state           this.posts = posts;         });     }   }; </script>",
    "link": "/tutorials/vuejs-api-call-and-mocking/",
    "sectionTitle": "4. Fetch the data and store the result in the reactive state",
    "sectionAnchor": "4-fetch-the-data-and-store-the-result-in-the-reactive-state",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/vuejs-api-call-and-mocking/#5-use-the-posts-state-variable-in-your-components-template",
    "title": "Call a mock REST API from your Vue.js application",
    "category": "tutorials",
    "content": "We can now render our blog posts on the page as <li> using a v-for directive:  <template>   <main>     <ul>       <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>     </ul>   </main> </template>  Putting all this code together, we get a fully functional component loading asynchronous mock data:  <script>   export default {     data() {       return {         posts: []       };     },     created() {       fetch('http://localhost:3000/posts')         .then((res) => res.json())         .then((posts) => {           // store the posts in the reactive state           this.posts = posts;         });     }   }; </script>  <template>   <main>     <ul>       <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>     </ul>   </main> </template>",
    "link": "/tutorials/vuejs-api-call-and-mocking/",
    "sectionTitle": "5. Use the `posts` state variable in your component's template",
    "sectionAnchor": "5-use-the-posts-state-variable-in-your-components-template",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#0",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "Data buckets were introduced in Mockoon's v1.21.0. They are persisting key-value stores that allow you to reuse data across your routes and body responses. You can reuse the data buckets content wherever the templating helpers are available: headers, body responses, file paths, etc. Although, their state persist between calls, which allow for more realistic behaviors and dynamic configuration of your responses.",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#what-are-data-buckets",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "A data bucket is a key-value store where you can define some string content that you can reuse in multiple route responses.  They are stored at the environment level and generated when the server starts or sometimes after the first call (see below). A data bucket content persists between mock API calls. So, they are the perfect way to create JSON \"databases\" to be reused in your routes.  Let's see the steps required to create data buckets and use them.",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "What are data buckets?",
    "sectionAnchor": "what-are-data-buckets",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#how-to-create-a-data-bucket",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "To create a new data bucket, open the Data options by clicking on the tab at the top of the window:  Open data bucket view  Add a new data bucket by clicking on the \"plus\" button:  Add a data bucket  You can personalize your data bucket title and content on the right part of the screen. Mockoon will automatically attribute a new unique ID to your data bucket. You can use this ID to reference the data using the data helpers (see below). To retrieve a bucket's unique ID, look in the footer under the data bucket content or right-click on a bucket name in the list and click on \"Copy ID to clipboard\".  Data buckets can contain any type of text content. They also support all of Mockoon's templating helpers. If your data bucket contains valid JSON, Mockoon will parse it to let you access the JS object, array, primitives, etc., using the templating helpers like (data, each, if, etc.).",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "How to create a data bucket?",
    "sectionAnchor": "how-to-create-a-data-bucket",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#data-bucket-generation-time",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "Mockoon usually generates data buckets when the server starts. Their state will persist until the next restart, so you can always expect the same content to be returned.  For example, if your data bucket contains the following JSON:  {   \"uuid\": \"{{faker 'string.uuid'}}\",   \"firstName\": \"{{faker 'person.firstName'}}\",   \"lastName\": \"{{faker 'person.lastName'}}\" }  The following content (or a variant of it) will be generated when the server starts, and will never change:  {   \"uuid\": \"e037ced5-997b-4756-8ae4-cc9c077ef214\",   \"firstName\": \"Jeromy\",   \"lastName\": \"Walker\" }  However, some buckets may not be generated at the server starting time. It is the case when the bucket contains at least one request helper. Request helpers are templating helpers that can only work in the context of an entering request. The required information to correctly evaluate the request helpers are not available when the server starts.  When Mockoon detects that a data bucket contains some request helpers, it will get ignored and won't be generated at server start. During the first request pointing to a route using the data bucket, it will generate it. The data buckets generated at request time are those directly linked to the endpoint response or used through helpers.  This mechanism allows you to use the request helpers and create data bucket configuration routes (see below).",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "Data bucket generation time",
    "sectionAnchor": "data-bucket-generation-time",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#link-a-data-bucket-to-a-response",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "You can directly link a data bucket to a route response or even multiple responses. Like this, it's easy to reuse the same content across multiple routes.  To link a data bucket to a route response, click on the \"Data\" button in the body selector and select your data bucket:  Using data bucket in a route response  Linking a data bucket to a route response will serve the content of the bucket \"as-is\".  The Content-Type of the response will still be the one you defined in the header.",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "Link a data bucket to a response",
    "sectionAnchor": "link-a-data-bucket-to-a-response",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#retrieve-a-data-buckets-content-with-the-templating-helpers",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "Aside from linking data buckets directly to your route responses, you can also use their contents with the two dedicated helpers: data and dataRaw. Head over to their respective documentation to understand how they work.  You can use these helpers anywhere templating is supported: body editor, file path, headers keys, values, etc. It allows you to define small reusable contents, like a file path, an API key, or a header value.  Both helpers support retrieving the data bucket by its unique ID or name. If your data bucket contains valid JSON, the helpers also allow you to retrieve only part of the object using an optional path:  {{data 'ID_or_name' 'object.path'}}  Let's consider the generated data bucket's content in the previous example:  {   \"uuid\": \"e037ced5-997b-4756-8ae4-cc9c077ef214\",   \"firstName\": \"Jeromy\",   \"lastName\": \"Walker\" }  Using the data helper like this, {{data 'ID_or_name'}}, would return the full content of the bucket, stringified. While using it with a path, {{data 'ID_or_name' 'uuid'}}, would give you only the uuid key's value inside the object.  You could also use the dataRaw helper to access the underlying JS object parsed from the JSON content. Using the \"raw\" version of the helper allows you to use arrays, objects, and primitives in combination with other helpers, like repeat, each, oneOf, etc.  [   {{#each (dataRaw 'abcd' 'obj.array')}}   {     \"value\": \"{{this}}\"   }   {{/each}} ]",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "Retrieve a data bucket's content with the templating helpers",
    "sectionAnchor": "retrieve-a-data-buckets-content-with-the-templating-helpers",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/use-persisting-data-buckets/#create-a-data-bucket-configuration-route",
    "title": "Use persisting data buckets to share data across routes",
    "category": "tutorials",
    "content": "Data buckets containing request helpers will only be generated during the first call to a route referencing them (directly or using them through the helpers). It allows you to create a configuration route for your bucket that you can use once to generate the bucket's content.  Let's say we have a route GET /users linking to a data bucket containing the following content:  [   {{# repeat (queryParamRaw 'total') }}   {     \"{{queryParamRaw 'firstKey'}}\": \"{{faker (queryParamRaw 'firstValue')}}\",     \"{{queryParamRaw 'secondKey'}}\": \"{{faker (queryParamRaw 'secondValue')}}\"   }   {{/ repeat }} ]  After starting the mock server, we can call the following endpoint:  GET http://localhost:3001/posts1?firstKey=firstName&firstValue=person.firstName&secondKey=email&secondValue=internet.email&total=10  The queryParamRaw helper will retrieve the values passed in the query string, and your bucket will be generated accordingly. Here, we choose to generate 10 items, with a first name and an email. We could then get this kind of content after subsequent calls to routes using the data bucket:  [   { \"firstName\": \"Anastasia\", \"email\": \"Delbert_Stracke80@hotmail.com\" },   { \"firstName\": \"Camilla\", \"email\": \"Margret53@gmail.com\" },   { \"firstName\": \"Maya\", \"email\": \"Crystel_Grady67@hotmail.com\" },   { \"firstName\": \"Demario\", \"email\": \"Hudson_Hirthe2@gmail.com\" },   { \"firstName\": \"Viola\", \"email\": \"Michael.Vandervort@hotmail.com\" },   { \"firstName\": \"Okey\", \"email\": \"Derrick.Bernier94@hotmail.com\" },   { \"firstName\": \"Mertie\", \"email\": \"Eva_Rempel76@yahoo.com\" },   { \"firstName\": \"Stella\", \"email\": \"Daron.West58@hotmail.com\" },   { \"firstName\": \"Nicola\", \"email\": \"Chris21@hotmail.com\" },   { \"firstName\": \"Hailey\", \"email\": \"Adaline.Kihn57@gmail.com\" } ]",
    "link": "/tutorials/use-persisting-data-buckets/",
    "sectionTitle": "Create a data bucket configuration route",
    "sectionAnchor": "create-a-data-bucket-configuration-route",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#0",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "Mockoon is a set of free and open-source API mocking tools. They help you get ready to work in no time. Should you be a front-end or back-end developer or a QA tester, Mockoon got you covered with a flexible user interface and a CLI that allows you to bring your mocking scenarios on servers and headless environments.  This tutorial will help you put up on track with the CLI and all its possibilities.  üìò To learn more about APIs and API mocking in general, head over to our API guide or API mocking guide",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#what-is-mockoon-cli",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "Mockoon CLI is an NPM package that can run on all environments where Node.js is installed. A Docker image and a GitHub Action are also available (see below).  The CLI is a companion application to Mockoon's main interface and is designed to launch one or more Mockoon data file.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "What is Mockoon CLI?",
    "sectionAnchor": "what-is-mockoon-cli",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#how-to-use-the-cli",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "As Mockoon CLI is designed to work in pair with the main user interface, you will learn how to create your first mock API and how to use the mock data with the CLI.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "How to use the CLI?",
    "sectionAnchor": "how-to-use-the-cli",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#step-1-create-a-mock-api-using-mockoon-interface",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "One of the prerequisites for using the CLI is to create a mock API in the main application. If you already have a setup in Mockoon, you can jump straight to the next section.  üöÄ To create a new mock API, we have a Getting started tutorial that will guide you step by step. Once your mock is created, come back to this tutorial to learn how to use it in the CLI.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Step 1. Create a mock API using Mockoon interface",
    "sectionAnchor": "step-1-create-a-mock-api-using-mockoon-interface",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#step-2-install-the-cli",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "Before importing your mock API in the CLI, you must install it. First ensure that Node.js is installed on your computer by running node -v in your terminal:  $ node -v v20.0.0  If it's not installed, head over to Node.js' download page and follow the instructions for your operating system.  You are now ready to install the CLI by running the following command npm i -g @mockoon/cli:  $ npm i -g @mockoon/cli  + @mockoon/cli@4.0.0 added 423 packages from 339 contributors in 15s  You can also install Mockoon CLI in the scope of a local project by running npm i @mockoon/cli. You will then need to use npx mockoon-cli ... to run it.  üóíÔ∏è A note about Mockoon versions: starting with release v3.0.0, all our applications are released with the same version number. This makes it easier to understand which version of the CLI is compatible with the desktop application.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Step 2. Install the CLI",
    "sectionAnchor": "step-2-install-the-cli",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#step-3-prepare-your-data-file",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "The CLI can open and migrate data from older versions of Mockoon. However, it doesn't alter the file you provide and only migrates the environment in-memory. If you created your mock with a more recent version of the application, you need to update your CLI with the following command: npm install -g @mockoon/cli@{version}.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Step 3. Prepare your data file",
    "sectionAnchor": "step-3-prepare-your-data-file",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#provide-a-mockoons-environment-file",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "You can run your mock in one single step by providing the actual location of your Mockoon environment file. To locate your environment file from the main application, right-click on an environment and select \"Show in folder\" in the context menu:  show in folder menu entry  Let's pretend your file name is data.json and resides in the current directory.  As an alternative, you can also provide a URL pointing to a Mockoon environment file, and Mockoon CLI will take care of downloading it.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Provide a Mockoon's environment file",
    "sectionAnchor": "provide-a-mockoons-environment-file",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#use-an-openapi-specification-file",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "Another option is to directly pass an OpenAPI specification file. It's useful to quickly run a mock API from a publicly available specification. Mockoon supports both JSON and YAML formats in versions 2.0.0 and 3.0.0. We also offer thousands of ready to use OpenAPI specifications on our mock samples directory.  As above, you can provide a path to a local OpenAPI specification file or directly the file's URL.  ‚ö†Ô∏è There is currently no equivalent between all the OpenAPI specifications and Mockoon's features (more info). If you want to run your Mockoon mock APIs with the CLI with all the features (templating, rules, etc.), you must use Mockoon's data files (see above) directly, or you may lose part of your mock's behavior.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Use an OpenAPI specification file",
    "sectionAnchor": "use-an-openapi-specification-file",
    "score": 9,
    "groupScore": 7
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#step-4-start-you-mock-api",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "After locating your environment file, you are ready to run your API mock with the CLI.  In your terminal, navigate to the folder where your Mockoon's data file or OpenAPI file is and run the following command:  mockoon-cli start --data ./data.json  Or:  mockoon-cli start --data ./openapi-spec.yaml  If you want to use a remotely hosted files, you can also provide a URL to the --data flag like this:  mockoon-cli start --data https://domain.com/data.json  You can also provide multiple parameters to customize your mock:  --port: to override the port on which the mock API will listen. --hostname: to override the hostname on which the mock API will listen.  You will find more information regarding the start command, including all the available flags on the official repository.  Your mock API will then be available on the port you specified and running as a foreground process:  $ mockoon-cli start --data ./data.json --port 3000 {\"level\": \"info\", \"environmentName\":\"Demo API\", \"message\":\"Server started on port 3000\"} {\"level\": \"info\", \"environmentName\":\"Demo API\", \"message\":\"Transaction recorded\", \"requestMethod\":\"GET\", \"requestPath\":\"/test\", \"responseStatus\":200}  It's also possible to run multiple mocks at the same time by providing multiple data files, ports and hostnames:  $ mockoon-cli start --data ./data1.json ./data2.json https://example.com/data3.json --port 3000 3001 3002 {\"level\": \"info\", \"environmentName\":\"Demo API 1\", \"message\":\"Server started on port 3000\"} {\"level\": \"info\", \"environmentName\":\"Demo API 2\", \"message\":\"Server started on port 3001\"} {\"level\": \"info\", \"environmentName\":\"Demo API 3\", \"message\":\"Server started on port 3002\"}",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Step 4. Start you mock API",
    "sectionAnchor": "step-4-start-you-mock-api",
    "score": 9,
    "groupScore": 8
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#step-5-view-a-running-mocks-logs",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "In addition to stdout (console), Mockoon CLI logs all events like requests and errors in your user folder in the following file: ~/.mockoon-cli/logs/{mock_name}.log.  This file contains all the log entries (all levels) produced by the running mock server. Most of the errors occurring in Mockoon CLI (or the main application) are not critical and therefore considered as normal output. As an example, if the JSON body from an entering request is erroneous, Mockoon will log a JSON parsing error, but it won't block the normal execution of the application.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Step 5. View a running mock's logs",
    "sectionAnchor": "step-5-view-a-running-mocks-logs",
    "score": 9,
    "groupScore": 9
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#using-the-generic-docker-image-published-on-docker-hub",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "A generic Docker image mockoon/cli is automatically built upon each release on Docker Hub's Mockoon CLI repository. It uses a node:18-alpine image and installs the latest version of Mockoon CLI.  All of mockoon-cli start flags (--port, etc.) must be provided when running the container.  To load a data file, you can either mount a local file and pass mockoon-cli start flags at the end of the command:  docker run -d --mount type=bind,source=./data.json,target=/data,readonly -p 3000:3000 mockoon/cli:latest -d data -p 3000  Or directly pass a URL to the mockoon-cli start command:  docker run -d -p 3000:3000 mockoon/cli:latest -d https://raw.githubusercontent.com/mockoon/mock-samples/main/samples/generate-mock-data.json -p 3000",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Using the generic Docker image published on Docker Hub",
    "sectionAnchor": "using-the-generic-docker-image-published-on-docker-hub",
    "score": 9,
    "groupScore": 11
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#using-the-dockerize-command",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "Mockoon CLI also offers a dockerize command that allows you to build a self-contained image. This command copies all the environment data files and generates a Dockerfile. After building the image, no Mockoon CLI-specific parameters will be needed at runtime.  Run the dockerize command:  mockoon-cli dockerize --data ./data1.json ./data2.json --port 3000 3001 --output ./tmp/Dockerfile  Then, navigate to the tmp folder, where the Dockerfile has been generated, and build the image:  docker build -t mockoon-image .  You can finally run your container:  docker run -d -p 3000:3000 -p 3001:3001 mockoon-image",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Using the dockerize command",
    "sectionAnchor": "using-the-dockerize-command",
    "score": 9,
    "groupScore": 12
  },
  {
    "objectID": "/tutorials/run-mock-api-anywhere-cli/#step-7-use-mockoon-cli-in-a-ci-environment-github-actions",
    "title": "Run your mock REST APIs anywhere with Mockoon CLI",
    "category": "tutorials",
    "content": "Mockoon CLI being a Javascript application, it can run on any environment where Node.js is installed, including continuous integration systems like GitHub Actions or CircleCI. It is useful when you want to run a mock server while running integration tests on another application. For example, you could mock the backend when running a React front-end application tests.  We published a GitHub Action that allows you to run Mockoon CLI in your GitHub Actions workflows.  Here is an example of a GitHub Action running a mock API before running some tests:  name: Run mock API server on:   push:     branches:       - main  jobs:   test:     runs-on: ubuntu-latest      steps:       - uses: actions/checkout@v3       - name: Use Node.js         uses: actions/setup-node@v3         with:           node-version: 18       - name: Start Mockoon CLI         uses: mockoon/cli-action@v1         with:           # Mockoon CLI version, default to 'latest'           version: 'latest'           # Mockoon local data file or URL           data-file: './data.json'           # port, default to 3000           port: 3000       - name: Make test call         run: curl -X GET http://localhost:3000/endpoint       - name: Run tests         run: npm run test  üí° If you are building your own actions with the CLI, do not forget to add an & at the end of the command to run it in the background: mockoon-cli start -d ./data-file.json &.",
    "link": "/tutorials/run-mock-api-anywhere-cli/",
    "sectionTitle": "Step 7. Use Mockoon CLI in a CI environment: GitHub Actions",
    "sectionAnchor": "step-7-use-mockoon-cli-in-a-ci-environment-github-actions",
    "score": 9,
    "groupScore": 13
  },
  {
    "objectID": "/tutorials/responses-and-rules/#0",
    "title": "Route responses and rules",
    "category": "tutorials",
    "content": "This tutorial will show you how to create route responses in Mockoon and use the rules system to serve them depending on conditions.  View the video version button  To learn more about APIs and API mocking in general, head over to our API guide or API mocking guide    For each of Mockoon‚Äôs API endpoints, you can define multiple responses with specific characteristics like status, body, and headers and serve them using a set of rules. In this tutorial, we will create a typical setup: one response returning a 200 status code and another one returning a 401 status code when the \"Authorization\" header is not present in the request.",
    "link": "/tutorials/responses-and-rules/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/responses-and-rules/#step-1-create-a-new-route",
    "title": "Route responses and rules",
    "category": "tutorials",
    "content": "The first step is to create a new route by clicking on the blue \"Add route\" button.  Add a route by clicking on the add route button  When you create a new endpoint, there is always at least one default response with a 200 status code.  Responses menu with the default response  We can customize its body with a simple JSON object.  Responses menu with the default response",
    "link": "/tutorials/responses-and-rules/",
    "sectionTitle": "Step 1. Create a new route",
    "sectionAnchor": "step-1-create-a-new-route",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/responses-and-rules/#step-2-add-a-401-unauthorized-response",
    "title": "Route responses and rules",
    "category": "tutorials",
    "content": "The next step is to add a second response returning a 401 status code when the \"Authorization\" header is missing from the request.  To add a new response, click on the blue \"plus\" button next to the response list.  Add a response by clicking on the plus button  You can also duplicate a response or delete it by clicking the buttons on the right.  The blue flag in the menu indicates which response will be served by default when no rule matches or when rules are disabled. We will keep the flag on our 200 \"success\" response.  Blue flag icon indicates the default response  The next step is to customize our response. Let‚Äôs change the status code to 401 \"Unauthorized\" and add a description: \"Error unauthorized\". Here too, we can customize the body with a simple JSON object.  customize the response by changing the status code and adding documentation",
    "link": "/tutorials/responses-and-rules/",
    "sectionTitle": "Step 2. Add a \"401 Unauthorized\" response",
    "sectionAnchor": "step-2-add-a-401-unauthorized-response",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/responses-and-rules/#step-3-add-a-rule",
    "title": "Route responses and rules",
    "category": "tutorials",
    "content": "The final step is to add a rule on the new response to serve it only when the \"Authorization\" header is missing.  Click on the rules tab and on the \"Add rule\" button.  Add a new rule by clicking on the rule tab and the green add rule button  In the new rule, select \"Header\" and enter \"Authorization\" as the \"Header name\".  Finally, select \"null\" as the value instead of \"equals\".  Customize the rule by entering its target, name and value  You can now test your setup by calling your mock API with and without an Authorization header.  $ curl http://localhost:3000/ -i HTTP/1.1 401 Unauthorized Content-Type: application/json; charset=utf-8 Content-Length: 25 Date: Tue, 07 Feb 2023 15:07:59 GMT Connection: keep-alive Keep-Alive: timeout=5  {   \"response\": \"error\" }  $ curl http://localhost:3000/ -i -H \"Authorization:abcd\" HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 27 Date: Tue, 07 Feb 2023 15:04:58 GMT Connection: keep-alive Keep-Alive: timeout=5  {   \"response\": \"success\" }",
    "link": "/tutorials/responses-and-rules/",
    "sectionTitle": "Step 3. Add a rule",
    "sectionAnchor": "step-3-add-a-rule",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/responses-and-rules/#step-4-route-responses-options",
    "title": "Route responses and rules",
    "category": "tutorials",
    "content": "Three options are also available next to the responses list: random, sequential, and rules disabled.  Three buttons allows for random or sequential responses, or rules disabling  You can randomize the responses with the first option or cycle through them sequentially with the second. Both options will disable the rules. The third option allows you to disable the rules and always serve the default response marked with a blue flag.",
    "link": "/tutorials/responses-and-rules/",
    "sectionTitle": "Step 4. Route responses options",
    "sectionAnchor": "step-4-route-responses-options",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/responses-and-rules/#step-5-learn-more",
    "title": "Route responses and rules",
    "category": "tutorials",
    "content": "Now that you know how to create basic rules, you can head over to the responses and rules documentation to explore the functionality.",
    "link": "/tutorials/responses-and-rules/",
    "sectionTitle": "Step 5. Learn more",
    "sectionAnchor": "step-5-learn-more",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/requests-recording-auto-mocking/#0",
    "title": "Record API requests and HTTP traffic and auto-mock endpoints",
    "category": "tutorials",
    "content": "When working on an application, you may want to use a mock API to speed up the development. But we all want to avoid the hassle of creating most of the endpoints manually.  What if you could record all the HTTP calls made to a server and easily create mocks for them? Good news, Mockoon got you covered!  By using Mockoon's request recording feature, you can intercept all the entering request to your mock server and create the corresponding endpoint automatically.  Another useful usage of this feature is to be able to quickly investigate bugs and communication problems by looking at the exact payload of a request.  Let's have a look on how this feature works.  To learn more about APIs and API mocking in general, head over to our API guide or API mocking guide",
    "link": "/tutorials/requests-recording-auto-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/requests-recording-auto-mocking/#step-1-open-the-requests-recording-page",
    "title": "Record API requests and HTTP traffic and auto-mock endpoints",
    "category": "tutorials",
    "content": "The first step is to create a new API in Mockoon or use one you already have and run it by clicking on the green \"play\" button.  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    As soon as you have your mock API running, open the requests logging page by clicking on \"Logs\" tab at the top of the window. The page you are seeing may be empty, which is normal. You are now ready to make your first calls.  Accessing the requests recording",
    "link": "/tutorials/requests-recording-auto-mocking/",
    "sectionTitle": "Step 1. Open the requests recording page",
    "sectionAnchor": "step-1-open-the-requests-recording-page",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/requests-recording-auto-mocking/#step-2-call-your-mock-server",
    "title": "Record API requests and HTTP traffic and auto-mock endpoints",
    "category": "tutorials",
    "content": "Now that you have your mock API running, you can call any route that should exists or, more straightforward, use your front-end application to trigger calls to your server.  Mockoon will answer with 404 to each of them, and you will start seeing the entering requests appearing on the left of the page in the form of a list.  List of entering requests screenshot",
    "link": "/tutorials/requests-recording-auto-mocking/",
    "sectionTitle": "Step 2. Call your mock server",
    "sectionAnchor": "step-2-call-your-mock-server",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/requests-recording-auto-mocking/#step-3-explore-the-recorded-requests",
    "title": "Record API requests and HTTP traffic and auto-mock endpoints",
    "category": "tutorials",
    "content": "Click on one of the entering requests in the list. The details should appear on the right side of the page.  You will see that the right panel has two tabs: Request and Response. You will find the entering call payload in the Request tab. The Response tab contains the actual response sent by Mockoon.  Select a request record  For each of them, you can see the headers, body, and params. The request and response bodies are also viewable in a separate editor with JSON linting enabled. It is especially useful when your body consists of dynamic templating helpers, which cannot be linted before being parsed and sent by Mockoon.  When used in conjunction with the proxy mode, this feature can also be used to debug what was forwarded to or answered by the proxied API.    You are now ready to create your first mock API endpoints automatically.",
    "link": "/tutorials/requests-recording-auto-mocking/",
    "sectionTitle": "Step 3. Explore the recorded requests",
    "sectionAnchor": "step-3-explore-the-recorded-requests",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/requests-recording-auto-mocking/#step-4-auto-mock-the-missing-endpoints",
    "title": "Record API requests and HTTP traffic and auto-mock endpoints",
    "category": "tutorials",
    "content": "Next to each record, you will see a small \"plus\" icon. Click on these icons to create each corresponding route in your mock server. It will reuse most of the requests information (path, headers, etc.) to create the missing endpoint. From there, you can further customize your endpoint or create more mocks from the rest of the entering requests.  Auto-mock by clicking on the plus icon",
    "link": "/tutorials/requests-recording-auto-mocking/",
    "sectionTitle": "Step 4. Auto-mock the missing endpoints",
    "sectionAnchor": "step-4-auto-mock-the-missing-endpoints",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/requests-recording-auto-mocking/#step-5-enable-recording-mode-to-automatically-create-new-endpoints",
    "title": "Record API requests and HTTP traffic and auto-mock endpoints",
    "category": "tutorials",
    "content": "You can also enable the recording mode to automatically create new endpoints when a new request is made to your mock server. To do so, click on the \"recording\" icon at the top of the page:  Enable recording mode",
    "link": "/tutorials/requests-recording-auto-mocking/",
    "sectionTitle": "Step 5. Enable recording mode to automatically create new endpoints",
    "sectionAnchor": "step-5-enable-recording-mode-to-automatically-create-new-endpoints",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/react-api-call-and-mocking/#0",
    "title": "Call a mock REST API from your React application",
    "category": "tutorials",
    "content": "This guide will teach you how to call any REST API from a React application created with the Create React App package. If you already have an existing API that you want to call from your application, you can skip the first step, in which we will create a fake REST API using Mockoon.",
    "link": "/tutorials/react-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/react-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock REST API from your React application",
    "category": "tutorials",
    "content": "When working on your React application, you may need to mock an API that is still under development, or that is only partially available. The easiest way to start working without having to wait is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of fake blog posts with a single title. In Mockoon, create a GET /posts API endpoint that returns an array of blog posts:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock server will be available at the following URL: http://localhost:3000. It is the URL we will need to use in our React component.",
    "link": "/tutorials/react-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/react-api-call-and-mocking/#2-make-a-call-to-the-api-endpoint-in-your-react-component",
    "title": "Call a mock REST API from your React application",
    "category": "tutorials",
    "content": "After creating a mock REST API endpoint in Mockoon, you can now call it from your React component. To do so, we need to use an AJAX library or the browser's built-in window.fetch function. We will be using the fetch function as it is available in most browsers.  You will find below the minimal code needed to call our API endpoint with the fetch function:  fetch('http://localhost:3002/posts')   .then((res) => res.json())   .then((result) => {     // we received our list of posts     console.log(result);   });  We need to integrate this code into a React component. We will reuse the App component which was automatically created by Create React App. However, we need to wrap this piece of code in a useEffect function in order to refresh the UI when our blog posts are fetched:  import { useEffect } from 'react';  function App() {   const [posts, setPosts] = useState([]);    useEffect(() => {     fetch('http://localhost:3002/posts')       .then((res) => res.json())       .then((result) => {         setPosts(result);       });   }, []);    return <ul>{/* TODO */}</ul>; }  export default App;  Note that we also stored the call result (our blog posts) in a state called posts.",
    "link": "/tutorials/react-api-call-and-mocking/",
    "sectionTitle": "2. Make a call to the API endpoint in your React component",
    "sectionAnchor": "2-make-a-call-to-the-api-endpoint-in-your-react-component",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/react-api-call-and-mocking/#3-use-the-posts-state-variable-in-your-component-jsx",
    "title": "Call a mock REST API from your React application",
    "category": "tutorials",
    "content": "We can now render our blog posts on the page as <li> using a simple map loop:  return (   <ul>     {posts.map((post) => (       <li key={post.id}>{post.title}</li>     ))}   </ul> );  Putting all this code together, we get a fully functional component loading asynchronous mock data:  import { useEffect } from 'react';  function App() {   const [posts, setPosts] = useState([]);    useEffect(() => {     fetch('http://localhost:3002/posts')       .then((res) => res.json())       .then((result) => {         setPosts(result);       });   }, []);    return (     <ul>       {posts.map((post) => (         <li key={post.id}>{post.title}</li>       ))}     </ul>   ); }  export default App;",
    "link": "/tutorials/react-api-call-and-mocking/",
    "sectionTitle": "3. Use the `posts` state variable in your component JSX",
    "sectionAnchor": "3-use-the-posts-state-variable-in-your-component-jsx",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/partial-mocking-proxy/#0",
    "title": "Create a partial mock API with Mockoon's proxy mode",
    "category": "tutorials",
    "content": "During the development of an application, you may use an API that is still under development. Rather than waiting for new API endpoints to be added and rely on your memory or documentation to continue your application development, you could use Mockoon to create a partial fake API. The idea is simple. Mockoon would serve the API endpoints you define while forwarding anything else to the URL of your choice. Let's dive through this with a simple example.  To learn more about APIs and API mocking in general, head over to our API guide or API mocking guide",
    "link": "/tutorials/partial-mocking-proxy/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/partial-mocking-proxy/#step-1-create-a-new-fakeapi-and-enable-the-proxy-mode",
    "title": "Create a partial mock API with Mockoon's proxy mode",
    "category": "tutorials",
    "content": "The first step is to create a new API in Mockoon or use one you already have.  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    As soon as you have your new mock API, you are ready to enable the proxy mode and forward all the calls to another URL. For this tutorial, we will be using the Star Wars API available at https://swapi.dev/api/. Head over to the environment proxy settings by clicking on the \"proxy\" tab at the top of the window. Then, enable the proxy mode and add the Star Wars API URL to which Mockoon will forward the requests:  Recording of enabling proxy mode",
    "link": "/tutorials/partial-mocking-proxy/",
    "sectionTitle": "Step 1. Create a new fakeAPI and enable the proxy mode",
    "sectionAnchor": "step-1-create-a-new-fakeapi-and-enable-the-proxy-mode",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/partial-mocking-proxy/#step-2-add-the-missing-endpoints",
    "title": "Create a partial mock API with Mockoon's proxy mode",
    "category": "tutorials",
    "content": "After creating your API, enabling the proxy mode, and adding the correct target URL, you need to add the missing API endpoints. The Star Wars API does not have any character with an ID above 83, and we want to add a missing one with id number 90. As is, calling GET /people/90 would return a 404. So, we will be adding the following body to a new GET /people/90 route:  {   \"name\": \"Mock Oon\",   \"height\": \"50\",   \"mass\": \"10\",   \"hair_color\": \"black\",   \"skin_color\": \"grey\",   \"eye_color\": \"grey\",   \"birth_year\": \"2017\",   \"gender\": \"raccoon\" }  To configure this missing endpoint, click on the blue \"plus\" button at the top of the endpoints list. Then, set the path to /people/90 and copy-paste the JSON body above.  Recording of adding a new endpoint",
    "link": "/tutorials/partial-mocking-proxy/",
    "sectionTitle": "Step 2. Add the missing endpoints",
    "sectionAnchor": "step-2-add-the-missing-endpoints",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/partial-mocking-proxy/#step-3-run-the-api-and-make-test-calls",
    "title": "Create a partial mock API with Mockoon's proxy mode",
    "category": "tutorials",
    "content": "You are ready to use your partial mock. Start the API by clicking on the green \"play\" icon at the top of the window.  You can now make a call to an existing endpoint of the Star Wars API, like /planets/1, and get the expected result from the Star Wars API, forwarded by Mockoon:  Screenshot of the result call  You can also call your custom endpoint GET /people/90 and see that Mockoon intercepted your call and returned the body you defined in your new route.  Screenshot of the result call",
    "link": "/tutorials/partial-mocking-proxy/",
    "sectionTitle": "Step 3. Run the API and make test calls",
    "sectionAnchor": "step-3-run-the-api-and-make-test-calls",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/partial-mocking-proxy/#step-4-check-the-environment-logs",
    "title": "Create a partial mock API with Mockoon's proxy mode",
    "category": "tutorials",
    "content": "Finally, you can check the different calls that have been made to Mockoon by going to the environment logs. You will see that the forwarded calls have a blue \"shield\" icon next to them, while the requests caught by Mockoon's routes have a green \"tick\" icon. To open the requests logs, click on the \"clock\" icon in the upper right corner of the screen:  Recording of checking the logs  You are now ready to unleash your creativity and create more awesome partial mocks!",
    "link": "/tutorials/partial-mocking-proxy/",
    "sectionTitle": "Step 4. Check the environment logs",
    "sectionAnchor": "step-4-check-the-environment-logs",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/nuxt-api-call-and-mocking/#0",
    "title": "Call a mock REST API from your Nuxt project",
    "category": "tutorials",
    "content": "This tutorial will detail step by step how to call a REST API from a Nuxt project created with the create-nuxt-app scaffolding tool. If you already have an existing API that you want to call from your application, you can skip the first step, in which we will create a fake REST API using Mockoon to speed up the development.",
    "link": "/tutorials/nuxt-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/nuxt-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock REST API from your Nuxt project",
    "category": "tutorials",
    "content": "When working on your Nuxt application, you may need to mock an API that is still under development, or that is only partially available. The easiest way to start working without having to wait is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of fake blog posts with a single title. In Mockoon, create a GET /posts API route that returns an array of blog posts:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock API server will be available at the following URL: http://localhost:3000. It is the URL we will need to use in our Vue.js component.",
    "link": "/tutorials/nuxt-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/nuxt-api-call-and-mocking/#2-preparing-our-vuejs-component",
    "title": "Call a mock REST API from your Nuxt project",
    "category": "tutorials",
    "content": "For this tutorial, we created a new Nuxt project using the official scaffolding tool: npx create-nuxt-app my-project. We answered \"no\" to most questions to keep the setup simple.  In the rest of this guide, we will use the main ./pages/index.vue file that was automatically created. First, let's \"clean\" this page component a bit by removing the Tutorial component:  <template>   <!-- Removed tutorial component --> </template>  <script>   export default {     name: 'IndexPage'   }; </script>",
    "link": "/tutorials/nuxt-api-call-and-mocking/",
    "sectionTitle": "2. Preparing our Vue.js component",
    "sectionAnchor": "2-preparing-our-vuejs-component",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/nuxt-api-call-and-mocking/#3-make-a-call-to-the-api-endpoint-in-your-component",
    "title": "Call a mock REST API from your Nuxt project",
    "category": "tutorials",
    "content": "After preparing our ./pages/index.vue page and creating a mock REST API endpoint in Mockoon, you can now call it from your component's code.  To make an AJAX call to an API, we need to use a library or the browser's built-in window.fetch function. We will be using the fetch function as it is available in most browsers.  You will find below the minimal code needed to call our API route with this function:  fetch('http://localhost:3000/posts')   .then((res) => res.json())   .then((posts) => {     // we received our list of posts     console.log(posts);   });  We need to integrate this code into our index page. However, we need to first prepare the initial reactive state (data) for our posts, and a created method using Vue's Options API, in which we will fetch our data at component's creation time.  <script>   export default {     data() {       return {         posts: []       };     },     created() {       // we will fetch our posts here, when the component is created     }   }; </script>",
    "link": "/tutorials/nuxt-api-call-and-mocking/",
    "sectionTitle": "3. Make a call to the API endpoint in your component",
    "sectionAnchor": "3-make-a-call-to-the-api-endpoint-in-your-component",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/nuxt-api-call-and-mocking/#4-fetch-the-data-and-store-the-result-in-the-reactive-state",
    "title": "Call a mock REST API from your Nuxt project",
    "category": "tutorials",
    "content": "We can now add our fetch function to the created method and store the result in the component's state:  <script>   export default {     data() {       return {         posts: []       };     },     created() {       fetch('http://localhost:3000/posts')         .then((res) => res.json())         .then((posts) => {           // store the posts in the reactive state           this.posts = posts;         });     }   }; </script>",
    "link": "/tutorials/nuxt-api-call-and-mocking/",
    "sectionTitle": "4. Fetch the data and store the result in the reactive state",
    "sectionAnchor": "4-fetch-the-data-and-store-the-result-in-the-reactive-state",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/nuxt-api-call-and-mocking/#5-use-the-posts-state-variable-in-your-components-template",
    "title": "Call a mock REST API from your Nuxt project",
    "category": "tutorials",
    "content": "We can now render our blog posts on the page as <li> using a v-for directive:  <template>   <ul>     <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>   </ul> </template>  Putting all this code together, we get a fully functional component loading asynchronous mock data:  <script>   export default {     data() {       return {         posts: []       };     },     created() {       fetch('http://localhost:3000/posts')         .then((res) => res.json())         .then((posts) => {           // store the posts in the reactive state           this.posts = posts;         });     }   }; </script>  <template>   <ul>     <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>   </ul> </template>",
    "link": "/tutorials/nuxt-api-call-and-mocking/",
    "sectionTitle": "5. Use the `posts` state variable in your component's template",
    "sectionAnchor": "5-use-the-posts-state-variable-in-your-components-template",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#0",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "In this guide, we will learn how to call a REST API from a Node.js application. Calling REST API is not the privilege of front-end developers! There are many reasons you may want to connect your back-end to a REST API: call to another internal API, user authentication, fetching data from providers, sending analytics data, etc.  If you already have an existing API that you want to use, you can skip the first step, in which we create a fake REST API using Mockoon.",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "You may already have access to the internal or third-party API you want to call, but this is not always the case. The API may be under development or require account creation, and you may want to start working with it as soon as possible. For this, the easiest way is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will simulate a call to the GitHub API by creating a fake GET /users/:username endpoint.  In Mockoon, create a GET /users/:username API endpoint that returns a payload containing a fake user object:  create a mock API endpoint  You can use the following JSON (taken from GitHub's documentation) as the body returned by the endpoint:  {   \"login\": \"octocat\",   \"id\": 1,   \"node_id\": \"MDQ6VXNlcjE=\",   \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",   \"gravatar_id\": \"\",   \"url\": \"https://api.github.com/users/octocat\",   \"html_url\": \"https://github.com/octocat\",   \"followers_url\": \"https://api.github.com/users/octocat/followers\",   \"following_url\": \"https://api.github.com/users/octocat/following{/other_user}\",   \"gists_url\": \"https://api.github.com/users/octocat/gists{/gist_id}\",   \"starred_url\": \"https://api.github.com/users/octocat/starred{/owner}{/repo}\",   \"subscriptions_url\": \"https://api.github.com/users/octocat/subscriptions\",   \"organizations_url\": \"https://api.github.com/users/octocat/orgs\",   \"repos_url\": \"https://api.github.com/users/octocat/repos\",   \"events_url\": \"https://api.github.com/users/octocat/events{/privacy}\",   \"received_events_url\": \"https://api.github.com/users/octocat/received_events\",   \"type\": \"User\",   \"site_admin\": false,   \"name\": \"monalisa octocat\",   \"company\": \"GitHub\",   \"blog\": \"https://github.com/blog\",   \"location\": \"San Francisco\",   \"email\": \"octocat@github.com\",   \"hireable\": false,   \"bio\": \"There once was...\",   \"twitter_username\": \"monatheoctocat\",   \"public_repos\": 2,   \"public_gists\": 1,   \"followers\": 20,   \"following\": 0,   \"created_at\": \"2008-01-14T04:33:35Z\",   \"updated_at\": \"2008-01-14T04:33:35Z\" }  Note that your fake mock server will be available at the following URL: http://localhost:3000. It is the URL we will need to use in our Node.js application.  You can further configure your mock API by adding as many routes and responses as you need. You can also give your mocks a more realistic behavior by using the templating system or adding rules.",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#2-start-your-mock-api-server",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "You can now start your API by clicking on the green \"play\" icon:  start a mock api",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "2. Start your mock API server",
    "sectionAnchor": "2-start-your-mock-api-server",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#3-call-your-mock-api-server",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "After starting your Mockoon's API, you are ready to call the endpoint in your Node.js application.  Your setup may vary here, but let's see a simple example of the GET API call with the node-fetch package available on NPM:  // replace original GitHub API URL by your local mock // const githubAPI = 'https://api.github.com/'; const githubAPI = 'https://localhost:3000/';  fetch(githubAPI + 'users/octocat', {   method: 'get',   headers: { 'Content-Type': 'application/json' } })   .then((res) => res.json())   .then((json) => {     // we received our user object!     console.log(json);   });  As you can see, this example requires a modification of your code to call the mock API instead of the GitHub API, and you may have a different setup that allows you to avoid touching the code.  One common solution is to use environment variables and the dotenv package to override them locally. Then, you would be able to modify the API URL in your .env file rather than in your code.",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "3. Call your mock API server",
    "sectionAnchor": "3-call-your-mock-api-server",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#4",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "replace original GitHub API URL by your local mock",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#github_apihttpsapigithubcom",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "GITHUB_API=https://localhost:3000/   And your JS file would look like this, using an environment variable:  ```js fetch(process.env.GITHUB_API + 'users/octocat', {   method: 'get',   headers: { 'Content-Type': 'application/json' } })   .then((res) => res.json())   .then((json) => console.log(json));  With this kind of setup, you will be able to locally switch from the original API you are using to a locally running mock API server. It's also a good practice to store configurations like API URLs in environment variables or configuration files.",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "GITHUB_API=https://api.github.com/",
    "sectionAnchor": "github_apihttpsapigithubcom",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/nodejs-api-call-and-mocking/#4-optional-use-the-proxy-mode-to-partially-mock-githubs-api",
    "title": "Easily call a mock REST API from a Node.js application",
    "category": "tutorials",
    "content": "You may also want to keep using the third-party API while mocking only a part of it. It's useful when testing API failures (500, 503, 504, etc.) or quickly prototyping a new feature. It is also possible with Mockoon by enabling the proxy mode:  enable proxy mode  To learn more about the proxy mode and how to use it, head over to the tutorial on Partial API mocking.",
    "link": "/tutorials/nodejs-api-call-and-mocking/",
    "sectionTitle": "4. (optional) Use the proxy mode to partially mock GitHub's API",
    "sectionAnchor": "4-optional-use-the-proxy-mode-to-partially-mock-githubs-api",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/nextjs-api-call-and-mocking/#0",
    "title": "Call a mock API from your Next.js application",
    "category": "tutorials",
    "content": "This guide will teach you how to call any REST API from your Next.js application. If you already have an existing API that you want to use, you can skip the first step, in which we create a fake REST API using Mockoon.",
    "link": "/tutorials/nextjs-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/nextjs-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock API from your Next.js application",
    "category": "tutorials",
    "content": "When working on your Next.js application, you may need to mock an API that doesn't exists yet, or is only partially available (see partial mocking with the proxy mode). For this, the easiest way is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of fake blog posts. In Mockoon, create a GET /posts API endpoint that returns an array of blog posts:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock server will be available at the following URL: http://localhost:3000. This is the URL we will need to use in our Next.js page.",
    "link": "/tutorials/nextjs-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/nextjs-api-call-and-mocking/#2-make-a-call-to-the-api-endpoint-in-your-nextjs-page",
    "title": "Call a mock API from your Next.js application",
    "category": "tutorials",
    "content": "After creating a mock REST API endpoint in Mockoon, you can now call it from your Next.js page. To do so, we need to use either the getStaticProps or the getServerSideProps functions. You can read more about these functions in the official documentation.  Using the getStaticProps function will allow you to pre-render the page at build time using the props returned by getStaticProps:  export async function getStaticProps(context) {   // We will fetch the blog posts here    return {     props: {} // props will be passed to the page   }; }  To fetch our blog posts from the mock API, we can use the fetch function and add the resulting data in the returned props:  export async function getStaticProps(context) {   // fetch the blog posts from the mock API   const res = await fetch('http://localhost:3000/posts');   const posts = await res.json();    return {     props: { posts } // props will be passed to the page   }; }",
    "link": "/tutorials/nextjs-api-call-and-mocking/",
    "sectionTitle": "2. Make a call to the API endpoint in your Next.js page",
    "sectionAnchor": "2-make-a-call-to-the-api-endpoint-in-your-nextjs-page",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/nextjs-api-call-and-mocking/#3-use-the-posts-prop-in-your-page",
    "title": "Call a mock API from your Next.js application",
    "category": "tutorials",
    "content": "We can now render our blog posts on the page as <li> using a simple map loop:  function HomePage({ posts }) {   return (     <ul>       {posts.map((post) => (         <li>{post.title}</li>       ))}     </ul>   ); }",
    "link": "/tutorials/nextjs-api-call-and-mocking/",
    "sectionTitle": "3. Use the `posts` prop in your page",
    "sectionAnchor": "3-use-the-posts-prop-in-your-page",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/nextjs-api-call-and-mocking/#use-nextjss-environment-variables",
    "title": "Call a mock API from your Next.js application",
    "category": "tutorials",
    "content": "To avoid modifying the server URL directly in the Next.js page's code, you can put this URL in Next.js's environment variables. To do so, create an environment variable in your .env.local or .env.development file:",
    "link": "/tutorials/nextjs-api-call-and-mocking/",
    "sectionTitle": "Use Next.js's environment variables",
    "sectionAnchor": "use-nextjss-environment-variables",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/nextjs-api-call-and-mocking/#envlocal-file",
    "title": "Call a mock API from your Next.js application",
    "category": "tutorials",
    "content": "API_URL=http://localhost:3000   You can then use the environment variable exposed by Next.js through the `process.env` object in the `getStaticProps` function:  ```javascript export async function getStaticProps(context) {   // fetch the blog posts from the mock API using the environment variable   const res = await fetch(`${process.env.API_URL}/posts`);   const posts = await res.json();    return {     props: { posts } // props will be passed to the page   }; }",
    "link": "/tutorials/nextjs-api-call-and-mocking/",
    "sectionTitle": ".env.local file",
    "sectionAnchor": "envlocal-file",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/javascript-api-call-and-mocking/#0",
    "title": "Call a mock API from your JavaScript application",
    "category": "tutorials",
    "content": "This short tutorial will teach you how to call any REST API endpoint from your JavaScript application. If you already have an existing API that you want to use, you can skip the first step, in which we create a fake REST API using Mockoon.",
    "link": "/tutorials/javascript-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/javascript-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock API from your JavaScript application",
    "category": "tutorials",
    "content": "When working on your JavaScript application, you may need to mock an API that doesn't exists yet, or is only partially available (see partial mocking with the proxy mode). For this, the easiest way is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock REST API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of imaginary blog posts. In Mockoon, create a GET /posts API endpoint that returns an array of simple blog posts with an id and a title:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock server will be available at the following URL: http://localhost:3000. This is the URL we will need to use in our JavaScript code.",
    "link": "/tutorials/javascript-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/javascript-api-call-and-mocking/#2-make-a-call-to-the-api-endpoint-in-your-javascript",
    "title": "Call a mock API from your JavaScript application",
    "category": "tutorials",
    "content": "After creating a mock REST API endpoint in Mockoon, you can now call it from your Javascript app.  Let's first create a minimal HTML file to execute our JavaScript:  <!DOCTYPE html> <html lang=\"en\">   <head>     <meta charset=\"UTF-8\" />     <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />     <title>My page</title>   </head>   <body>     <ul id=\"posts\"></ul>      <script>       // Our JavaScript will go here     </script>   </body> </html>  It contains a script tag to add our JavaScript and a ul element that will receive our list of posts later. We can save this HTML code in an index.html file.  The next step is to add JavaScript in the script tag to call our GET /posts API endpoint. For this, we will use the fetch function:  <script>   fetch('http://localhost:3000/posts')     .then((response) => response.json())     .then((posts) => console.log(posts)); </script>  By default, fetch will make a GET call on the provided endpoint. As we receive JSON data, we first need to convert it as a JavaScript object before using it, with response.json().  After opening your index.html file in your browser, you should see a call in the network tab and your data displayed in the console:  Data displayed in developer tools console",
    "link": "/tutorials/javascript-api-call-and-mocking/",
    "sectionTitle": "2. Make a call to the API endpoint in your JavaScript",
    "sectionAnchor": "2-make-a-call-to-the-api-endpoint-in-your-javascript",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/javascript-api-call-and-mocking/#3-use-the-posts-in-your-html",
    "title": "Call a mock API from your JavaScript application",
    "category": "tutorials",
    "content": "We can now render the list of post titles on the page as <li> using a simple forEach loop:  <script>   fetch('http://localhost:3000/posts')     .then((response) => response.json())     .then((posts) => {       const postsContainer = document.getElementById('posts');        posts.forEach((post) => {         const li = document.createElement('li');         li.textContent = post.title;         postsContainer.appendChild(li);       });     }); </script>  For each post, we will create a new li element and append it to the ul container element that we created earlier.  Here is all the code put together:  <!DOCTYPE html> <html lang=\"en\">   <head>     <meta charset=\"UTF-8\" />     <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />     <title>My page</title>   </head>   <body>     <ul id=\"posts\"></ul>     <script>       fetch('http://localhost:3000/posts')         .then((response) => response.json())         .then((posts) => {           const postsContainer = document.getElementById('posts');            posts.forEach((post) => {             const li = document.createElement('li');             li.textContent = post.title;             postsContainer.appendChild(li);           });         });     </script>   </body> </html>  You can now imagine a more complex layout where you could call more endpoints to display full articles, lists of recommended posts, etc.",
    "link": "/tutorials/javascript-api-call-and-mocking/",
    "sectionTitle": "3. Use the `posts` in your HTML",
    "sectionAnchor": "3-use-the-posts-in-your-html",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/ionic-api-call-and-mocking/#0",
    "title": "Call a mock API from your Ionic mobile application",
    "category": "tutorials",
    "content": "In this guide, we will learn how to call an API endpoint from an Ionic mobile application using the Angular framework. If you already have an existing API that you want to use, you can skip the first step, in which we create a fake REST API endpoint using Mockoon.",
    "link": "/tutorials/ionic-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/ionic-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock API from your Ionic mobile application",
    "category": "tutorials",
    "content": "During the development of your Ionic mobile application, you may need to mock an API that is not ready yet, or only partially available (see partial mocking with the proxy mode). For this, the easiest way is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of fake blog posts. In Mockoon, create a GET /posts API endpoint that returns an array of blog posts:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock server will be available at the following URL: http://localhost:3000. This is the URL we will need to use in our Angular service.",
    "link": "/tutorials/ionic-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/ionic-api-call-and-mocking/#2-make-a-call-to-the-api-endpoint-in-your-angular-service",
    "title": "Call a mock API from your Ionic mobile application",
    "category": "tutorials",
    "content": "After creating a mock API endpoint in Mockoon, you can now call it from your Ionic mobile application using an Angular service. To do so, we need to create a new \"posts\" service using Ionic's following command:  $ ionic g service services/posts > ng.cmd generate service services/posts --project=app CREATE src/app/services/posts.service.spec.ts (352 bytes) CREATE src/app/services/posts.service.ts (134 bytes) [OK] Generated service!  Then we will need to inject and use Angular's HttpClient in our new service to be able to call our API:  import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http';  @Injectable() export class PostsService {   constructor(private http: HttpClient) {} }  We finally add a getPosts method that we will call from our component and returns an Observable containing our list of posts:  getPosts(): Observable<{ id: number; title: string }[]> {   return this.http.get('http://localhost:3000/posts'); }  Below is our service after putting all the pieces of code together:  import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http';  @Injectable() export class PostsService {   constructor(private http: HttpClient) {}    getPosts(): Observable<{ id: number; title: string }[]> {     return this.http.get('http://localhost:3000/posts');   } }",
    "link": "/tutorials/ionic-api-call-and-mocking/",
    "sectionTitle": "2. Make a call to the API endpoint in your Angular service",
    "sectionAnchor": "2-make-a-call-to-the-api-endpoint-in-your-angular-service",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/ionic-api-call-and-mocking/#3-subscribe-to-the-observable-in-your-component",
    "title": "Call a mock API from your Ionic mobile application",
    "category": "tutorials",
    "content": "Let's display our blog post titles in our \"HomePage\" component. We first need to inject our PostsService and then assign our Observable returned by the getPosts method so we can use it in the template:  import { Component, OnInit } from '@angular/core'; import { Observable } from 'rxjs'; import { PostsService } from '../services/posts.service';  @Component({   selector: 'app-home',   templateUrl: 'home.page.html',   styleUrls: ['home.page.scss'] }) export class HomePage implements OnInit {   public posts$: Observable<{ id: number; title: string }[]>;   constructor(private postsService: PostsService) {}    ngOnInit() {     // assign the Observable returned by the `getPosts` method     this.posts$ = this.postsService.getPosts();   } }",
    "link": "/tutorials/ionic-api-call-and-mocking/",
    "sectionTitle": "3. Subscribe to the Observable in your component",
    "sectionAnchor": "3-subscribe-to-the-observable-in-your-component",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/ionic-api-call-and-mocking/#4-display-the-titles-as-a-list-of-items",
    "title": "Call a mock API from your Ionic mobile application",
    "category": "tutorials",
    "content": "We can now display our list of post titles using ion_item elements. We will reuse the div#container from the home.page.html file created by the ionic start command. We will use a simple *ngFor directive combined with the | async pipe to subscribe to our observable:  <ion-header [translucent]=\"true\">   <ion-toolbar>     <ion-title> Blank </ion-title>   </ion-toolbar> </ion-header>  <ion-content [fullscreen]=\"true\">   <ion-header collapse=\"condense\">     <ion-toolbar>       <ion-title size=\"large\">Blank</ion-title>     </ion-toolbar>   </ion-header>    <div id=\"container\">     <ion-item *ngFor=\"let post of posts$ | async\">       <ion-label> {{post.title}} </ion-label>     </ion-item>   </div> </ion-content>  We can now see the result after running the ionic serve command:  post titles list",
    "link": "/tutorials/ionic-api-call-and-mocking/",
    "sectionTitle": "4. Display the titles as a list of items",
    "sectionAnchor": "4-display-the-titles-as-a-list-of-items",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/getting-started/#0",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "Mockoon is a free cross-platform desktop application that takes API mocking to the next level. Mockoon offers a fast and easy-to-use interface and gives you complete control over your mock APIs with advanced functionality like a templating system, a proxy mode, and requests recording.  This tutorial will show you how to install the desktop mocking application and set up your first mock API.  View the video version button  To learn more about APIs and API mocking in general, head over to our API guide or API mocking guide",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/getting-started/#step-1-install-the-application",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "Mockoon is available on the three major operating systems: Windows, macOS, and Linux. Visit the download section on the homepage to download the binary or installer for your operating system:  Screenshot of the download section on the homepage   After downloading the installer, double click on the file to install Mockoon and follow the instructions. Now, open the application to start setting up your first mock API.",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "Step 1. Install the application",
    "sectionAnchor": "step-1-install-the-application",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/getting-started/#step-2-create-your-first-mock-api",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "After launching the application for the first time, you will find a demo mock API, also called \"environment\" in Mockoon. You can keep it and build from here or create a new one. To create a new mock API, click on the \"New environment\" button. You will be prompted to save the environment's JSON file:  Recording of creating a new environment  You can also rename the environment, as shown below:  Environment renaming",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "Step 2. Create your first mock API",
    "sectionAnchor": "step-2-create-your-first-mock-api",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/getting-started/#step-3-create-your-first-api-route",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "The newly created mock API already includes a route on /. You can modify it by setting up the method and path of your choice.  You can also create a new endpoint by clicking on the blue \"plus\" button at the top of the endpoint list:  Recording of adding a new API route",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "Step 3. Create your first API route",
    "sectionAnchor": "step-3-create-your-first-api-route",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/getting-started/#step-4-api-endpoint-configuration",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "You can further customize your endpoint by adding a custom header and the following sample body (which makes use of Mockoon's templating system):  // Sample body [   {{# repeat 5}}   {     \"title\": \"Tutorial {{@index}}\",     \"tags\": \"{{someOf (array 'Getting started' 'https' 'proxy mode' 'headers' 'templating') 1 3}}\"   }   {{/ repeat}} ]  Recording of updating an API route  You can create a more complex configuration by serving files or adding multiple responses triggered by rules.",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "Step 4. API endpoint configuration",
    "sectionAnchor": "step-4-api-endpoint-configuration",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/getting-started/#step-5-run-and-call-your-mock-api",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "The last step is to run your mock API. For this, click on the green \"play\" arrow in the header:  Recording of running a mock API  Your mock server is now available on http://localhost:3000 (but also on http://127.0.0.1 and all your local network adapters).  You can do a test call to the following URL http://localhost:3000/tutorials using your favorite tool (here using Insomnia) and see the returned response:  Screenshot of the result call",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "Step 5. Run and call your mock API",
    "sectionAnchor": "step-5-run-and-call-your-mock-api",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/getting-started/#step-6-learn-more",
    "title": "Create your first mock API with Mockoon",
    "category": "tutorials",
    "content": "Now that you know how to create a basic mock API, you can head over to the official documentation to explore the other functionalities like requests logging, partial API mocking with proxy mode, or the templating system.",
    "link": "/tutorials/getting-started/",
    "sectionTitle": "Step 6. Learn more",
    "sectionAnchor": "step-6-learn-more",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#0",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Mocking an API can save you time. By faking the backend responses early, you don't have to worry about whether an endpoint is ready or not. You are up and running in no time and can start implementing your application. However, your mock should still be realistic. \"Lorem ipsum\" content is often not enough to surface layout problems, container overflowed by text, etc.  When mocking using Mockoon, you can easily customize your endpoints to make them look like real ones and even behave realistically, thanks to the dynamic templating system.  Let's dig into this templating system and see how it allows you to generate random data of any type (JSON, CSV, XML, HTML, etc.) and make it behaves dynamically.  To learn more about APIs and API mocking in general, head over to our API guide or API mocking guide",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#generate-random-fake-data",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Nowadays, most of the developers work with JSON. Generating a massive amount of fake JSON data with Mockoon is a breeze thanks to the powerful templating system based on Handlebars syntax. But it's also perfect to generate any type of content: CSV, XML, HTML, you name it!  Mockoon also offers multiple helpers and embarks the Faker.js library, which can generate localized random data as various as: cities, addresses, first names, phone numbers, UUID, etc.  This tutorial will show only some examples of content generation. If you want to learn more about Mockoon templating system and all the available helpers, head over to the official templating documentation.    Let's see what Mockoon has to offer.  You can find on our repository all the following examples ready to use! &nbsp;Download  To open the file, please follow the instructions.",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Generate random fake data",
    "sectionAnchor": "generate-random-fake-data",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#complete-json-example-posts-list",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Let's say you are working on the next great social network, building the front-end with your favorite framework while the backend team works hard to implements more and more API endpoints. You switch on your favorite mock server tool (yes, Mockoon), and start wondering how you could return a huge amount of realistic posts on a GET /posts endpoint. Here is where the helpers available in Mockoon comes into play. By using a combination of repeat, image.avatar, lorem.sentences, etc. you can quickly get a massive amount of random data. Combined with the latency option, you can even simulate a slow server and check how your application behaves under stress.  To use the templating system, you only have to use the response body editor and start adding your content. Remember to use the double curly braces to delimit your helpers {{ helperName }} Let's have a look at what such a body could look like:  [   {{#repeat (queryParam 'total' '5')}}   {     \"id\": {{@index}},     \"title\": \"{{faker 'lorem.sentence'}}\",     \"content\": \"{{faker 'lorem.sentences'}}\",     \"media\": \"{{faker 'image.urlLoremFlickr' category='nature'}}\",     \"author\": {       \"name\": \"{{faker 'person.firstName'}} {{faker 'person.firstName'}}\",       \"avatar\": \"{{faker 'image.avatar'}}\"     },     \"comments\": [       {{#repeat (faker 'string.numeric' 5)}}       {         \"id\": \"{{faker 'string.uuid'}}\",         \"content\": \"{{faker 'lorem.sentence'}}\",         \"author\": {           \"name\": \"{{faker 'person.firstName'}} {{faker 'person.firstName'}}\",           \"avatar\": \"{{faker 'image.avatar'}}\"         }       }       {{/repeat}}     ],     \"likes\": {{faker 'string.numeric' 100}},     \"shares\": {{faker 'string.numeric' 100}},     \"location\": {       \"lat\": {{faker 'location.latitude'}},       \"long\": {{faker 'location.longitude'}}     },     \"archived\": {{faker 'datatype.boolean'}}   }   {{/repeat}} ]  After a call to Mockoon, this would be the kind of body generated from this template:  [   {     \"id\": 0,     \"title\": \"Amet sint maxime repellendus aspernatur et eos et dolorum voluptatem.\",     \"content\": \"Placeat libero ipsa nobis ipsum quibusdam quas harum ut. Distinctio minima iusto. Ad ad maiores et sint voluptate recusandae architecto. Et nihil ullam aut alias.\",     \"media\": \"http://placeimg.com/640/480/nature\",     \"author\": {       \"name\": \"Lexi Clifford\",       \"avatar\": \"https://s3.amazonaws.com/uifaces/faces/twitter/caseycavanagh/128.jpg\"     },     \"comments\": [       {         \"id\": \"a1b18846-9ef6-45ee-bab1-9e7135c8bca0\",         \"content\": \"Dolor eum omnis neque placeat cumque animi eos ut.\",         \"author\": {           \"name\": \"Adrien Edgardo\",           \"avatar\": \"https://s3.amazonaws.com/uifaces/faces/twitter/loganjlambert/128.jpg\"         }       }     ],     \"likes\": 80,     \"shares\": 83,     \"location\": {       \"lat\": 49.2286, ...  This example makes an extensive usage of what Mockoon and Faker.js have to offer. First, it generates as many \"posts\" items as provided in the total query parameter (or default to 5) when calling GET /your/endpoint?total=140. It is especially useful when you want to request a specific number of items depending on the pagination or a \"number per pages\" user setting. Second, you can see that multiple properties are defined, and random mock data is generated like avatar image URLs, names, coordinates, etc.  There are a lot of possibilities and combinations you can try. You can also make your template react to a lot of parameters from the entering request by using Mockoon's helpers. We've already seen queryParam above, but you will find many more in the templating documentation. They allow you to query the request information like body, urlParam, header, method, etc.",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Complete JSON example: posts list",
    "sectionAnchor": "complete-json-example-posts-list",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#generate-other-types-of-fake-data",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Mockoon does not limit you to JSON. The templating language based on Handlebars is compatible with any content type. It means that you can generate CSV, HTML, XML, etc. You will find below some examples of what can you can achieve with the templating system.",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Generate other types of fake data?",
    "sectionAnchor": "generate-other-types-of-fake-data",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#generate-geographical-fake-csv-data",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Generating realistic mock CSV data is also very easy. You will see below that it involves the same syntax as for the JSON example:  city,state,address,latitude,longitude,timezone {{#repeat 5000}} {{faker 'location.city'}},{{faker 'location.state' abbreviated=true}},{{faker 'location.streetAddress'}},{{faker 'location.latitude'}},{{faker 'location.longitude'}},{{faker 'location.timeZone'}} {{/repeat}}  After parsing, this template would result in the following body:  city,state,address,latitude,longitude,timezone South Lew,MI,72031 Cindy Unions,89.9870,-16.3010,America/Santiago, New Theron,OR,242 Mariano Creek,-43.9050,-76.3276,Asia/Novosibirsk, Keshawnmouth,AR,29520 Breitenberg Drives,-13.4154,-134.3900,Pacific/Guam, ...",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Generate geographical fake CSV data",
    "sectionAnchor": "generate-geographical-fake-csv-data",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#generate-xml-mock-data",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Generating an XML file with fake data would also be done in no time. You will find below an example of a products list:  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <PRODUCTS>   {{# repeat 50}}   <PRODUCT>     <UUID>{{faker 'string.uuid'}}</UUID>     <NAME>{{faker 'commerce.product'}}</NAME>     <PRICE>{{faker 'commerce.price'}}</PRICE>     <COLOR>{{faker 'color.human'}}</COLOR>     <INVENTORY>{{faker 'string.numeric' 2}}</INVENTORY>   </PRODUCT>   {{/ repeat}} </PRODUCTS>  After parsing, this template would result in the following body:  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <PRODUCTS>   <PRODUCT>     <UUID>26421e57-ca4a-4c20-a845-b5317d80beea</UUID>     <NAME>Table</NAME>     <PRICE>718.00</PRICE>     <COLOR>olive</COLOR>     <INVENTORY>12</INVENTORY> ...  You are now ready to generate massive amounts of data for your mock APIs. The only limit is your imagination!",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Generate XML mock data",
    "sectionAnchor": "generate-xml-mock-data",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#generate-dynamic-templating-depending-on-the-request",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "We just saw some interesting use-cases but still quite simple. When working on your application, you may want to go a little bit further by making the template react to the request sent to Mockoon. This is possible by using various helpers that you will find in the templating documentation: body, queryParam, urlParam, cookie, header, hostname, ip, method, etc.  They allow you to access the entering request's information. Combined with other helpers like repeat, switch, or if, you will be able to dynamically generate more complex content.  You will find below some examples:",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Generate dynamic templating depending on the request",
    "sectionAnchor": "generate-dynamic-templating-depending-on-the-request",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#new-user-after-a-post-request",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "This first example tries to reproduce a call to a POST /users route, which would answer with the newly created object, a user. For this, we will reuse in the response the various parameters present in the request:  {   \"id\": \"{{faker 'string.uuid'}}\",   \"firstname\": \"{{body 'firstname'}}\",   \"lastname\": \"{{body 'lastname'}}\",   \"birthdate\": \"{{body 'birthdate'}}\",   \"email\": \"{{body 'email'}}\",   \"createdAt\": \"{{now}}\" }  After a call to this endpoint with the following body:  POST /users Content-Type: application/json  {   \"firstname\": \"John\",   \"lastname\": \"Doe\",   \"birthdate\": \"1956-10-10\",   \"email\": \"john.doe@domain.com\" }  We would receive this kind of response content, containing the request information plus some new fields (id and createdAt):  {   \"id\": \"6eeede77-107e-4d1a-abf3-feb2925c48f7\",   \"firstname\": \"John\",   \"lastname\": \"Doe\",   \"birthdate\": \"1956-10-10\",   \"email\": \"john.doe@domain.com\",   \"createdAt\": \"2020-11-18T21:11:26.820+01:00\" }  Here, we mainly used the body helper, but we can imagine more complex examples.",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "New user after a POST request",
    "sectionAnchor": "new-user-after-a-post-request",
    "score": 9,
    "groupScore": 7
  },
  {
    "objectID": "/tutorials/generate-mock-json-data/#variable-content-depending-on-multiple-request-parameters",
    "title": "Generate dynamic mock data with Mockoon templating system",
    "category": "tutorials",
    "content": "Let's imagine an endpoint GET /inventory/:type returning either \"products\" or \"materials\" depending on the route parameter type and in various numbers depending on a query parameter named total. To achieve this, we can use a combination of repeat and switch helpers:  [   {{#repeat (queryParam 'total')}}   {     \"id\": \"{{faker 'string.uuid'}}\",     {{# switch (urlParam 'type')}}     {{# case 'products'}}     \"name\": \"{{faker 'commerce.product'}}\",     \"price\": \"{{faker 'commerce.price'}} EUR\"     {{/ case}}     {{# case 'materials'}}     \"name\": \"{{faker 'commerce.productMaterial'}}\",     \"quantity\": \"{{faker 'string.numeric' 2}}\"     {{/ case}}     {{/ switch}}   }   {{/repeat}} ]  When calling the endpoint with /content/materials?total=2 we would receive the following array of materials with the properties id, name, and quantity:  [   {     \"id\": \"eca2e895-a100-4a86-b1be-ff76fc29068a\",     \"name\": \"Granite\",     \"quantity\": \"37\"   },   {     \"id\": \"fcaceec9-23d9-4979-9905-c9455569bffc\",     \"name\": \"Wooden\",     \"quantity\": \"49\"   } ]  When calling the endpoint with /content/products?total=2 we would receive the following array of products with the properties id, name, and price:  [   {     \"id\": \"c9d31bbd-3b55-4c53-8c3d-49a8af4fb6ba\",     \"name\": \"Pants\",     \"price\": \"485.00 EUR\"   },   {     \"id\": \"cc147251-6dd5-4dd4-85da-251648eada9e\",     \"name\": \"Bike\",     \"price\": \"268.00 EUR\"   } ]  For more complex cases, you could also create multiple responses for the same route, with different bodies, and trigger them by defining some rules. To learn more about using multiple responses combined with rules, you can have a look at the related documentation.  Remember, you can find all this tutorial's examples ready to use on our repository! &nbsp;Download  To open the file, please follow the instructions.",
    "link": "/tutorials/generate-mock-json-data/",
    "sectionTitle": "Variable content depending on multiple request parameters",
    "sectionAnchor": "variable-content-depending-on-multiple-request-parameters",
    "score": 9,
    "groupScore": 8
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#0",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "When creating an API mock, you often need to apply the same rules to all your endpoints. It also makes your mock more consistent and easier to maintain. For example, you may want to check that all your requests contain an Authorization header or that they all contain a specific property in their body. In mockoon, you can easily create routes that will apply rules to all your endpoints and server specific responses, like a 401 Unauthorized. This tutorial will show you how to do it through an example.  Creating global rules in Mockoon requires the use of different features:  The response's fallback mode. Wildcard routes Response rules  In this tutorial, we will create a mock API with a simple GET route and a global route that will check that all the requests contain an Authorization header and return a 401 Unauthorized error if that's not the case.",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#1-create-a-route-to-protect",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "Starting with an empty environment, create a new route and set its path to /protected and its method to GET:  mockoon interface with a single route named protected  You can keep the status code to 200 and add a simple JSON response body:  {   \"response\": \"success\" }",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "1. Create a route to protect",
    "sectionAnchor": "1-create-a-route-to-protect",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#2-create-a-wildcard-route",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "To create a global route, you first need to create a new HTTP route that will match all the endpoints you want to protect, both with its path and method(s). To do so, create a new route, set its path to *, which will match any path, and select \"All methods\" in the method dropdown:  wildcard route on all methods  We could also set its path to /protected and its method to GET to match our previous route, but it would only protect this specific route and not all the others.  Important point: you need to move the wildcard route above the GET /protected route, so it can be evaluated first and catch all the requests. You can create it first or move it up in the routes list with a drag and drop.  üí° You can also create a wildcard route that only matches a specific method, like GET or POST, instead of \"All methods\", if you want to protect all your POST endpoints, for example. Finally, you can create a wildcard route that matches all the endpoints starting with a specific path, like /users/* instead of /*. You can use this method to protect all your /users/something endpoints but not the /users one.",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "2. Create a wildcard route",
    "sectionAnchor": "2-create-a-wildcard-route",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#3-setup-the-response-and-rule",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "The second step is to set up one or more responses with rules on this wildcard route. We will create a rule checking that the request contains an Authorization header and return a 401 error if it's not present.",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "3. setup the response and rule",
    "sectionAnchor": "3-setup-the-response-and-rule",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#3a-set-the-status-code-and-body",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "Modify the existing response by setting the status code to 401:  set response status code to 401 in the menu  You can also add a simple JSON response body returning an error:  {   \"error\": \"Unauthorized\" }",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "3a. Set the status code and body",
    "sectionAnchor": "3a-set-the-status-code-and-body",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#3b-create-a-new-rule",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "The second step is to add a new rule to this response by navigating to the \"Rules\" tab in the response view and clicking the \"Add rule\" button. In the newly added rule, select the \"Header\" rule type. Then, set the \"Header name\" to Authorization and the operator to null:  create rule to check that the Authorization header is null  üí° You can create more responses with associated rules to verify more criteria on the request and serve different responses accordingly (400 Bad Request when the body is missing, etc.).",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "3b. Create a new rule",
    "sectionAnchor": "3b-create-a-new-rule",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#4-activate-the-fallback-mode",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "Once your route is created and your responses customized, activate the fallback mode on your wildcard route by clicking on the \"fallback\" icon next to the response list:  fallback mode activated  The fallback mode will automatically pass the request to the next route, here GET /protected, when none of the wildcard route rules match.  üìò You can learn more about the fallback mode in our documentation.",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "4. Activate the fallback mode",
    "sectionAnchor": "4-activate-the-fallback-mode",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/create-global-rules-routes/#5-test-your-mock",
    "title": "Create global rules for your routes",
    "category": "tutorials",
    "content": "Our setup is complete, and we can now test our mock by making two requests to our GET /protected route, one without and one with an Authorization header.  First, start your environment by clicking on the green \"play\" button at the top:  highlighted green play button at the top of the screen  Then, open a terminal and make a request without the Authorization header using curl:  curl -i http://localhost:3000/protected  You should get a 401 Unauthorized error with our \"Unauthorized\" response body:  $ curl -i http://localhost:3000/protected HTTP/1.1 401 Unauthorized [...] {   \"error\": \"Unauthorized\" }  Now, make a second request with a fake Authorization header:   curl -i http://localhost:3000/protected -H \"Authorization: xxxx\"  You should get a 200 status code with our \"Success\" response body:  $ curl -i http://localhost:3000/protected -H \"Authorization: xxxx\" HTTP/1.1 200 OK [...] {   \"response\": \"success\" }",
    "link": "/tutorials/create-global-rules-routes/",
    "sectionTitle": "5. Test your mock",
    "sectionAnchor": "5-test-your-mock",
    "score": 9,
    "groupScore": 7
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#0",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "Where Mockoon routes are independent and stateless, CRUD routes can generate multiple endpoints to perform CRUD operations (Create, Read, Update, Delete) on data buckets. Let's see how to create a full REST API in seconds using Mockoon's CRUD routes.",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#1-create-a-new-crud-route",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "The first step is to create a new automated CRUD route. To create a CRUD route, click on the \"CRUD route\" entry in the add route menu:  Add a new CRUD route  Then, set its path, usually a resource name:  Set the CRUD route path",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "1. Create a new CRUD route",
    "sectionAnchor": "1-create-a-new-crud-route",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#2-create-and-link-a-data-bucket-to-the-crud-route",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "You may have noticed that the CRUD route is not linked to a data bucket yet, hence the \"Select a data bucket for CRUD operations\" message in the route response:  no databucket linked message  A data bucket is a key-value store where you can define some string content that you can reuse in multiple route responses.  They are stored at the environment level and generated when the server starts or sometimes after the first call. A data bucket content persists between mock API calls. So, they are the perfect way to create JSON \"databases\" to be reused in your routes.  üìò To learn more about data buckets, head over to our data buckets documentation or tutorial.    Let's create one and link it to the route.",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "2. Create and link a data bucket to the CRUD route",
    "sectionAnchor": "2-create-and-link-a-data-bucket-to-the-crud-route",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#create-a-new-data-bucket",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "To create a new data bucket, open the Data options by clicking on the tab at the top of the window:  Open data bucket view  Add a new data bucket by clicking on the \"plus\" button and personalize your data bucket name and content on the right part of the screen. Here, we named it \"Users\" and added some JSON content with templating to generate three fake users at runtime:  Add a data bucket and personalize it with some content  Here is the JSON content we used:  [   {{#repeat 3}}     {       \"id\": {{add @index 1}},       \"name\": \"{{faker 'person.firstName'}} {{faker 'person.lastName'}}\",       \"email\": \"{{faker 'internet.email'}}\"     }     {{#unless @last}},{{/unless}}   {{/repeat}} ]",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Create a new data bucket",
    "sectionAnchor": "create-a-new-data-bucket",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#link-the-data-bucket-to-the-crud-route",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "You can now link the data bucket to the CRUD route we created previously. To link the data bucket, select your data bucket in the dropdown:  Select the data bucket in the crud route dropdown",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Link the data bucket to the CRUD route",
    "sectionAnchor": "link-the-data-bucket-to-the-crud-route",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#3-perform-crud-operations",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "Now that the data bucket is linked to the CRUD route, you can perform CRUD operations on it.  When starting the mock API, Mockoon will automatically generate a series of routes for each CRUD operation on the data bucket. Some examples:  GET /users to list all users of our bucket. GET /users/:id to get the user with a specific ID. POST /users to add a new user to the data bucket array. PUT /users/:id to update the user with a specific ID. DELETE /users/:id to delete the user with a specific ID.  üìò More routes are created by CRUD endpoints, and many options are available: sorting, pagination, etc. Head over to our CRUD routes documentation for more information.",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "3. Perform CRUD operations",
    "sectionAnchor": "3-perform-crud-operations",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#list-all-users",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "To list all users, you can perform a GET request on the /users route using your favorite tool (Postman, Insomnia, curl, etc.):  $ curl http://localhost:3000/users  [   { \"id\": 1, \"name\": \"Gudrun Rempel\", \"email\": \"Ignacio_Glover4@gmail.com\" },   { \"id\": 2, \"name\": \"Roberta Conroy\", \"email\": \"Adriana.Treutel@gmail.com\" },   { \"id\": 3, \"name\": \"Tia Armstrong\", \"email\": \"Polly5@hotmail.com\" } ]",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "List all users",
    "sectionAnchor": "list-all-users",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#get-a-single-user",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "To get the first user, you can perform a GET request on the /users/1 route:  $ curl http://localhost:3000/users/1  {   \"id\": 1,   \"name\": \"Gudrun Rempel\",   \"email\": \"Ignacio_Glover4@gmail.com\" }",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Get a single user",
    "sectionAnchor": "get-a-single-user",
    "score": 9,
    "groupScore": 7
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#add-a-new-user",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "To add a new user with id 4, you can perform a POST request on the /users route with the following payload:  $ curl -X POST http://localhost:3000/users -H 'Content-Type: application/json' -d '{\"id\": 4, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\"}'  { \"id\": 4, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" }",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Add a new user",
    "sectionAnchor": "add-a-new-user",
    "score": 9,
    "groupScore": 8
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#replace-a-user",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "To Replace the first user, you can perform a PUT request on the /users/1 route with the following payload:  $ curl -X PUT http://localhost:3000/users/1 -H 'Content-Type: application/json' -d '{\"id\": 1, \"name\": \"Mock Oon\", \"email\": \"mock.oon@example.com\"}'  { \"id\": 1, \"name\": \"Mock Oon\" }",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Replace a user",
    "sectionAnchor": "replace-a-user",
    "score": 9,
    "groupScore": 9
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#delete-a-user",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "To delete the second user, you can perform a DELETE request on the /users/2 route:  $ curl -X DELETE http://localhost:3000/users/2",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Delete a user",
    "sectionAnchor": "delete-a-user",
    "score": 9,
    "groupScore": 10
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#list-all-users-again",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "Finally, you can list the users again to see all the changes we made:  $ curl http://localhost:3000/users  [   { \"id\": 1, \"name\": \"Mock Oon\", \"email\": \"mock.oon@example.com\" },   { \"id\": 3, \"name\": \"Tia Armstrong\", \"email\": \"Polly5@hotmail.com\" },   { \"id\": 4, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } ]",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "List all users again",
    "sectionAnchor": "list-all-users-again",
    "score": 9,
    "groupScore": 11
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#customizing-the-id-property",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "By default, CRUD endpoints will use the id property to identify objects in an array in all the routes manipulating a single resource (e.g. GET /resource/:id). However, you can change this property to anything you want, like uuid, custom_id, etc:  Customize the CRUD id property",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Customizing the \"id\" property",
    "sectionAnchor": "customizing-the-id-property",
    "score": 9,
    "groupScore": 12
  },
  {
    "objectID": "/tutorials/create-full-rest-api-crud-routes/#data-persistence",
    "title": "Create full mock REST APIs in seconds using Mockoon's CRUD routes",
    "category": "tutorials",
    "content": "As you can see, the data bucket content is generated once when the server starts, and its state persists between calls. You can reset the bucket to its initial state by restarting your mock API.  ‚ö†Ô∏è The data bucket generated content is not persisted on disk to make testing multiple scenarios easier.",
    "link": "/tutorials/create-full-rest-api-crud-routes/",
    "sectionTitle": "Data persistence",
    "sectionAnchor": "data-persistence",
    "score": 9,
    "groupScore": 13
  },
  {
    "objectID": "/tutorials/create-api-python-flask-mocking/#0",
    "title": "Create your first API with Flask (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "In this guide, you will learn how to create a basic REST API using Flask microframework for Python. Flask is one of the most popular and easy-to-use Python libraries for API creation.  Before continuing, you can learn more about REST APIs in general, how they work, their components, etc. in our series of tutorials    Creating an API using this library is easy, straightforward, and only requires the following basic steps.",
    "link": "/tutorials/create-api-python-flask-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-api-python-flask-mocking/#1-initialize-your-new-python-application",
    "title": "Create your first API with Flask (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To create a simple API using Flask, we first need to verify that Python and pip are installed by running the following commands:  $ python --version Python 3.10.4  $ pip --version pip 22.0.4 from /usr/lib/python3/dist-packages/pip (python 3.10)  Go to Python's website to install Python and pip if one of the above commands is unsuccessful.  After verifying that Python and pip are installed, you can install flask by running the following command:  $ pip install flask Collecting flask ... Successfully installed Jinja2-3.1.1 MarkupSafe-2.1.1 Werkzeug-2.1.1 click-8.1.2 colorama-0.4.4 flask-2.1.1 itsdangerous-2.1.2",
    "link": "/tutorials/create-api-python-flask-mocking/",
    "sectionTitle": "1. Initialize your new Python application",
    "sectionAnchor": "1-initialize-your-new-python-application",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-api-python-flask-mocking/#2-create-a-flask-web-server",
    "title": "Create your first API with Flask (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Before coding our Flask server, we first need to create a new python file. Let's name it api.py and create it in a new folder of your choice.  In this file, we need to import the Flask class from the Flask library by using Python's import command:  from flask import Flask  It will allow us to instantiate and run a web server instance.  We can now instantiate a new webserver instance by using the Flask class we previously imported, and pass the current module name:  from flask import Flask  app = Flask(__name__);",
    "link": "/tutorials/create-api-python-flask-mocking/",
    "sectionTitle": "2. Create a Flask web server",
    "sectionAnchor": "2-create-a-flask-web-server",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-api-python-flask-mocking/#3-add-api-routes-and-return-json-data",
    "title": "Create your first API with Flask (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We are now ready to add API routes to our webserver by using Flask's route() decorator with a path and a list of HTTP methods or verbs (GET, PUT, POST, etc.) as parameters:  from flask import Flask  app = Flask(__name__);  @app.route('/users', methods=['GET']) def get_users():   return 'Get users'   @app.route('/users', methods=['DELETE']) def delete_user():   return 'Delete a user'  This code will enable calls to the /users API route for both the GET and DELETE methods.  To return JSON data, we will need to import jsonify, a function from Flask that can convert lists and dictionaries to JSON and send it in the response together with the correct Content-Type header (application/json):  from flask import Flask, jsonify  app = Flask(__name__);  @app.route('/users', methods=['GET']) def get_users():   return jsonify([         {'id': 546, 'username': 'John'},         {'id': 894, 'username': 'Mary'},         {'id': 326, 'username': 'Jane'}     ])   @app.route('/users', methods=['DELETE']) def delete_user():     return jsonify({'result': 'success'})  Of course, this code is quite basic, and the two routes we created should probably load the list of users and delete users from a database before returning a result. But this is out of the scope of this small tutorial.",
    "link": "/tutorials/create-api-python-flask-mocking/",
    "sectionTitle": "3. Add API routes and return JSON data",
    "sectionAnchor": "3-add-api-routes-and-return-json-data",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-api-python-flask-mocking/#4-run-your-api-web-server",
    "title": "Create your first API with Flask (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "One last line of code is required for our code to run the webserver:  app.run()  Calling Flask instance run() function will run the webserver and listen on the default port 5000.  Here is the final code after putting everything together:  from flask import Flask, jsonify  app = Flask(__name__);  @app.route('/users', methods=['GET']) def get_users():   return jsonify([         {'id': 546, 'username': 'John'},         {'id': 894, 'username': 'Mary'},         {'id': 326, 'username': 'Jane'}     ])   @app.route('/users', methods=['DELETE']) def delete_user():     return jsonify({'result': 'success'})  app.run()  You can now run your server with the following command:  python api.py  Your API is available on http://localhost:5000. You can do a test call to the following API endpoints GET /users and DELETE /users using your favorite tool (here, Insomnia) and see the returned response:  Get users call response preview  Delete users call response preview",
    "link": "/tutorials/create-api-python-flask-mocking/",
    "sectionTitle": "4. Run your API web server",
    "sectionAnchor": "4-run-your-api-web-server",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-api-python-flask-mocking/#speed-up-development-with-api-mocking",
    "title": "Create your first API with Flask (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Working with an API can be challenging. It could be unavailable for various reasons: the whole API is under development, some routes are missing, the documentation is outdated, the access is restricted to the production environment or behind a firewall, etc.  Instead of waiting for the API to be ready to be able to consume it, you could mock it using an API mocking tool like Mockoon.  API mocking is a technique that consists in imitating an unavailable API by simulating the endpoints and their responses. With this technique, you can have a running mock in no time and start calling it right away from your front-end or back-end application.  Mocking an API with Mockoon is easy and requires only some small steps to start working.  To learn more about setting up Mockoon and creating your first fake API in less than 5 minutes, head over to our getting start tutorial    #sub#API mocking with Mockoon",
    "link": "/tutorials/create-api-python-flask-mocking/",
    "sectionTitle": "Speed up development with API mocking",
    "sectionAnchor": "speed-up-development-with-api-mocking",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#0",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "In this tutorial, you will learn how to create a basic REST API using PHP's Laravel framework. Laravel is one of the most popular PHP frameworks for web application development and REST API creation.  Before continuing, you can learn more about REST APIs in general, how they work, their components, etc. in our series of tutorials    Creating an API using this framework is easy, straightforward, and only requires the following basic steps.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#1-verify-that-php-and-composer-are-installed",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To create a simple API using Laravel, we first need to verify that PHP and composer are installed by running the following commands:  $ php -v PHP 8.1.6 (cli) (built: May 11 2022 08:55:59) (ZTS Visual C++ 2019 x64) Copyright (c) The PHP Group Zend Engine v4.1.6, Copyright (c) Zend Technologies  $ composer -v    ______   / ____/___  ____ ___  ____  ____  ________  _____  / /   / __ \\/ __ `__ \\/ __ \\/ __ \\/ ___/ _ \\/ ___/ / /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ / \\____/\\____/_/ /_/ /_/ .___/\\____/____/\\___/_/                     /_/ Composer version 2.3.10 2022-07-13 15:48:23  Go to the PHP and Composer website download pages if the above commands are unsuccessful.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "1. Verify that PHP and Composer are installed",
    "sectionAnchor": "1-verify-that-php-and-composer-are-installed",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#2-generate-a-new-application-with-composer",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To generate a new Laravel application, we will use Composer. It will automatically install the required dependencies and create an application skeleton. To create this new application, run the following command in any folder of your choice:  $ composer create-project laravel/laravel my-api Creating a \"laravel/laravel\" project at \"./my-api\" Installing laravel/laravel (v9.3.2)   - Downloading laravel/laravel (v9.3.2) ...  You can rename the application by modifying my-api to the name of your choice. Composer will create a new folder containing the scaffolded application.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "2. Generate a new application with Composer",
    "sectionAnchor": "2-generate-a-new-application-with-composer",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#3-create-a-new-controller",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To add routes to our REST API, we first need to create a new controller. To do so, run the following command:  $ php artisan make:controller API/UsersController --api    INFO  Controller created successfully.  It will create a new API controller UsersController in a subfolder of the ./app/Http/Controllers folder. Thanks to the --api flag, the controller code will be stripped out of unnecessary methods.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "3. Create a new controller",
    "sectionAnchor": "3-create-a-new-controller",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#4-create-a-new-route",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Next, we will need to add a new route pointing to our UsersController. To do so, open the ./routes/api.php file, and add the following lines:  use App\\Http\\Controllers\\API\\UsersController;  Route::apiResource(\"users\", UsersController::class);  You can verify that your API route were added by listing them using the following command:  $ php artisan route:list    GET|HEAD        / ............................................................   GET|HEAD        api/user .....................................................   GET|HEAD        api/users ............ users.index ‚Ä∫ API\\UsersController@index   POST            api/users ............ users.store ‚Ä∫ API\\UsersController@store   GET|HEAD        api/users/{user} ....... users.show ‚Ä∫ API\\UsersController@show   PUT|PATCH       api/users/{user} ... users.update ‚Ä∫ API\\UsersController@update   DELETE          api/users/{user} . users.destroy ‚Ä∫ API\\UsersController@destroy                                                              Showing [7] routes  You may have more routes showing in this list depending on your configuration.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "4. Create a new route",
    "sectionAnchor": "4-create-a-new-route",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#5-serve-the-application-and-test-the-endpoint",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We now have a basic setup that allows us to serve the application and test our endpoints.  To serve the PHP Laravel application, run the following command:  $ php artisan serve    INFO  Server running on [http://127.0.0.1:8000].  Your API is available on http://localhost:8000/api/xxxx. You can now check that you are receiving a successful response (status code 200) when calling the /api/users endpoint with your favorite API testing tool (here Insomnia): Get users call response test",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "5. Serve the application and test the endpoint",
    "sectionAnchor": "5-serve-the-application-and-test-the-endpoint",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#6-add-some-fake-data-json-to-the-get-users-endpoints",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We will not create a Model or connect the controller to a database in this tutorial. We will only return some fake JSON data from the API endpoints.  Let's return a list of users from the GET /users route by returning a simple PHP object from the controller's index method:  /**  * Display a listing of the resource.  *  * @return \\Illuminate\\Http\\Response  */ public function index() {     $object = [         (object) [             'id' => 546,             'username' => 'John',         ],         (object) [             'id' => 894,             'username' => 'Mary',         ],         (object) [             'id' => 326,             'username' => 'Jane',         ]     ];      return response()->json($object); }  We can also return a JSON message from the DELETE /users route by returning a simple success message from the controller's destroy method:  /**  * Remove the specified resource from storage.  *  * @param  int  $id  * @return \\Illuminate\\Http\\Response  */ public function destroy($id) {     return response()->json((object) [         'result' => 'success'     ]); }  Note that Laravel will automatically handle the JSON serialization of our objects and send the correct Content-Type: application/json header as we use the response()->json() function.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "6. Add some fake data JSON to the `GET /users` endpoints",
    "sectionAnchor": "6-add-some-fake-data-json-to-the-get-users-endpoints",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#7-test-your-endpoints",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "You can do a test call to the following API endpoints GET /users and DELETE /users and see the returned response:  Get users call response preview  Delete users call response preview  Of course, this code is quite basic, and the two routes we created should probably load the list of users and delete users from a database before returning a result. But this is out of the scope of this small tutorial.",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "7. Test your endpoints",
    "sectionAnchor": "7-test-your-endpoints",
    "score": 9,
    "groupScore": 7
  },
  {
    "objectID": "/tutorials/create-api-php-laravel-mocking/#speed-up-development-with-api-mocking",
    "title": "Create your first API with PHP Laravel (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Working with an API can be challenging. It could be unavailable for various reasons: the whole API is under development, some routes are missing, the documentation is outdated, the access is restricted to the production environment or behind a firewall, etc.  Instead of waiting for the API to be ready to be able to consume it, you could mock it using an API mocking tool like Mockoon.  API mocking is a technique that consists in imitating an unavailable API by simulating the endpoints and their responses. With this technique, you can have a running mock in no time and start calling it right away from your front-end or back-end application.  Mocking an API with Mockoon is easy and requires only some small steps to start working.  To learn more about setting up Mockoon and creating your first fake API in less than 5 minutes, head over to our getting start tutorial    #sub#API mocking with Mockoon",
    "link": "/tutorials/create-api-php-laravel-mocking/",
    "sectionTitle": "Speed up development with API mocking",
    "sectionAnchor": "speed-up-development-with-api-mocking",
    "score": 9,
    "groupScore": 8
  },
  {
    "objectID": "/tutorials/create-api-nodejs-express-mocking/#0",
    "title": "Create your first API with Express (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "In this tutorial, you will learn how to create a small REST API using the Express library for Node.js. Express is one of the most popular libraries for API creation. It is also available in some major Cloud functions providers like Firebase.  Before continuing, you can learn more about REST APIs in general, how they work, their components, etc. in our series of tutorials    Creating an API using this library is easy, straightforward, and only requires the following basic steps.",
    "link": "/tutorials/create-api-nodejs-express-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-api-nodejs-express-mocking/#1-create-a-new-npm-application",
    "title": "Create your first API with Express (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To create a simple API using Express, we first need to initialize a new NPM application.  To do so, first verify that Node.js and NPM are installed by running the following commands:  $ node -v  v16.14.0  $ npm -v  7.24.1  Go to Node.js' website to install Node.js and NPM if it is not already done.  After verifying that Node.js and NPM are installed, you can initialize a new NPM application by running the npm init command in a new folder. For this tutorial, you can safely ignore all the questions that NPM will ask and press Enter for each of them. You can also run npm init --yes to automatically answer all the questions with the default values.  $ npm init --yes Wrote to ./new-app/package.json:  {   \"name\": \"new-app\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"   },   \"keywords\": [],   \"author\": \"\",   \"license\": \"ISC\" }",
    "link": "/tutorials/create-api-nodejs-express-mocking/",
    "sectionTitle": "1. Create a new NPM application",
    "sectionAnchor": "1-create-a-new-npm-application",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-api-nodejs-express-mocking/#2-create-a-new-express-server",
    "title": "Create your first API with Express (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Before coding our Express server, we first need to create a new javascript file. Let's name it index.js and put it next to our package.json file.  In this file, we need to load the Express library by using Node.js' require() function:  const express = require('express');  It will allow us to instantiate the library and listen on a port on the current machine (your development computer or a server if the code is deployed). To instantiate an instance of Express, we need to execute the function that was returned by the library and store the result in a variable. Then, we can listen to a specific port on the machine, here port 3000, using the Express instance (app) listen() method:  const express = require('express');  const app = express();  app.listen(3000, () => {   console.log('Our app is listening for request on port 3000'); });",
    "link": "/tutorials/create-api-nodejs-express-mocking/",
    "sectionTitle": "2. Create a new Express server",
    "sectionAnchor": "2-create-a-new-express-server",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-api-nodejs-express-mocking/#3-add-api-routes",
    "title": "Create your first API with Express (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We are now ready to add API routes to our small server by using Express methods that match the HTTP methods or verbs (GET, PUT, POST, etc.). Depending on the route you want to create, GET /users, POST /invoices, etc. you can use the corresponding method with the path as a parameter:  const express = require('express'); const app = express();  // new API route: GET /users, returning a list of users app.get('/users', (request, response) => {   response.json([     { id: 546, username: 'John' },     { id: 894, username: 'Mary' },     { id: 326, username: 'Jane' }   ]); });  // DELETE user app.delete('/users', (request, response) => {   response.json({ result: 'success' }); });  app.listen(3000, () => {});  Of course, this code is quite basic, and the two routes we created should probably load the list of users and delete users from a database before returning a result. But this is out of the scope of this small tutorial.",
    "link": "/tutorials/create-api-nodejs-express-mocking/",
    "sectionTitle": "3. Add API routes",
    "sectionAnchor": "3-add-api-routes",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-api-nodejs-express-mocking/#4-call-your-api",
    "title": "Create your first API with Express (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Your API is now available on http://localhost:3000. You can do a test call to the following API endpoints GET /users and DELETE /users using your favorite tool (here Insomnia) and see the returned response:  Get users call response preview  Delete users call response preview",
    "link": "/tutorials/create-api-nodejs-express-mocking/",
    "sectionTitle": "4. Call your API",
    "sectionAnchor": "4-call-your-api",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-api-nodejs-express-mocking/#speed-up-development-with-api-mocking",
    "title": "Create your first API with Express (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Working with an API can be challenging. It could be unavailable for various reasons: the whole API is under development, some routes are missing, the documentation is outdated, the access is restricted to the production environment or behind a firewall, etc.  Instead of waiting for the API to be ready to be able to consume it, you could mock it using an API mocking tool like Mockoon.  API mocking is a technique that consists in imitating an unavailable API by simulating the endpoints and their responses. With this technique, you can have a running mock in no time and start calling it right away from your front-end or back-end application.  Mocking an API with Mockoon is easy and requires only some small steps to start working.  To learn more about setting up Mockoon and creating your first fake API in less than 5 minutes, head over to our getting start tutorial    #sub#API mocking with Mockoon",
    "link": "/tutorials/create-api-nodejs-express-mocking/",
    "sectionTitle": "Speed up development with API mocking",
    "sectionAnchor": "speed-up-development-with-api-mocking",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#0",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "In this tutorial, you will learn how to create a basic REST API using Java's Spring framework. Spring is one of the most popular Java frameworks for web applications development and REST API creation.  Before continuing, you can learn more about REST APIs in general, how they work, their components, etc. in our series of tutorials    Creating an API using this framework is easy, straightforward, and only requires the following basic steps.",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#1-verify-that-the-jdk-is-installed",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To create a simple API using Spring, we first need to verify that the JDK is installed by running the following command:  $ javac -version javac 18.0.1  Go to Oracle's website to install the JDK if the above command is unsuccessful.",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "1. Verify that the JDK is installed",
    "sectionAnchor": "1-verify-that-the-jdk-is-installed",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#2-generate-a-new-application-with-spring-initializr",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To speed up development, we can use Spring's own application generator called Spring Initializr to generate a new application with all the configuration needed to create an API. Please note that we are adding Spring Web as a dependency which contains all the needed libraries to create web applications and APIs. We didn't modify any other options except the Java version (18).  Generate an application with Spring Initializr  After clicking on the \"Generate\" button, the generator will download a zip file containing a new project. Extract it, and open the project with your favorite IDE (IntelliJ, Eclipse, etc.).",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "2. Generate a new application with Spring Initializr",
    "sectionAnchor": "2-generate-a-new-application-with-spring-initializr",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#3-add-a-new-spring-controller",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To be able to add routes to our new API, we first need to create a new controller. To do so, create a new 'UsersController.java' file in your ./src/main/java/com/example/demo folder.  In this file, we first need to use the same package name as the main DemoApplication.java file and import the relevant annotations, GetMapping and RestController:  package com.example.demo;  import org.springframework.web.bind.annotation.RestController;  We can then create a new UsersController class to handle our /users routes:  package com.example.demo;  import org.springframework.web.bind.annotation.RestController;  @RestController public class UsersController {  }  The class needs to be annotated with @RestController. It allows Spring to use our class as a web requests handler.",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "3. Add a new Spring controller",
    "sectionAnchor": "3-add-a-new-spring-controller",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#3-add-api-routes-and-return-json-data",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We are now ready to add API routes to our controller by adding methods and Spring annotations. There are annotations for each type of HTTP method, @GetMapping, @PostMapping, etc.  package com.example.demo;  import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.RestController;  @RestController public class UsersController {   @GetMapping(\"/users\")   public String getUsers() {     return \"Get users\";   }    @DeleteMapping(\"/users\")   public String deleteUser() {     return \"Delete a user\";   } }  This code will enable calls to the /users API route for both the GET and DELETE HTTP methods and use respectively the getUsers and deleteUser methods to handle the requests on those routes. For now, our routes only return simple strings. Let's return a list of users from the GET /users route by adding a simple User class and modifying our getUsers method accordingly:  package com.example.demo;  import java.util.ArrayList; import java.util.List;  import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.RestController;  class User {   public int id;   public String username;    public User(int id, String username) {     this.id = id;     this.username = username;   } }  @RestController public class UsersController {   @GetMapping(\"/users\")   public List<User> getUsers() {     List<User> list = new ArrayList<User>();     list.add(new User(546, \"John\"));     list.add(new User(894, \"Mary\"));     list.add(new User(326, \"Jane\"));     return list;   }    @DeleteMapping(\"/users\")   public String deleteUser() {     return \"Delete a user\";   } }  We can also return a JSON message from the DELETE /users route by returning a simple Map:  package com.example.demo;  import org.springframework.web.bind.annotation.GetMapping;  import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Map;  import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.RestController;  class User {   public int id;   public String username;    public User(int id, String username) {     this.id = id;     this.username = username;   } }  @RestController public class UsersController {    @GetMapping(\"/users\")   public List<User> getUsers() {     List<User> list = new ArrayList<User>();     list.add(new User(546, \"John\"));     list.add(new User(894, \"Mary\"));     list.add(new User(326, \"Jane\"));     return list;   }    @DeleteMapping(\"/users\")   public Map<String, String> deleteUser() {     return Collections.singletonMap(\"result\", \"success\");   } }  Please note that Spring will automatically handle the JSON serialization of our lists and objects and send the correct Content-Type: application/json header.  Of course, this code is quite basic, and the two routes we created should probably load the list of users and delete users from a database before returning a result. But this is out of the scope of this small tutorial.",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "3. Add API routes and return JSON data",
    "sectionAnchor": "3-add-api-routes-and-return-json-data",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#4-run-your-web-server",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "You can now run your new API server by running the following Maven command:  $ ./mvnw spring-boot:run ... [INFO] Building demo 0.0.1-SNAPSHOT ...   .   ____          _            __ _ _  /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\  \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::                (v2.6.7) ... 2022-04-27 08:57:58.474  INFO 1736 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet: Completed initialization in 0 ms  Your API is available on http://localhost:8080. You can do a test call to the following API endpoints GET /users and DELETE /users using your favorite tool (here, Insomnia) and see the returned response:  Get users call response preview  Delete users call response preview",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "4. Run your web server",
    "sectionAnchor": "4-run-your-web-server",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-api-java-spring-mocking/#speed-up-development-with-api-mocking",
    "title": "Create your first Java Spring API (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Working with an API can be challenging. It could be unavailable for various reasons: the whole API is under development, some routes are missing, the documentation is outdated, the access is restricted to the production environment or behind a firewall, etc.  Instead of waiting for the API to be ready to be able to consume it, you could mock it using an API mocking tool like Mockoon.  API mocking is a technique that consists in imitating an unavailable API by simulating the endpoints and their responses. With this technique, you can have a running mock in no time and start calling it right away from your front-end or back-end application.  Mocking an API with Mockoon is easy and requires only some small steps to start working.  To learn more about setting up Mockoon and creating your first fake API in less than 5 minutes, head over to our getting start tutorial    #sub#API mocking with Mockoon",
    "link": "/tutorials/create-api-java-spring-mocking/",
    "sectionTitle": "Speed up development with API mocking",
    "sectionAnchor": "speed-up-development-with-api-mocking",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#0",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "In this tutorial, you will learn how to create a basic REST API using the Go language and its HTTP web framework, Gin. Golang is an open-source language supported by Google. Its simplicity and versatility make it very popular. As in any other language, you can create any application, like REST APIs.  Before continuing, you can learn more about REST APIs in general, how they work, their components, etc. in our series of tutorials    Creating an API using this framework is easy, straightforward, and only requires the following basic steps.",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#1-verify-that-go-is-installed",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To create a simple API using Go, we first need to verify that it is installed on your computer by running the following commands:  $ go version go version go1.19 windows/amd64  Go to the Golang website download page if the above command is unsuccessful.",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "1. Verify that Go is installed",
    "sectionAnchor": "1-verify-that-go-is-installed",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#2-create-a-new-go-file-and-a-new-module",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "To create a new Go application, you first need to create a new Go file in the folder of your choice. Let's name it main.go and add the following package declaration:  package main  We will also need to create a module to manage our dependencies. To do so, run the following command in the same folder:  $ go mod init tutorial/api go: creating new go.mod: module tutorial/api go: to add module requirements and sums:         go mod tidy",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "2. Create a new Go file and a new module",
    "sectionAnchor": "2-create-a-new-go-file-and-a-new-module",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#3-add-the-required-dependencies",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "As we will be using Gin to create our HTTP server, we need to add it as a dependency with net/http. To do so, add the following lines in the main.go file:  package main  import (     \"net/http\"     \"github.com/gin-gonic/gin\" )",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "3. Add the required dependencies",
    "sectionAnchor": "3-add-the-required-dependencies",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#4-add-the-main-method-and-create-a-web-server",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "In our main.go file, we need to create a main() function that will be called on startup and initialize and run our HTTP server:  func main() {     router := gin.Default()      // TODO define routes      router.Run(\"localhost:8080\") }  This code will initialize a new Gin router and start the HTTP server on port 8080.",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "4. Add the main method and create a web server",
    "sectionAnchor": "4-add-the-main-method-and-create-a-web-server",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#5-create-fake-data-for-the-get-route",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We will not cover the setup and connection to a database in this tutorial. We will directly store and return fake data from a GET /users route.  First we need to declare a user struct to use with our in-memory data. Add the following code after the import section:  type user struct {     Id        int     `json:\"id\"`     Username  string  `json:\"username\"` }  Then, we can create a variable holding some random user data, here, an array of users with an id and a username:  var users = []user{     {Id: \"546\", Username: \"John\"},     {Id: \"894\", Username: \"Mary\"},     {Id: \"326\", Username: \"Jane\"}, }",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "5. Create fake data for the GET route",
    "sectionAnchor": "5-create-fake-data-for-the-get-route",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#6-create-a-get-route",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Next, we will need to add a new GET /users route returning our fake data. To do so, we need to use router.GET in the main function, and add a getUsers function returning our fake data formatted as JSON:  func getUsers(c *gin.Context) {     c.IndentedJSON(http.StatusOK, users) }  func main() {     router := gin.Default()      // new `GET /users` route associated with our `getUsers` function     router.GET(\"/users\", getUsers)      router.Run(\"localhost:8080\") }  Here is the full and final code of our small web server and GET /users route:  package main  import (     \"net/http\"     \"github.com/gin-gonic/gin\" )  type user struct {     Id        int     `json:\"id\"`     Username  string  `json:\"username\"` }  var users = []user{     {Id: 546, Username: \"John\"},     {Id: 894, Username: \"Mary\"},     {Id: 326, Username: \"Jane\"}, }  func getUsers(c *gin.Context) {     c.IndentedJSON(http.StatusOK, users) }  func main() {     router := gin.Default()      // new `GET /users` route associated with our `getUsers` function     router.GET(\"/users\", getUsers)      router.Run(\"localhost:8080\") }",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "6. Create a GET route",
    "sectionAnchor": "6-create-a-get-route",
    "score": 9,
    "groupScore": 6
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#7-track-dependency",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Before running our code, we must track the Gin module as a dependency. For this, run the following command:  $ go get . go: downloading github.com/gin-gonic/gin v1.8.1 ... go: added github.com/gin-gonic/gin v1.8.1 ...  This will add the Gin module as a dependency of our module.",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "7. Track dependency",
    "sectionAnchor": "7-track-dependency",
    "score": 9,
    "groupScore": 7
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#8-run-the-server",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "We now have a basic setup that allows us to run the application and test our endpoints.  To run the Golang application and Gin HTTP server, run the following command:  $ go run . ... [GIN-debug] GET    /users       --> main.getUsers (3 handlers) ...  You can verify that your routes are correctly created in the debug output of the command. Your API is now available on http://localhost:8080.",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "8. Run the server",
    "sectionAnchor": "8-run-the-server",
    "score": 9,
    "groupScore": 8
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#7-test-your-endpoints",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "You can do a test call to the following GET /users endpoint and see the returned response:  Get users call response preview  Of course, this code is quite basic, and the route we created should probably load the list of users from a database before returning a result. But this is out of the scope of this small tutorial.",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "7. Test your endpoints",
    "sectionAnchor": "7-test-your-endpoints",
    "score": 9,
    "groupScore": 9
  },
  {
    "objectID": "/tutorials/create-api-golang-mocking/#speed-up-development-with-api-mocking",
    "title": "Create your first API with the Golang Gin (or mock it using Mockoon!)",
    "category": "tutorials",
    "content": "Working with an API can be challenging. It could be unavailable for various reasons: the whole API is under development, some routes are missing, the documentation is outdated, the access is restricted to the production environment or behind a firewall, etc.  Instead of waiting for the API to be ready to be able to consume it, you could mock it using an API mocking tool like Mockoon.  API mocking is a technique that consists in imitating an unavailable API by simulating the endpoints and their responses. With this technique, you can have a running mock in no time and start calling it right away from your front-end or back-end application.  Mocking an API with Mockoon is easy and requires only some small steps to start working.  To learn more about setting up Mockoon and creating your first fake API in less than 5 minutes, head over to our getting start tutorial    #sub#API mocking with Mockoon",
    "link": "/tutorials/create-api-golang-mocking/",
    "sectionTitle": "Speed up development with API mocking",
    "sectionAnchor": "speed-up-development-with-api-mocking",
    "score": 9,
    "groupScore": 10
  },
  {
    "objectID": "/tutorials/angular-api-call-and-mocking/#0",
    "title": "Call a mock API from your Angular application",
    "category": "tutorials",
    "content": "In this guide, we will learn how to call a REST API from an Angular application. If you already have an existing API that you want to use, you can skip the first step, in which we create a fake REST API using Mockoon.",
    "link": "/tutorials/angular-api-call-and-mocking/",
    "sectionTitle": "",
    "sectionAnchor": "",
    "score": 9,
    "groupScore": 0
  },
  {
    "objectID": "/tutorials/angular-api-call-and-mocking/#1-create-a-mock-api-endpoint-with-mockoon",
    "title": "Call a mock API from your Angular application",
    "category": "tutorials",
    "content": "During the development of your Angular application, you may need to mock an API that is not ready yet, or only partially available (see partial mocking with the proxy mode). For this, the easiest way is to create a mock API using a tool like Mockoon. (Read more about the benefits of API mocking).  To learn more about how to set up your first mock API with Mockoon, head over to the Getting started tutorial.    For the rest of the tutorial, we will use an array of fake blog posts. In Mockoon, create a GET /posts API endpoint that returns an array of blog posts:  create a mock API endpoint  You can use the following JSON as the body returned by the endpoint:  [   {     \"id\": 1,     \"title\": \"My first blog post\"   },   {     \"id\": 2,     \"title\": \"My second blog post\"   } ]  Note that your fake mock server will be available at the following URL: http://localhost:3000. This is the URL we will need to use in our Angular service.",
    "link": "/tutorials/angular-api-call-and-mocking/",
    "sectionTitle": "1. Create a mock API endpoint with Mockoon",
    "sectionAnchor": "1-create-a-mock-api-endpoint-with-mockoon",
    "score": 9,
    "groupScore": 1
  },
  {
    "objectID": "/tutorials/angular-api-call-and-mocking/#2-make-a-call-to-the-api-endpoint-in-your-angular-service",
    "title": "Call a mock API from your Angular application",
    "category": "tutorials",
    "content": "After creating a mock API endpoint in Mockoon, you can now call it from your Angular service. To do so, we need to inject and use Angular's HttpClient:  import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http';  @Injectable() export class PostsService {   constructor(private http: HttpClient) {} }  We then need to add a getPosts method that will return an Observable containing our list of posts:  getPosts(): Observable<{ id: number; title: string }> {   return this.http.get('http://localhost:3000/posts'); }  Below is our service after putting the two pieces of code together:  import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http';  @Injectable() export class PostsService {   constructor(private http: HttpClient) {}    getPosts(): Observable<{ id: number; title: string }[]> {     return this.http.get('http://localhost:3000/posts');   } }",
    "link": "/tutorials/angular-api-call-and-mocking/",
    "sectionTitle": "2. Make a call to the API endpoint in your Angular service",
    "sectionAnchor": "2-make-a-call-to-the-api-endpoint-in-your-angular-service",
    "score": 9,
    "groupScore": 2
  },
  {
    "objectID": "/tutorials/angular-api-call-and-mocking/#3-subscribe-to-the-observable-in-your-component",
    "title": "Call a mock API from your Angular application",
    "category": "tutorials",
    "content": "In any component where we need to display the list of posts, we can now inject our PostsService and call our getPosts method:  import { Component, OnInit } from '@angular/core'; import { PostsService } from '../services/posts-service.ts';  @Component({   selector: 'app-posts',   templateUrl: './posts.component.html' }) export class PostsComponent implements OnInit {   constructor(private postsService: PostsService) {}    ngOnInit() {     // subscribe to the Observable to make the HTTP call     this.postsService.getPosts().subscribe((posts) => {       // we received our posts!       console.log(posts);     });   } }",
    "link": "/tutorials/angular-api-call-and-mocking/",
    "sectionTitle": "3. Subscribe to the Observable in your component",
    "sectionAnchor": "3-subscribe-to-the-observable-in-your-component",
    "score": 9,
    "groupScore": 3
  },
  {
    "objectID": "/tutorials/angular-api-call-and-mocking/#use-angulars-environment-files",
    "title": "Call a mock API from your Angular application",
    "category": "tutorials",
    "content": "To avoid changing the server URL directly in the Angular service, you can put this URL in Angular's environment files. You would only need to change your environment.dev.ts and keep your other environment files and service clean.  export const environment = {   production: false,   // Your Mockoon's API URL   apiURL: 'http://localhost:3000/' };  This would require the use of environment.apiUrl in your service(s):  import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { environment } from '../environments/environment';  @Injectable() export class PostsService {   constructor(private http: HttpClient) {}    getPosts(): Observable<{ id: number; title: string }> {     return this.http.get(`${environment.apiUrl}/posts`);   } }",
    "link": "/tutorials/angular-api-call-and-mocking/",
    "sectionTitle": "Use Angular's environment files",
    "sectionAnchor": "use-angulars-environment-files",
    "score": 9,
    "groupScore": 4
  },
  {
    "objectID": "/tutorials/angular-api-call-and-mocking/#using-angulars-proxy",
    "title": "Call a mock API from your Angular application",
    "category": "tutorials",
    "content": "If you are using Angular CLI's proxy feature, you can also edit the proxy.conf.json file and set the target to point to your Mockoon's API:  {   \"/api\": {     \"target\": \"http://localhost:3000\",     \"secure\": false   } }  Do not forget to add the --proxy-config flag followed by the path to the proxy.conf.json file to your ng serve command, or to add the proxyConfig option to the serve target in your angular.json file:  ... \"architect\": {   \"serve\": {     \"builder\": \"@angular-devkit/build-angular:dev-server\",     \"options\": {       \"browserTarget\": \"your-application-name:build\",       \"proxyConfig\": \"src/proxy.conf.json\"     }, ...",
    "link": "/tutorials/angular-api-call-and-mocking/",
    "sectionTitle": "Using Angular's proxy",
    "sectionAnchor": "using-angulars-proxy",
    "score": 9,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/templating/overview/#templating-overview",
    "title": "Overview",
    "category": "docs",
    "content": "Mockoon implements Handlebars, Faker.js v8.1.0, and a set of custom helpers to create dynamic responses. This templating system is supported in the data buckets, response's body, header values, file content, file path and rule values. You will find below a global overview of how and where you can use helpers. You can also check the available helpers on specific documentation pages.",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Templating overview",
    "sectionAnchor": "templating-overview",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/templating/overview/#handlebars-syntax",
    "title": "Overview",
    "category": "docs",
    "content": "All the helpers must be used according to Handlebars' syntax, for example: {{helperName param1 param2}}. Some helpers accepting options objects can be used with Handlebars' object params: {{faker 'date.month' abbr=false}}.  Please note that a space always follows the helper name and separates each and all params like in oneOf *space* (array *space* 'item1' *space* 'item2'). Also, parenthesis serves to prioritize a helper over another but not to symbolize a function call. Helpers do not require parenthesis in order to work.  All Handlebars helpers are available (if, each, etc.). For more information, please have a look at Handlebars' documentation.",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Handlebars syntax",
    "sectionAnchor": "handlebars-syntax",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/templating/overview/#special-characters-escaping",
    "title": "Overview",
    "category": "docs",
    "content": "Handlebars will escape special characters (& < > \" ' ` =) by default. If you want to avoid this behavior, you can use the triple curly braces syntax:{{{helperName}}}.",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Special characters escaping",
    "sectionAnchor": "special-characters-escaping",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/templating/overview/#available-helpers",
    "title": "Overview",
    "category": "docs",
    "content": "Besides Handlebars built-in helpers, Mockoon offers many of them:  custom helpers request helpers response helpers Faker.js library helpers",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Available helpers",
    "sectionAnchor": "available-helpers",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/templating/overview/#body-and-file-content-templating",
    "title": "Overview",
    "category": "docs",
    "content": "Templating will work in the body editor without consideration for the Content-Type that has been defined. It will also work with files content for a limited set of MIME types (application/json, text/html, text/css, text/csv, application/javascript, application/typescript, text/plain, application/xhtml+xml, application/xml).  Here is an example of what you can do with this templating system:  {   \"userId\": \"{{urlParam 'id'}}\",   \"name\": \"{{queryParam 'name' 'John'}}\",   \"lang\": \"{{{header 'Accept-Language' 'en'}}}\",   \"elementTitle\": \"{{body 'elements.0.title' 'default'}}\",   \"ip\": \"{{ip}}\",   \"method\": \"{{method}}\",   \"hostname\": \"{{hostname}}\",   \"friends\": [     {{#repeat 2}}     {        \"id\": {{@index}},        \"name\": \"{{faker 'person.firstName'}} {{faker 'person.lastName'}}\"      }     {{/repeat}}   ],    \"oneItem\": \"{{oneOf (array 'item1' 'item2' 'item3')}}\",    \"someItemsAsString\": \"{{someOf (array 'item1' 'item2' 'item3') 1 2}}\",    \"someItemsAsArray\": {{{someOf (array 'item1' 'item2' 'item3') 1 2 true}}},    \"userName\":      {{#switch (urlParam 'id')}}       {{#case '1'}}\"John\"{{/case}}       {{#case '2'}}\"Jack\"{{/case}}       {{#default}}\"Peter\"{{/default}}     {{/switch}} }  body editor content  The above template produces the following body with this request:  GET /user/123456?name=john Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7  {   \"element\": [     {\"title\": \"My title\"}   ] }  Response:  {   \"userId\": \"5\",   \"name\": \"john\",   \"lang\": \"fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7\",   \"elementTitle\": \"My title\",   \"ip\": \"::1\",   \"method\": \"GET\",   \"hostname\": \"localhost\",   \"friends\": [     {       \"id\": 0,       \"name\": \"Stephen Bradbury\"     },     {       \"id\": 1,       \"name\": \"Warren Caffey\"     }   ],   \"oneItem\": \"item1\",   \"someItemsAsString\": \"item2\",   \"someItemsAsArray\": [\"item2\", \"item3\"],   \"userName\": \"John\" }  This system is flexible enough to generate a lot of different contents like CSV files:  firstname,lastname,countryCode {{#repeat 10}}   {{faker 'person.firstName'}},{{faker 'person.lastName'}},{{faker     'location.countryCode'   }} {{/repeat}}  Response:  firstname,lastname,countryCode Max,Magby,AZ Stan,Muldoon,HM Drew,Rebelo,CY Cory,Neal,BG Grace,Whitson,CY Haydee,Backer,ET Erik,Friedrich,MX Stephen,Paquette,PH Neida,Durrett,PN Vaughn,Neal,MO",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Body and file content templating",
    "sectionAnchor": "body-and-file-content-templating",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/templating/overview/#base64-encoding",
    "title": "Overview",
    "category": "docs",
    "content": "By using the base64 helper, you can encode parts or entirety of the response by enclosing the content in a block helper. Inline helper:  {{base64 'test'}} {{base64 (body 'path.to.property')}}  Block helper:  {{# base64}} firstname,lastname,countryCode {{# repeat 10 }} {{ faker 'person.firstName' }},{{ faker 'person.lastName' }},{{ faker 'location.countryCode' }} {{/ repeat}} {{/ base64}}",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Base64 encoding",
    "sectionAnchor": "base64-encoding",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/templating/overview/#disable-body-and-file-templating",
    "title": "Overview",
    "category": "docs",
    "content": "Templating can be disabled for the body and file content in each route response separately. Thus, no helper will be interpreted by the templating engine.  First, open the Route response settings:  click on route response fourth settings tab  Then, disable the templating by checking the box:  check the disable templating box",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Disable body and file templating",
    "sectionAnchor": "disable-body-and-file-templating",
    "score": 10,
    "groupScore": 8
  },
  {
    "objectID": "/docs/latest/templating/overview/#file-input-templating",
    "title": "Overview",
    "category": "docs",
    "content": "Templating is also supported in the file input field. It allows to dynamically serve files depending on the request parameters, like urlParam or any other helper. Example:  If you have a set of files named ./file1.json and ./file2.json, a route param can be declared (/myroute/:id) and retrieved with the urlParam helper in the file input:  c:/.../file{{urlParam 'id'}}.json.  If you call this route with /myroute/1, ./file1.json will be sent.  add a templating helper in the file path  For more information about absolute and relative file paths, please refer to our file serving documentation.",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "File input templating",
    "sectionAnchor": "file-input-templating",
    "score": 10,
    "groupScore": 9
  },
  {
    "objectID": "/docs/latest/templating/overview/#headers-and-rule-values",
    "title": "Overview",
    "category": "docs",
    "content": "Templating helpers can also be used in the headers values both in route headers and environment headers:  add a templating helper in the header value  Finally, templating helpers can be used in the response rule values to create dynamic rules:  screenshot showing a response rule with a template helper in the value field",
    "link": "/docs/latest/templating/overview/",
    "sectionTitle": "Headers and rule values",
    "sectionAnchor": "headers-and-rule-values",
    "score": 10,
    "groupScore": 10
  },
  {
    "objectID": "/docs/latest/templating/mockoon-response-helpers/#templating-response-helpers",
    "title": "Response helpers",
    "category": "docs",
    "content": "Mockoon offers the following helpers which can customize the outgoing response:  status",
    "link": "/docs/latest/templating/mockoon-response-helpers/",
    "sectionTitle": "Templating response helpers",
    "sectionAnchor": "templating-response-helpers",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/templating/mockoon-response-helpers/#status",
    "title": "Response helpers",
    "category": "docs",
    "content": "Set the response status code. This helper does not return any content.  Arguments (ordered) Type Description 0 number Valid status code (100-999)  Examples  {{status 404}}",
    "link": "/docs/latest/templating/mockoon-response-helpers/",
    "sectionTitle": "`status`",
    "sectionAnchor": "status",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#templating-request-helpers",
    "title": "Request helpers",
    "category": "docs",
    "content": "Mockoon offers the following helpers which can return information relative to the entering request:  body bodyRaw queryParam queryParamRaw urlParam cookie header hostname ip method baseUrl",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "Templating request helpers",
    "sectionAnchor": "templating-request-helpers",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#body",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get the value at a given path from the request body if the entering Content-Type is set to application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, application/soap+xml or text/xml. This helper is designed to retrieve data to be served in a response. To reuse the retrieved data with other helpers (each, if, etc.), use the bodyRaw helper below.  The path supports two syntaxes, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Please note that XML bodies are parsed using xml-js package. Refer to this page or the package documentation for more information on how the XML is parsed and how to fetch specific properties. Please also note that multipart/form-data only supports fields. Uploaded files will be ignored. Full objects or arrays can be retrieved by the helper. The full request's raw body can also be fetched when the path is omitted ({{body}}) independently from the request's Content-Type. If no value is present at the requested path, the default value will be used. A third parameter (boolean) can be set to true to returns a stringified value even if it's a primitive.  Arguments (ordered) Type Description 0 string Path to the body property 1 string Default value if property is not found 2 boolean Stringify primitive values  Examples  {{body}}  <!-- Using object-path syntax --> {{body 'path.to.property'}} {{body 'deep.property\\.with\\.dot'}}  <!-- using JSONPath syntax --> {{body '$.array.[*].property'}}  {{body 'path' 'default value'}} {{body 'path' 'default value' true}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`body`",
    "sectionAnchor": "body",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#bodyraw",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get the raw value at a given path from the request body if the entering Content-Type is set to application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, application/soap+xml or text/xml. This \"raw\" helper is designed to work with other helpers (each, if, etc.). To directly use the retrieved data in the response, use the body helper above.  The path supports two syntaxes, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Please note that XML bodies are parsed using xml-js package. Refer to this page or the package documentation for more information on how the XML is parsed and how to fetch specific properties. Please also note that multipart/form-data only supports fields. Uploaded files will be ignored. Full objects or arrays can be retrieved by the helper. The full request's raw body can also be fetched when the path is omitted ({{bodyRaw}}) independently from the request's Content-Type. If no value is present at the requested path, the default value will be used. This helper allows the use of body within handlebars' helpers such as {{#each}} and {{#if}}.  Arguments (ordered) Type Description 0 string Path to the body property 1 string Default value if property is not found  Examples  {{bodyRaw}}  <!-- Using object-path syntax --> {{bodyRaw 'path.to.property'}} {{bodyRaw 'deep.property\\.with\\.dot'}}  <!-- using JSONPath syntax --> {{bodyRaw '$.array.[*].property'}}  {{bodyRaw 'path' 'default value'}}  {{#each (bodyRaw 'path.to.array.property' 'default value')}}   value {{/each}}  {{#if (bodyRaw 'path.to.boolean.property' 'default value')}}   value {{/if}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`bodyRaw`",
    "sectionAnchor": "bodyraw",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#queryparam",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get the value at a given path from the request's query string. Complex query strings with arrays and objects are supported. This helper is designed to retrieve data to be served in a response. To reuse the retrieved data with other helpers (each, if, etc.), use the queryParamRaw helper below.  The path supports two syntaxes, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Full objects or arrays can be retrieved by the helper. The full query string object can also be fetched when the path is omitted ({{queryParam}}). It will be stringified and can be used in a JSON body for example. If there is no value at the requested path, the default value will be used. A third parameter (boolean) can be set to true to returns a stringified value even if it's a primitive.  Arguments (ordered) Type Description 0 string Path to the query param property 1 string Default value if property is not found 2 boolean Stringify primitive values  Examples  {{queryParam}}  <!-- Using object-path syntax --> {{queryParam 'path.to.property'}} {{queryParam 'deep.property\\.with\\.dot'}}  <!-- using JSONPath syntax --> {{queryParam '$.array.[*].property'}}  {{queryParam 'path' 'default value'}} {{queryParam 'path' 'default value' true}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`queryParam`",
    "sectionAnchor": "queryparam",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#queryparamraw",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get the raw value at a given path from the request's query string. Complex query strings with arrays and objects are supported. This \"raw\" helper is designed to work with other helpers (each, if, etc.). To directly use the retrieved data in the response, use the queryParam helper above.  The path supports two syntaxes, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Full objects or arrays can be retrieved by the helper. The full query string object can also be fetched when the path is omitted ({{queryParamRaw}}). If there is no value at the requested path, the default value will be used. This helper allows the use of queryParam within handlebars' helpers such as {{#each}} and {{#if}}.  Arguments (ordered) Type Description 0 string Path to the query param property 1 string Default value if property is not found  Examples  {{queryParamRaw}}  <!-- Using object-path syntax --> {{queryParamRaw 'path.to.property'}} {{queryParamRaw 'deep.property\\.with\\.dot'}}  <!-- using JSONPath syntax --> {{queryParamRaw '$.array.[*].property'}}  {{queryParamRaw 'path' 'default value'}}  {{#each (queryParamRaw 'path.to.array.query' 'default value')}}   value {{/each}}  {{#if (queryParamRaw 'path.to.boolean.query' 'default value')}}   value {{/if}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`queryParamRaw`",
    "sectionAnchor": "queryparamraw",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#urlparam",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get a named parameter from the route /:paramName1/:paramName2.  Arguments (ordered) Type Description 0 string Route parameter name  Examples  {{urlParam 'paramName1'}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`urlParam`",
    "sectionAnchor": "urlparam",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#cookie",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get the content of a cookie or returns a default value if the cookie is not present.  Arguments (ordered) Type Description 0 string Cookie name 1 string Default value if cookie is not found  Examples  {{cookie 'cookie_name' 'default value'}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`cookie`",
    "sectionAnchor": "cookie",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#header",
    "title": "Request helpers",
    "category": "docs",
    "content": "Get content from any request header or returns a default value if header is not present.  Arguments (ordered) Type Description 0 string Header name 1 string Default value if header is not found  Examples  {{header 'Header-Name' 'default value'}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`header`",
    "sectionAnchor": "header",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#hostname",
    "title": "Request helpers",
    "category": "docs",
    "content": "Returns the request hostname.  Examples  {{hostname}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`hostname`",
    "sectionAnchor": "hostname",
    "score": 10,
    "groupScore": 8
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#ip",
    "title": "Request helpers",
    "category": "docs",
    "content": "Returns the request IP address.  Examples  {{ip}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`ip`",
    "sectionAnchor": "ip",
    "score": 10,
    "groupScore": 9
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#method",
    "title": "Request helpers",
    "category": "docs",
    "content": "Returns the request method (GET, PUT, POST, etc.).  Examples  {{method}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`method`",
    "sectionAnchor": "method",
    "score": 10,
    "groupScore": 10
  },
  {
    "objectID": "/docs/latest/templating/mockoon-request-helpers/#baseurl",
    "title": "Request helpers",
    "category": "docs",
    "content": "Returns the base URL of the request: protocol, host, port and API prefix.  Examples  {{baseUrl}}",
    "link": "/docs/latest/templating/mockoon-request-helpers/",
    "sectionTitle": "`baseUrl`",
    "sectionAnchor": "baseurl",
    "score": 10,
    "groupScore": 11
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#mockoon-templating-helpers",
    "title": "Custom helpers",
    "category": "docs",
    "content": "In addition to Handlebars' built-in helpers, Mockoon offers the following helpers:  Block helpers Data buckets repeat data switch dataRaw  Arrays Objects array object oneOf someOf join slice len filter  Math  Variables add eq setVar subtract gt getVar multiply gte divide lt modulo lte ceil toFixed floor round  Strings  Dates Misc includes concat now newline substr indexOf dateTimeShift base64 lowercase parseInt date base64Decode uppercase padStart time objectId split padEnd dateFormat stringify eq  Faker.js aliases int street hexColor float city guid boolean country ipv4 title countryCode ipv6 firstName zipcode lorem lastName postcode company lat domain long tld phone email color",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "Mockoon templating helpers",
    "sectionAnchor": "mockoon-templating-helpers",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#repeat",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Repeat the block content a random number of times if two arguments are provided, or a fixed amount of time if only one argument is provided. Set the comma parameter to false (default to true) to prevent the insertion of new lines and commas by the helper.  Parameters/arguments Type Description [0] number Minimum items 1 number Maximum items [comma=true] boolean Add trailing comma  Examples  {{#repeat 5 10 comma=true}}test{{/repeat}}  <!--  result:  test, test, test, test, test -->",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`repeat`",
    "sectionAnchor": "repeat",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#switch",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Select some content depending on a variable. Behaves like a regular switch.  Arguments (ordered) Type Description 0 any Value against which the switch matches the cases  Examples  {{#switch (urlParam 'id')}}   {{#case '1'}}\"John\"{{/case}}   {{#case '2'}}\"Jack\"{{/case}}   {{#default}}\"Peter\"{{/default}} {{/switch}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`switch`",
    "sectionAnchor": "switch",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#data",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Get the stringified value at a given path from a data bucket selected by ID or name. This helper is designed to retrieve data to be served in a response. To reuse the retrieved data with other helpers (each, if, etc.), use the dataRaw helper below.  The path supports two syntaxes, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Please note that a value can be retrieved at the path if the data bucket contains valid JSON. Full objects or arrays can be retrieved by the helper and will be stringified. The full data bucket content can be fetched when the path is omitted ({{data 'ID'}}).  Arguments (ordered) Type Description 0 string ID or name of the data bucket 1 string Path to the data bucket property  Examples  {{data 'abcd'}}  <!-- Using object-path syntax --> {{data 'abcd' 'path.to.property'}} {{data 'abcd' 'deep.property\\.with\\.dot'}}  <!-- using JSONPath syntax --> {{data 'abcd' '$.array.[*].property'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`data`",
    "sectionAnchor": "data",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#dataraw",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Get the raw value (array, object, etc.) at a given path from a data bucket selected by ID or name. This \"raw\" helper is designed to work with other helpers (each, if, etc.). To directly use the retrieved data in the response, use data buckets direct linking or the data helper above.  The path supports two syntaxes, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Please note that a value can be retrieved at the path if the data bucket contains valid JSON. Primitives and data structures can be retrieved by the helper and reused in other helpers (see example below). The full data bucket content (array, object, etc.) can be fetched when the path is omitted ({{dataRaw 'ID'}}).  Arguments (ordered) Type Description 0 string ID or name of the data bucket 1 string Path to the data bucket property  Examples  {{dataRaw 'abcd'}}  <!-- Using object-path syntax --> {{dataRaw 'abcd' 'path.to.property'}} {{dataRaw 'abcd' 'deep.property\\.with\\.dot'}}  <!-- using JSONPath syntax --> {{dataRaw 'abcd' '$.array.[*].property'}}  {{#each (dataRaw 'path.to.array.property')}}   value {{/each}}  {{#if (dataRaw 'path.to.boolean.property')}}   value {{/if}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`dataRaw`",
    "sectionAnchor": "dataraw",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#array",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Create an array from the given items. This helper is mostly used with the following helpers: oneOf, someOf.  Arguments (ordered) Type Description 0..n any Value used to populate the array  Examples  {{array 'item1' 'item2' 'item3'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`array`",
    "sectionAnchor": "array",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#oneof",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Select a random item in the array passed in parameters. oneOf will return the actual value in the array. Set the stringify parameter to true (default to false) to get a JSON stringified result.  Arguments (ordered) Type Description 0 any[] Array of values [1 = false] boolean Stringify the result  Examples  {{oneOf (array 'item1' 'item2' 'item3')}} result: item2",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`oneOf`",
    "sectionAnchor": "oneof",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#someof",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random number of items from the array passed in parameters, concatenated as a string. Use it with triple curly braces to get a JSON representation.  Arguments (ordered) Type Description 0 any[] Array of values 1 number Minimum number of items 2 number Maximum number of items [3 = false] boolean Get result as an array  Examples  {{someOf (array 'item1' 'item2' 'item3') 1 2}} result: item1,item2  <!-- Use triple curly braces to avoid character escaping --> {{{someOf (array 'item1' 'item2' 'item3') x y true}}} result: item1,item2",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`someOf`",
    "sectionAnchor": "someof",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#join",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a new string by concatenating all the elements in an array.  Arguments (ordered) Type Description 0 [] Array of values 1 string Separator  Examples  {{join (array 'item1' 'item2' 'item3') '#'}} result: item1#item2#item3",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`join`",
    "sectionAnchor": "join",
    "score": 10,
    "groupScore": 8
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#slice",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a copy of a portion of an array from start to end indexes (not included).  Arguments (ordered) Type Description 0 [] Array of values 1 number Start index 2 number End index  Examples  {{slice (array 'item1' 'item2' 'item3') 0 2}} result: ['item1', 'item2']",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`slice`",
    "sectionAnchor": "slice",
    "score": 10,
    "groupScore": 9
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#len",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return an array or string length.  Arguments (ordered) Type Description 0 [] | string Array or string  Examples  {{len (array 'item1' 'item2' 'item3')}} result: 3  {{len 'hello'}} result: 5",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`len`",
    "sectionAnchor": "len",
    "score": 10,
    "groupScore": 10
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#filter",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a filtered array. This helper can be used with data buckets, use the dataRaw for that.  Arguments (ordered) Type Description 0 any[] Input array 1..n primitive or object or array OR conditions level  The first argument is the array to be filtered. Each argument starting from index 1 is a condition filter (array 1 2 3) 1 3 5 6 .....Condition can be primitives (string, number), objects or arrays with sub-conditions. When the condition is an object, then all keys and values work as an AND. Conditions support infinite nesting of conditions using arrays. The first level of filer arguments works as OR conditions filter (array 1 2 3) 1 3 equals fo [1,2,3].filter(x => x === 3 || x === 1). The second level of conditions works as AND sub-conditions list. The third level of conditions works as OR sub-conditions list. Nesting of conditions matches the rule OR (the first level of the arguments) -> AND -> OR -> AND -> ... For a better understanding of how to build AND queries with objects please check the object helper documentation.  Structure  <!-- filter query base OR structure --> {{ filter (array 1 2 3 ... ) c1 c2 c3 ... }} result: c1 OR c2 OR c3  <!-- filter query base AND structure (the AND conditions described as sub-conditions) --> {{ filter (array x y z) (array c1 c2 c3) }} result: items that fit to c1 AND c2 AND c3  <!-- filter query a few OR from several AND conditions --> {{ filter (array x y z) (array a1 a2 a3) (array b1 b2 b3) (array c1 c2 c3) }} result: (a1 AND a2 AND a3) OR (b1 AND b2 AND b3) OR (c1 AND c2 AND c3)  <!-- filter with complex nested structure --> {{ filter (array 1 2 3) (array a1 a2 (array x1 x2) ) (array b1 b2 b3) }} results: items that fit to (a1 AND a2 AND (x1 OR x2) ) OR (b1 AND b2 AND b3)  Examples  <!-- Simple OR filter --> {{filter (array 1 2 3) 1 3}} result: 1,3  <!-- Simple OR filter --> {{filter   (array 'item1' 'item2' 'item3' 'item4' 'item3')   'item1'   'item2'   'item3' }} result: item1,item2,item3,item3  <!-- Data bucket get all users with type='item1' --> {{filter (dataRaw 'Users') (object type='item1')}}  <!-- Data bucket get all users with type='item1' OR type='item2' OR type='item3' --> {{filter   (dataRaw 'Users')   (object type='item1')   (object type='item2')   (object type='item3') }}  <!-- Data bucket get all users with type='item1' AND category='some-category' --> {{filter (dataRaw 'Users') (object type='item1' category='some-category')}}  <!-- Data bucket get all users with type='item1' OR category='some-category' --> {{filter   (dataRaw 'Users')   (array (object type='item1') (object category='some-category')) }}  <!-- Mixed data filter --> {{filter   (array 'item1' 'item2' (object type='type1') (object type='type2'))   'item1'   (object type='type2') }}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`filter`",
    "sectionAnchor": "filter",
    "score": 10,
    "groupScore": 11
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#object",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return an object that can be used in other helpers.  Parameters (named) Type Description [string]=any any key=value notation of the object properties  Examples  {{{object type='item1'}}} result: {type: 'item1'}  {{{object type='item1' category='cat1'}}} result: {type: 'item1', category: 'cat1'}  {{{object type=(array 1 2 3)}}} result: {type: [1,2,3]}  {{{object type=(array 1 2 3)}}} result: {type: [1,2,3]}  {{{object type=(filter (array 1 2 3) 1 3)}}} result: {type: [1,3]}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`object`",
    "sectionAnchor": "object",
    "score": 10,
    "groupScore": 12
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#add",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Add the numbers passed as parameters to each others. Unrecognized strings passed as arguments will be ignored.  Arguments (ordered) Type Description 0..n any[] Value of the operandes (can process numbers and strings)  Examples  {{add 1 1}} result: '2'  {{add '1' '1'}} result: '2'  {{add '1' 'foo' 1}} result: '2'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`add`",
    "sectionAnchor": "add",
    "score": 10,
    "groupScore": 13
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#subtract",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Subtract the numbers passed as parameters to the first parameter. Unrecognized strings passed as arguments will be ignored.  Arguments (ordered) Type Description 0..n any[] Value of the operandes (can process numbers and strings)  Examples  {{subtract 2 1}} result: '1'  {{subtract '2' '1'}} result: '1'  {{subtract '2' 'foo' 1}} result: '1'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`subtract`",
    "sectionAnchor": "subtract",
    "score": 10,
    "groupScore": 14
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#multiply",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Multiply the numbers passed as parameters to each others. Unrecognized strings passed as arguments will be ignored.  Arguments (ordered) Type Description 0..n any[] Value of the operandes (can process numbers and strings)  Examples  {{multiply 2 3}} result: '6'  {{multiply '2' '3'}} result: '6'  {{multiply '2' 'foo' 3}} result: '6'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`multiply`",
    "sectionAnchor": "multiply",
    "score": 10,
    "groupScore": 15
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#divide",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Divide the first parameter by the other numbers passed as parameters. Unrecognized strings passed as arguments will be ignored.  Arguments (ordered) Type Description 0..n any[] Value of the operandes (can process numbers and strings)  Examples  {{divide 4 2}} result: '2'  {{divide '4' '2'}} result: '2'  {{divide '4' 'foo' 2}} result: '2'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`divide`",
    "sectionAnchor": "divide",
    "score": 10,
    "groupScore": 16
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#modulo",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Compute the modulo of the first parameter by the second.  Arguments (ordered) Type Description 0 number First value (can process numbers and strings) 1 number Second value (can process numbers and strings)  Examples  {{modulo 5 4}} result: '1'  {{modulo '5' '4'}} result: '1'  {{modulo '5' 'foo' 4}} result: '1'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`modulo`",
    "sectionAnchor": "modulo",
    "score": 10,
    "groupScore": 17
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#ceil",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Ceil the value of the number passed as parameter.  Arguments (ordered) Type Description 0 number Value to ceil (can process numbers and strings)  Examples  {{ceil 1.5}} result: '2'  {{ceil '1.5'}} result: '2'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`ceil`",
    "sectionAnchor": "ceil",
    "score": 10,
    "groupScore": 18
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#floor",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Floor the value of the number passed as parameter.  Arguments (ordered) Type Description 0 number Value to floor (can process numbers and strings)  Examples  {{floor 2.5}} result: '2'  {{floor '2.5'}} result: '2'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`floor`",
    "sectionAnchor": "floor",
    "score": 10,
    "groupScore": 19
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#eq",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Verify if two numbers or strings are equal. Returns a boolean. Returns false if type of the value not equals.  Arguments (ordered) Type Description 0 string | number First number or string 1 string | number Second number or string  Examples  {{#if (eq 55 55)}}   true {{/if}} Result: true  {{#if (eq 55 '55')}}   true {{else}}   false {{/if}} Result: false  {{#if (eq 'x1' 'x1')}}   true {{/if}} Result: true",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`eq`",
    "sectionAnchor": "eq",
    "score": 10,
    "groupScore": 20
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#gt",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Verify if the first number is greater than the second number. Returns a boolean.  Arguments (ordered) Type Description 0 number First number 1 number Second number  Examples  {{#if (gt 56 55)}}   true {{/if}} Result: true",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`gt`",
    "sectionAnchor": "gt",
    "score": 10,
    "groupScore": 21
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#gte",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Verify if the first number is greater than or equal to the second number. Returns a boolean.  Arguments (ordered) Type Description 0 number First number 1 number Second number  Examples  {{#if (gte 55 55)}}   true {{/if}} Result: true",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`gte`",
    "sectionAnchor": "gte",
    "score": 10,
    "groupScore": 22
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#lt",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Verify if the first number is lower than the second number. Returns a boolean.  Arguments (ordered) Type Description 0 number First number 1 number Second number  Examples  {{#if (lt 55 56)}}   true {{/if}} Result: true",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`lt`",
    "sectionAnchor": "lt",
    "score": 10,
    "groupScore": 23
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#lte",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Verify if the first number is lower than or equal to the second number. Returns a boolean.  Arguments (ordered) Type Description 0 number First number 1 number Second number  Examples  {{#if (lte 55 55)}}   true {{/if}} Result: true",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`lte`",
    "sectionAnchor": "lte",
    "score": 10,
    "groupScore": 24
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#tofixed",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Format a number using fixed-point notation.  Arguments (ordered) Type Description 0 number A number 1 number Number of digits  Examples  {{toFixed 1.11111 2}} Result: 1.11",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`toFixed`",
    "sectionAnchor": "tofixed",
    "score": 10,
    "groupScore": 25
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#round",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return the value of a number rounded to the nearest integer.  Arguments (ordered) Type Description 0 number A number to round  Examples  {{round 0.499}} Result: 0",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`round`",
    "sectionAnchor": "round",
    "score": 10,
    "groupScore": 26
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#newline",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Add a newline \\n.  Examples  {{newline}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`newline`",
    "sectionAnchor": "newline",
    "score": 10,
    "groupScore": 27
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#base64",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Encode the parameter as base64. This can be used as an inline helper or block helper (see examples below).  Arguments (ordered) Type Description [0] any Value to encode (optional when used as a block helper)  Examples  {{base64 'test'}}  {{#base64}}   firstname,lastname,countryCode   {{#repeat 10}}     {{faker 'person.firstName'}},{{faker 'person.lastName'}},{{faker       'address.countryCode'     }}   {{/repeat}} {{/base64}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`base64`",
    "sectionAnchor": "base64",
    "score": 10,
    "groupScore": 28
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#base64decode",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Decode a base64 string. This can be used as an inline helper or block helper (see examples below).  Arguments (ordered) Type Description [0] string Base64 string to decode (optional when used as a block helper)  Examples  {{base64Decode 'YWJjZA=='}}  {{#base64Decode}}   {{body 'base64content'}} {{/base64Decode}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`base64Decode`",
    "sectionAnchor": "base64decode",
    "score": 10,
    "groupScore": 29
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#objectid",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Create a valid ObjectId. It can generates the ObjectId based on the specified time (in seconds) or from a 12 byte string that will act as a seed. Syntax is based on bson-objectid package.  Arguments (ordered) Type Description 0 string | number Seed  Examples  {{objectId 1414093117}} {{objectId '54495ad94c934721ede76d90'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`objectId`",
    "sectionAnchor": "objectid",
    "score": 10,
    "groupScore": 30
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#setvar",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Set a variable to be used later in the template. The value can be the result of another helper. To use it elsewhere in the template, refer to the variable with its name prefixed with an @: {{@varname}}. The variable can also be used as a helper parameter: {{#repeat @varname}}...{{/repeat}}. Variables declared in a block helper will be scoped to the block and unavailable outside.  Arguments (ordered) Type Description 0 string Variable name 1 any Variable value  Examples  {{setVar 'varname' 'value'}} {{setVar 'varname' (body 'id')}}  usage: {{@varname}} {{#repeat @varname}}...{{/repeat}}  declare a variable in a block helper: {{#repeat 5}}   {{setVar 'random' (oneOf (array '1' '2' '3'))}}   {{@random}} {{/repeat}}  {{setVar 'myArray' (array '1' '2' '3')}} {{#each @myArray}}   {{setVar 'eachIndex' @index}}   {{@eachIndex}} {{/repeat}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`setVar`",
    "sectionAnchor": "setvar",
    "score": 10,
    "groupScore": 31
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#getvar",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Dynamically get a variable set with setVar.  Arguments (ordered) Type Description 0 string Variable name  Examples  {{setVar 'varname' 'value'}}  {{getVar 'varname'}} {{getVar (concat 'var' 'name')}} {{getVar (body 'property')}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`getVar`",
    "sectionAnchor": "getvar",
    "score": 10,
    "groupScore": 32
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#includes",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Search whether a string can be found in another string and returns the appropriate boolean.  Arguments (ordered) Type Description 0 any Data to search into 1 any Data to search  Examples  {{includes 'Some data' 'data'}}  result: true",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`includes`",
    "sectionAnchor": "includes",
    "score": 10,
    "groupScore": 33
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#substr",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a portion of a string starting at the specified index and extending for a given number of characters afterwards.  Arguments (ordered) Type Description 0 any Starting index [1 = max length] any Length  Examples  {{substr 'Some data' 5 4}}  result: 'data'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`substr`",
    "sectionAnchor": "substr",
    "score": 10,
    "groupScore": 34
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#lowercase",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return the first string parameter lowercased.  Arguments (ordered) Type Description 0 string String to lowercase  Examples  {{lowercase 'ABCD'}}  result: 'abcd'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`lowercase`",
    "sectionAnchor": "lowercase",
    "score": 10,
    "groupScore": 35
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#uppercase",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return the first string parameter uppercased.  Arguments (ordered) Type Description 0 string String to uppercase  Examples  {{uppercase 'abcd'}}  result: 'ABCD'",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`uppercase`",
    "sectionAnchor": "uppercase",
    "score": 10,
    "groupScore": 36
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#split",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Split a string and return an array containing the multiples substrings. This helper can be used within handlebars' iterative helpers such as each. (Default separator is \" \")  Arguments (ordered) Type Description 0 string Data to split 1 string Separator  Examples  {{#each (split '1 2 3 4')}}   item{{this}}, {{/each}} result: item1,item2,item3,item4  {{#each (split 'This is my string.')}}   {{this}}, {{/each}} result: This,is,my,string,",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`split`",
    "sectionAnchor": "split",
    "score": 10,
    "groupScore": 37
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#stringify",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return objects and arrays as a formatted JSON string indented with two spaces.  Arguments (ordered) Type Description 0 any Object or array  Examples  Considering an entering body:  {   \"prop1\": \"123\",   \"prop2\": {     \"data\": \"test\"   } }  {{{stringify (bodyRaw 'prop2')}}}  {   \"data\": \"test\" }",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`stringify`",
    "sectionAnchor": "stringify",
    "score": 10,
    "groupScore": 38
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#concat",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Concatenate multiple strings/numbers together. This helper can concatenate results from other helpers, or be used as a parameter of another helper (see examples below).  Arguments (ordered) Type Description 0..n any Values to concatenate  Examples  {{concat 'value1' 2 'value3'}} {{concat @index (body 'id') 'value3'}} {{#repeat (concat 1 2 3)}}...{{/repeat}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`concat`",
    "sectionAnchor": "concat",
    "score": 10,
    "groupScore": 39
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#indexof",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return the index of the searched 'data' inside the string. A last parameter (number) can be passed to start the search at a specific index.  Arguments (ordered) Type Description 0 any Data to search into 1 any Data to search [2 = 0] number Search starting index  Examples  {{indexOf 'Some data' 'data' 0}}  result: 5",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`indexOf`",
    "sectionAnchor": "indexof",
    "score": 10,
    "groupScore": 40
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#parseint",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Parse a number from a string.  Arguments (ordered) Type Description 0 string String to parse",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`parseInt`",
    "sectionAnchor": "parseint",
    "score": 10,
    "groupScore": 41
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#padstart",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Pads a string with a given string (repeated, if needed) until the resulting string reaches the given length. The padding is applied from the start of the string.  Arguments (ordered) Type Description 0 string String to pad 1 number pad length [2 = ' '] string Padding character(s) (default to blank space)  {{padStart '5' 5 '0'}}  result: 00005",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`padStart`",
    "sectionAnchor": "padstart",
    "score": 10,
    "groupScore": 42
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#padend",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Pads a string with a given string (repeated, if needed) until the resulting string reaches the given length. The padding is applied from the end of the string.  Arguments (ordered) Type Description 0 string String to pad 1 number pad length [2 = ' '] string Padding character(s) (default to blank space)  Examples  {{padEnd '5' 5 '0'}}  result: 50000",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`padEnd`",
    "sectionAnchor": "padend",
    "score": 10,
    "groupScore": 43
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#now",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Display the current time in the chosen format. Format syntax is based on date-fns package (v2) and is optional (default to ISO string).  Arguments (ordered) Type Description 0 string Date format  Examples  {{now 'YYYY-MM-DD'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`now`",
    "sectionAnchor": "now",
    "score": 10,
    "groupScore": 44
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#datetimeshift",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Shift a date by adding the number of years, months, etc. passed as parameters. The date and format parameters are optional. The helper will return the current date and time as an ISO string if omitted (yyyy-MM-ddTHH:mm:ss.SSSxxx).  Parameters (named) Type Description date string Date to shift [format = 'yyyy-MM-ddTHH:mm:ss.SSSxxx'] string Format of the shifted date [years = 0] number Years to shift [months = 0] number Months to shift [days = 0] number Days to shift [hours = 0] number Hours to shift [minutes = 0] number Minutes to shift [seconds = 0] number Seconds to shift  Examples  {{dateTimeShift   date='2021-01-01'   format='yyyy-MM-dd HH:mm:ss'   years=1   months=1   days=1   hours=1   minutes=1   seconds=1 }}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`dateTimeShift`",
    "sectionAnchor": "datetimeshift",
    "score": 10,
    "groupScore": 45
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#date",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random formatted date (using date-fns package format) between a minimum and a maximum. Uses faker 'date.between' to generate the random date.  Arguments (ordered) Type Description 0 string Starting date 1 string Ending date 2 string Date format  Examples  {{date '2020-11-20' '2020-11-25' \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`date`",
    "sectionAnchor": "date",
    "score": 10,
    "groupScore": 46
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#time",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random formatted time (using date-fns package format) between a minimum and a maximum. Uses faker 'date.between' to generate the random time.  Arguments (ordered) Type Description 0 number Starting time 1 number Ending time 2 string Time format  Examples  {{time '09:00' '10:00' 'HH:mm'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`time`",
    "sectionAnchor": "time",
    "score": 10,
    "groupScore": 47
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#dateformat",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a formatted date (using date-fns package format).  Arguments (ordered) Type Description 0 string | Date Date to format 1 string Output format  Examples  {{dateFormat '2021-01-01' 'yyyy'}} {{dateFormat (faker 'date.recent') 'yyyy'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`dateFormat`",
    "sectionAnchor": "dateformat",
    "score": 10,
    "groupScore": 48
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#int",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random integer. Alias of faker 'number.int.  Arguments (ordered) Type Description 0 number Minimum 1 number Maximum  Examples  {{int 0 100}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`int`",
    "sectionAnchor": "int",
    "score": 10,
    "groupScore": 49
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#float",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random float. Alias of faker 'number.float with precision = 10.  Arguments (ordered) Type Description 0 number Minimum 1 number Maximum  Examples  {{float 0 100}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`float`",
    "sectionAnchor": "float",
    "score": 10,
    "groupScore": 50
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#boolean",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random boolean. Alias of faker 'datatype.boolean'.  Examples  {{boolean}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`boolean`",
    "sectionAnchor": "boolean",
    "score": 10,
    "groupScore": 51
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#title",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random title. Alias of faker 'name.prefix'.  Arguments (ordered) Type Description 0 string Sex  Examples:  {{title 'male'}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`title`",
    "sectionAnchor": "title",
    "score": 10,
    "groupScore": 52
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#firstname",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random first name. Alias of faker 'person.firstName'.  Examples:  {{firstName}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`firstName`",
    "sectionAnchor": "firstname",
    "score": 10,
    "groupScore": 53
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#lastname",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random last name. Alias of faker 'person.lastName'.  Examples:  {{lastName}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`lastName`",
    "sectionAnchor": "lastname",
    "score": 10,
    "groupScore": 54
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#company",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random company name. Alias of faker 'company.companyName'.  Examples:  {{company}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`company`",
    "sectionAnchor": "company",
    "score": 10,
    "groupScore": 55
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#domain",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random domain name. Alias of faker 'internet.domainName'.  Examples:  {{domain}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`domain`",
    "sectionAnchor": "domain",
    "score": 10,
    "groupScore": 56
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#tld",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random top level domain. Alias of faker 'internet.domainSuffix'.  Examples:  {{tld}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`tld`",
    "sectionAnchor": "tld",
    "score": 10,
    "groupScore": 57
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#email",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random email address. Alias of faker 'internet.email'.  Examples:  {{email}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`email`",
    "sectionAnchor": "email",
    "score": 10,
    "groupScore": 58
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#street",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random address. Alias of faker 'location.streetAddress'.  Examples:  {{street}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`street`",
    "sectionAnchor": "street",
    "score": 10,
    "groupScore": 59
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#city",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random city name. Alias of faker 'location.city'.  Examples:  {{city}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`city`",
    "sectionAnchor": "city",
    "score": 10,
    "groupScore": 60
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#country",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random country name. Alias of faker 'location.country'.  Examples:  {{country}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`country`",
    "sectionAnchor": "country",
    "score": 10,
    "groupScore": 61
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#countrycode",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random country code. Alias of faker 'location.countryCode'.  Examples:  {{countryCode}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`countryCode`",
    "sectionAnchor": "countrycode",
    "score": 10,
    "groupScore": 62
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#zipcode",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random zip code. Alias of faker 'location.zipCode'.  Examples:  {{zipcode}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`zipcode`",
    "sectionAnchor": "zipcode",
    "score": 10,
    "groupScore": 63
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#postcode",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random zip code. Alias of faker 'location.zipCode'.  Examples:  {{postcode}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`postcode`",
    "sectionAnchor": "postcode",
    "score": 10,
    "groupScore": 64
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#lat",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random latitude. Alias of faker 'location.latitude'.  Examples:  {{lat}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`lat`",
    "sectionAnchor": "lat",
    "score": 10,
    "groupScore": 65
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#long",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random longitude. Alias of faker 'location.longitude'.  Examples:  {{long}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`long`",
    "sectionAnchor": "long",
    "score": 10,
    "groupScore": 66
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#phone",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random phone number. Alias of faker 'phone.number'.  Examples:  {{phone}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`phone`",
    "sectionAnchor": "phone",
    "score": 10,
    "groupScore": 67
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#color",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random color. Alias of faker 'color.human'.  Examples:  {{color}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`color`",
    "sectionAnchor": "color",
    "score": 10,
    "groupScore": 68
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#hexcolor",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random hexadecimal color code.  Examples:  {{hexColor}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`hexColor`",
    "sectionAnchor": "hexcolor",
    "score": 10,
    "groupScore": 69
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#guid",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random GUID. Alias of faker 'string.uuid'.  Examples:  {{guid}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`guid`",
    "sectionAnchor": "guid",
    "score": 10,
    "groupScore": 70
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#ipv4",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random IP v4. Alias of faker 'internet.ip'.  Examples:  {{ipv4}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`ipv4`",
    "sectionAnchor": "ipv4",
    "score": 10,
    "groupScore": 71
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#ipv6",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return a random IP v6. Alias of faker 'internet.ipv6'.  Examples:  {{ipv6}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`ipv6`",
    "sectionAnchor": "ipv6",
    "score": 10,
    "groupScore": 72
  },
  {
    "objectID": "/docs/latest/templating/mockoon-helpers/#lorem",
    "title": "Custom helpers",
    "category": "docs",
    "content": "Return random lorem ipsum text. Alias of faker 'lorem.sentence'.  Arguments (ordered) Type Description 0 number Number of words  Examples:  {{lorem 50}}",
    "link": "/docs/latest/templating/mockoon-helpers/",
    "sectionTitle": "`lorem`",
    "sectionAnchor": "lorem",
    "score": 10,
    "groupScore": 73
  },
  {
    "objectID": "/docs/latest/templating/fakerjs-helpers/#fakerjs-helpers",
    "title": "Faker.js helpers",
    "category": "docs",
    "content": "Mockoon implements Faker.js v8.1.0 library by wrapping most of the available helpers. Faker.js offers lots of helpers: location.zipCode, location.city, location.count, person.firstName, person.lastName, number.int, number.float, internet.avatar, internet.email, etc. Please have a look at Faker.js documentation to learn how to use them.",
    "link": "/docs/latest/templating/fakerjs-helpers/",
    "sectionTitle": "Faker.js helpers",
    "sectionAnchor": "fakerjs-helpers",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/templating/fakerjs-helpers/#usage",
    "title": "Faker.js helpers",
    "category": "docs",
    "content": "All Faker.js helpers must be used with the following syntax: {{faker 'namespace.method'}}. Examples:  {{faker 'location.zipCode'}} {{faker 'location.city'}} {{faker 'location.county'}} {{faker 'person.firstName'}} ...  Faker.js methods may use two different ways of passing parameters: ordered arguments or options objects. Wrapped in Handlebars helpers, this may result in two different ways of using them:  // named parameters {{faker 'number.int' min=0 max=25}}  // ordered arguments (here count=25) {{faker 'string.alphanumeric' 25}}",
    "link": "/docs/latest/templating/fakerjs-helpers/",
    "sectionTitle": "Usage",
    "sectionAnchor": "usage",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/templating/fakerjs-helpers/#set-fakerjs-locale-and-seed",
    "title": "Faker.js helpers",
    "category": "docs",
    "content": "Faker.js locale and seed can be defined in the settings:  fakerjs settings  üìùA note on Faker.js seeding By providing a seed value, you can generate repeatable sequences of fake data. Using seeding will not always generate the same value but rather a predictable sequence.",
    "link": "/docs/latest/templating/fakerjs-helpers/",
    "sectionTitle": "Set Faker.js' locale and seed",
    "sectionAnchor": "set-fakerjs-locale-and-seed",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/server-configuration/serving-over-tls/#tls",
    "title": "TLS",
    "category": "docs",
    "content": "Mockoon supports serving your mock API over TLS with a self-signed certificate by default. You can also provide your certificate and trusted CA certificates.",
    "link": "/docs/latest/server-configuration/serving-over-tls/",
    "sectionTitle": "TLS",
    "sectionAnchor": "tls",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/server-configuration/serving-over-tls/#activate-the-tls-option",
    "title": "TLS",
    "category": "docs",
    "content": "You can activate the TLSoption for each environment independently. Open the Environment Settings by clicking on the tab at the top of the window:  click on the settings tab  Enable the TLS option by ticking the checkbox. The option was successfully activated if a yellow lock is displayed next to the environment name.  tick the TLS checkbox  You may need to restart your environment for the change to take effect.    Your mock API will now be available on https://localhost:port instead of http://localhost:port.  Please note that Mockoon is using a self-signed certificate to serve your environment over TLS.",
    "link": "/docs/latest/server-configuration/serving-over-tls/",
    "sectionTitle": "Activate the TLS option",
    "sectionAnchor": "activate-the-tls-option",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/server-configuration/serving-over-tls/#provide-your-own-certificate",
    "title": "TLS",
    "category": "docs",
    "content": "You can also provide your certificate in both PKCS12 or PEM formats by filling out the input fields with the path to the file(s).  add certificate path  Mockoon also supports passphrase-protected keys and custom-trusted CA certificates. As Mockoon is using Node.js' tls, you can refer to the tls.createSecureContext() documentation for a full description of the available options.  All the path fields support both absolute and relative paths. Relative paths are resolved from the environment's file location.",
    "link": "/docs/latest/server-configuration/serving-over-tls/",
    "sectionTitle": "Provide your own certificate",
    "sectionAnchor": "provide-your-own-certificate",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/server-configuration/proxy-mode/#partially-mock-apis-using-the-proxy-mode",
    "title": "Partial mocking with proxy mode",
    "category": "docs",
    "content": "Mockoon supports partial mocking of an API endpoints by forwarding the requests that does not match a declared route to the URL of your choice.  To activate the proxy mode, open the Environment Proxy options by clicking on the tab at the top of the window:  click on proxy tab  Enable the proxy mode by checking the box and enter the server URL to which you want to forward the calls. A small shield icon should appear on the right of your environment name indicating that the proxy mode has been enabled:  tick the Proxy checkbox  From now on, all routes that have been defined in Mockoon will be intercepted, and any other request not matching any route path will be forwarded to the server URL you entered in the proxy mode setting.",
    "link": "/docs/latest/server-configuration/proxy-mode/",
    "sectionTitle": "Partially mock APIs using the proxy mode",
    "sectionAnchor": "partially-mock-apis-using-the-proxy-mode",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/server-configuration/proxy-mode/#disable-api-prefix-forwarding",
    "title": "Partial mocking with proxy mode",
    "category": "docs",
    "content": "By default, the API prefix will be part of the path called on the proxied API. You can disable this behavior by ticking the \"Remove prefix\" checkbox:  tick the Proxy no prefix forward checkbox",
    "link": "/docs/latest/server-configuration/proxy-mode/",
    "sectionTitle": "Disable API prefix forwarding",
    "sectionAnchor": "disable-api-prefix-forwarding",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/server-configuration/proxy-mode/#proxy-headers",
    "title": "Partial mocking with proxy mode",
    "category": "docs",
    "content": "Proxy specific headers can also be added, both to the forwarded request and the response received from the target API.  add proxy headers by filling the keys and values  Proxy request headers will be automatically added to the request sent to the proxied server, while proxy response headers are added to the response received from the proxied server.",
    "link": "/docs/latest/server-configuration/proxy-mode/",
    "sectionTitle": "Proxy headers",
    "sectionAnchor": "proxy-headers",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/server-configuration/listening-hostname/#listening-hostnameadapter",
    "title": "Listening hostname/adapter",
    "category": "docs",
    "content": "By default, Mockoon's mock APIs will listen to all available network adapters on IPv4 and IPv6, often described as 0.0.0.0 and ::. Your mock server will be available on all your adapters, such as localhost, 127.0.0.1, your local IPv4 address(es) 192.168.x.x, ::1, etc.  To configure each environment to listen on a specific hostname, open the Environment Settings by clicking on the tab at the top of the window:  click on the settings tab  Add a custom hostname in the input field:  field to set a custom hostname  You may need to restart your environment for the change to take effect.    When using the CLI, you can choose a specific adapter to listen to (e.g. 192.168.1.1) by using the --hostname flag with the start command.",
    "link": "/docs/latest/server-configuration/listening-hostname/",
    "sectionTitle": "Listening hostname/adapter",
    "sectionAnchor": "listening-hostnameadapter",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/server-configuration/cors/#automatic-handling-of-cors-preflight-requests",
    "title": "CORS",
    "category": "docs",
    "content": "When creating mock APIs, chances are the front-end application and the mocked API won‚Äôt be on the same domain, thus triggering browsers OPTIONS preflight requests.  For your application to work, you can make Mockoon automatically answer to these OPTIONS requests:  Open the Environment Settings by clicking on the tab at the top of the window:  click on the settings tab  Enable the **Automatically handle OPTIONS pre-flight requests ** by ticking the checkbox:  tick the CORS checkbox  You need to restart the environment for the change to take effect.  Mockoon will now automatically answer with a 200 HTTP status code to all preflight OPTIONS requests. The following headers will also be added to the response:  Access-Control-Allow-Origin: * Access-Control-Allow-Methods: GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS Access-Control-Allow-Headers: Content-Type, Origin, Accept,Authorization,Content-Length, X-Requested-With  Please note that Mockoon won‚Äôt send any CORS header on routes with the OPTIONS method (i.e. OPTIONS /my-route).",
    "link": "/docs/latest/server-configuration/cors/",
    "sectionTitle": "Automatic handling of CORS preflight requests",
    "sectionAnchor": "automatic-handling-of-cors-preflight-requests",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/server-configuration/cors/#add-cors-headers-to-the-environment-headers",
    "title": "CORS",
    "category": "docs",
    "content": "You can also add the same CORS headers to all routes of a mock API with one click.  Open the Environment Headers by clicking on the tab at the top of the window:  click on the headers tab  Then, click on the Add CORS headers link:  Click on the add CORS headers link  The above headers will be automatically added to your list of headers:  view cors headers in the list",
    "link": "/docs/latest/server-configuration/cors/",
    "sectionTitle": "Add CORS headers to the environment headers",
    "sectionAnchor": "add-cors-headers-to-the-environment-headers",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#multiple-responses",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "For each route, multiple responses can be defined (status, body, and headers) and triggered using a set of rules. There is always at least one response when you create a new route. You can modify it and add more responses but you can never delete the last route response.",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Multiple responses",
    "sectionAnchor": "multiple-responses",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#adding-or-duplicating-a-response",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "To add a new response to your route, click on the \"plus\" icon next to the responses list:  Click on the icon to add a new response  You can also duplicate an existing route response by clicking on the \"copy\" icon on the right:  Click on the copy icon to duplicate a response  Everything will be copied to the new response: documentation, file/body, headers and rules.",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Adding or duplicating a response",
    "sectionAnchor": "adding-or-duplicating-a-response",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#route-responses-precedence",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "Route responses order define the order in which the rules are interpreted. You can easily change the default response by reordering the responses menu with a drag and drop:  Reorder route responses",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Route responses precedence",
    "sectionAnchor": "route-responses-precedence",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#default-route-response",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "Without rules or when a request does not match the one you defined, the default response will always be the one marked with the blue flag. You can easily change the default response by clicking on the grey flags in the menu:  Define a new default route response",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Default route response",
    "sectionAnchor": "default-route-response",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#random-route-response",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "Mockoon can serve the route responses randomly (200, 500, 404) to simulate an unpredictable behavior.  To activate this option, click on the \"shuffle\" icon next to the response list:  Random route responses  ‚ö†Ô∏è When this option is active, the default response and all the rules defined on this route will be ignored. Also, this option cannot be selected in addition to the sequential responses option below.",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Random route response",
    "sectionAnchor": "random-route-response",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#sequential-route-response",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "Mockoon can serve the route responses sequentially (200 ‚Üí 500 ‚Üí 404). Mockoon will serve all the responses one after the other and restart at the beginning. The sequence is reset when restarting the server.  To activate this option, click on the \"repeat\" icon next to the response list:  Sequential route responses  ‚ö†Ô∏è When this option is active, the default response and all the rules defined on this route will be ignored. Also, this option cannot be selected in addition to the random responses option above.",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Sequential route response",
    "sectionAnchor": "sequential-route-response",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/route-responses/multiple-responses/#fallback-mode",
    "title": "Multiple route responses",
    "category": "docs",
    "content": "When the fallback mode is enabled, Mockoon will automatically pass the request to the proxy (or the next route, see below) when none of the responses' rules match.  To activate this option, click on the \"fallback\" icon next to the response list:  fallback mode responses  Behind the scene, the server will automatically jump to the next route in the order they were declared and, ultimately, to the proxied server. It allows to create complex setups where a wildcard or parameterized route contains rules to protect the access to other routes:  GET /users/* --> Authorization header required GET /users/:id --> No rules  üí° Header over to our \"Global routes with rules\" documentation section to learn more about this feature.    ‚ö†Ô∏è When this option is active, the default response will be ignored. Also, this option cannot be selected in addition to the other response options above and could result in a 404 if the proxy is not enabled.",
    "link": "/docs/latest/route-responses/multiple-responses/",
    "sectionTitle": "Fallback mode",
    "sectionAnchor": "fallback-mode",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/route-responses/global-routes-with-rules/#global-routes-with-rules",
    "title": "Global routes with rules",
    "category": "docs",
    "content": "If you want to serve the same responses based on the same rules for all or part of your endpoints, you can create global routes using the fallback mode and a wildcard path. This is useful if you want to protect all your endpoints by checking if an Authorization header is present or if you want to verify that all your requests contain a specific property in their body.  Three parts are required to create a global route:",
    "link": "/docs/latest/route-responses/global-routes-with-rules/",
    "sectionTitle": "Global routes with rules",
    "sectionAnchor": "global-routes-with-rules",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/route-responses/global-routes-with-rules/#1-create-a-wildcard-route",
    "title": "Global routes with rules",
    "category": "docs",
    "content": "To create a global route, you first need to create a new HTTP route that will match all the endpoints you want to protect. To do so, create a new route and select \"All methods\" in the method dropdown:  wildcard route on all methods  In this example, the wildcard route is placed above the GET /users route, which is important as it will be evaluated first and catch all the requests. You can create it first or move it up in the routes list with a drag and drop.  üí° You can also create a wildcard route that only matches a specific method, like GET or POST, instead of \"All methods\", if you want to protect all your POST endpoints, for example. Finally, you can create a wildcard route that matches all the endpoints starting with a specific path, like /users/* instead of /*. You can use this method to protect all your /users/something endpoints but not the /users one.",
    "link": "/docs/latest/route-responses/global-routes-with-rules/",
    "sectionTitle": "1. Create a wildcard route",
    "sectionAnchor": "1-create-a-wildcard-route",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/route-responses/global-routes-with-rules/#2-create-your-global-responses-and-rules",
    "title": "Global routes with rules",
    "category": "docs",
    "content": "The second step is to create one or more responses with rules. For example, you can create a response checking that the request contains an Authorization header and returning a 401 error if's not present. To follow this example, use the existing response or create a new one and set the status code to 401:  create response with status code 401  Add a new rule to this response by clicking on the \"add rule\" button and selecting the \"Header\" rule type. Then, set the rule to check that the Authorization header is null as we want to return a 401 error if it is not present:  create rule to check that the Authorization header is null  üí° You can create more responses with associated rules to verify more criteria on the request and serve different responses accordingly (errors, etc.).",
    "link": "/docs/latest/route-responses/global-routes-with-rules/",
    "sectionTitle": "2. Create your global responses and rules",
    "sectionAnchor": "2-create-your-global-responses-and-rules",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/route-responses/global-routes-with-rules/#3-activate-the-fallback-mode",
    "title": "Global routes with rules",
    "category": "docs",
    "content": "Once your route is created and your responses customized, activate the fallback mode by clicking on the \"fallback\" icon next to the response list:  Activate fallback mode  This will automatically pass the request to the next route when none of the responses' rules match.  üìò Learn more about the fallback mode in our documentation.",
    "link": "/docs/latest/route-responses/global-routes-with-rules/",
    "sectionTitle": "3. Activate the fallback mode",
    "sectionAnchor": "3-activate-the-fallback-mode",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#adding-response-rules",
    "title": "Responses rules",
    "category": "docs",
    "content": "After creating multiple responses for each route, you can create more complex scenarios and serve the responses depending on the fulfillment of rules.",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "Adding response rules",
    "sectionAnchor": "adding-response-rules",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#defining-rules",
    "title": "Responses rules",
    "category": "docs",
    "content": "You can define an unlimited number of rules for each route. At each request, Mockoon will assert each response's rules and serve the response which contains the first matching rule(s). The rules are interpreted in the order they are declared: [rule OR|AND rule] OR [rule OR|AND rule], the brackets symbolizing each route response.  Rules interpretation order  To add a new rule to a response, go to the route response's Rules tab, click on \"Add rule\" and fill the fields:  Click on add and fill the fields",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "Defining rules",
    "sectionAnchor": "defining-rules",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#reordering-rules",
    "title": "Responses rules",
    "category": "docs",
    "content": "By default, rules are interpreted in the order you added them. You can change their interpretation order by drag and dropping them:  Drag and drop rules to reorder them",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "Reordering rules",
    "sectionAnchor": "reordering-rules",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#disabling-rules",
    "title": "Responses rules",
    "category": "docs",
    "content": "You can temporarily disable the rules and serve the default response only. To activate this option, click on the \"rules\" icon next to the response list:  Disable rules  When this option is active, the default response will be always served and all the rules defined on this route will be ignored. Also, this option cannot be selected in addition to the random or sequential responses.",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "Disabling rules",
    "sectionAnchor": "disabling-rules",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#rules-logical-operator",
    "title": "Responses rules",
    "category": "docs",
    "content": "Inside a route response, rules are interpreted by default with the OR logical operator. When you have more than one rule in a route response, you can easily switch the operator applied when interpreting the rules, by clicking on the OR|AND buttons at the left of the rules:  Choose the rule operator OR AND  Rules have four parts:  a target a property name or path an invert operator toggle a comparison operator a value",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "Rules logical operator",
    "sectionAnchor": "rules-logical-operator",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#1-target",
    "title": "Responses rules",
    "category": "docs",
    "content": "Rule target  In the dropdown menu you can choose between:  the body value (full raw content or one of its properties if request's Content-Type is either application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, application/soap+xml or text/xml). the value of a header. the value of a cookie. the value of a route parameter. the value of a query string field. the request number index starting at 1.",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "1. Target",
    "sectionAnchor": "1-target",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#2-property-name-or-path",
    "title": "Responses rules",
    "category": "docs",
    "content": "Rule property  Depending on the target, the way to access properties may be different:  body:keep empty to match against the full raw body content. use a path to access one of its properties. Two syntaxes are supported, object-path or JSONPath Plus. When using object-path, properties containing dots are supported by escaping the dots: key.key\\.with\\.dot. Fetching object properties is compatible with request's bodies of Content-Type application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, application/soap+xml or text/xml. Please note that XML bodies are parsed using xml-js package. Refer to this page or the package documentation for more information on how the XML is parsed and how to fetch specific properties. Please also note that multipart/form-data only supports fields. Uploaded files will be ignored.   headers: a header name like Accept or Content-Type. cookies: the cookie name like Session-id. route param: a route param name without the colon (\":\"), :userId becoming userId. query string: either provide a property name like filter or a path if the query string field is an object filter.primary. request number: nothing has to be provided here for the request number.  For body and query string, if the property is an array, Mockoon will automatically check in the array if at least one item matches the value.",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "2. Property name or path",
    "sectionAnchor": "2-property-name-or-path",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#3-invert-operator",
    "title": "Responses rules",
    "category": "docs",
    "content": "You can invert the comparison operator (! equals, ! regex match, etc.) by toggling on the exclamation mark button:  Rule comparison operator",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "3. Invert operator",
    "sectionAnchor": "3-invert-operator",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#4-comparison-operator",
    "title": "Responses rules",
    "category": "docs",
    "content": "Rule comparison operator  Multiple comparison operators are available in each rule:  equals: asserts that the targeted property is equal to the value. regex match: asserts that the targeted property matches the regex value. null: asserts that the targeted property is null or absent (for headers or cookies). empty array: asserts that the targeted property is an empty array.",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "4. Comparison operator",
    "sectionAnchor": "4-comparison-operator",
    "score": 10,
    "groupScore": 8
  },
  {
    "objectID": "/docs/latest/route-responses/dynamic-rules/#5-value",
    "title": "Responses rules",
    "category": "docs",
    "content": "Rule value  Depending on the comparison operator chosen, equals or regex match, you can either set a simple text value like \"expected value\" or any kind of regex. To use a regex, you must write it without the leading and trailing slashes.  Regex examples: primary|secondary, ^user1-9, UTF-.*. You can also test for empty values with the following regex: ^$|\\s+.  The request number supports simple entries like 1 or 2 but also regexes, allowing you to return a different response for the first 3 calls ^[1-3]$ or failing on odd request indexes [13579]$.  üí° The response rule values also support templating helpers to create dynamic rules. See the templating helpers documentation for more information.",
    "link": "/docs/latest/route-responses/dynamic-rules/",
    "sectionTitle": "5. Value",
    "sectionAnchor": "5-value",
    "score": 10,
    "groupScore": 9
  },
  {
    "objectID": "/docs/latest/response-configuration/xml-support/#xml-support",
    "title": "XML support",
    "category": "docs",
    "content": "When sending a request containing a valid XML body and an application/xml or text/xml Content-Type, Mockoon will parse the XML and allow you to create body response rules or use the body and bodyRaw templating helpers. Mockoon uses the xml-js NPM package to convert the entering XML. Please note that the xml-js package converts XML into JSON in a particular way, as shown below:  Entering XML body:  <?xml version=\"1.0\" encoding=\"utf-8\"?> <user userID=\"123\"> <firstname>John</firstname> <lastname>Doe</lastname> </user>  JSON equivalent (compacted):  {   \"_declaration\": {     \"_attributes\": {       \"version\": \"1.0\",       \"encoding\": \"utf-8\"     }   },   \"user\": {     \"_attributes\": {       \"userID\": \"123\"     },     \"firstname\": {       \"_text\": \"John\"     },     \"lastname\": {       \"_text\": \"Doe\"     }   } }  Please refer to xml-js documentation for more detail on how the XML is parsed.",
    "link": "/docs/latest/response-configuration/xml-support/",
    "sectionTitle": "XML support",
    "sectionAnchor": "xml-support",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/response-configuration/response-headers/#headers",
    "title": "Headers",
    "category": "docs",
    "content": "In Mockoon you can easily define response headers for each route but also at the environment level. Response headers defined on a route will override those defined in an environment.",
    "link": "/docs/latest/response-configuration/response-headers/",
    "sectionTitle": "Headers",
    "sectionAnchor": "headers",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/response-configuration/response-headers/#route-level-response-headers",
    "title": "Headers",
    "category": "docs",
    "content": "To add response headers like Content-Type to your route, go to the route's Headers tab and fill the name and value fields:  Complete route response header form  You can add one or more headers by clicking on the \"Add header\" button at the bottom of the list:  Add route response header",
    "link": "/docs/latest/response-configuration/response-headers/",
    "sectionTitle": "Route level response headers",
    "sectionAnchor": "route-level-response-headers",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/response-configuration/response-headers/#environment-level-response-headers",
    "title": "Headers",
    "category": "docs",
    "content": "You can also add response headers at the environment level. Headers defined in an environment will be overridden if they are redefined on a route. To define an environment response header:  Open the Environment Headers by clicking on the tab at the top of the window:  click on the headers tab  And add one or more headers by clicking on the \"Add header\" button at the bottom of the list:  Add environment header",
    "link": "/docs/latest/response-configuration/response-headers/",
    "sectionTitle": "Environment level response headers",
    "sectionAnchor": "environment-level-response-headers",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/response-configuration/response-body/#response-body",
    "title": "Body",
    "category": "docs",
    "content": "Each route response can serve a different body content. You have three possibilities to add a body content to your response: the inline body editor, an external file, or the content of a data bucket.  You can choose each option using the body selector:  body type toggle buttons",
    "link": "/docs/latest/response-configuration/response-body/",
    "sectionTitle": "Response body",
    "sectionAnchor": "response-body",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/response-configuration/response-body/#body-editor-inline",
    "title": "Body",
    "category": "docs",
    "content": "You can use the body editor to directly create your response content. It supports all the templating helpers.  inline body editor  Mockoon will save the content of the inline body editor directly in your data file. Using an external file could improve the performance for large content.",
    "link": "/docs/latest/response-configuration/response-body/",
    "sectionTitle": "Body editor (inline)",
    "sectionAnchor": "body-editor-inline",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/response-configuration/response-body/#external-file",
    "title": "Body",
    "category": "docs",
    "content": "You can also choose to serve an external file, using the second option:  external file linking input  Please refer to the file serving documentation for more information.",
    "link": "/docs/latest/response-configuration/response-body/",
    "sectionTitle": "External file",
    "sectionAnchor": "external-file",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/response-configuration/response-body/#data-bucket",
    "title": "Body",
    "category": "docs",
    "content": "You can finally choose to serve the content of a data bucket using the third option:  data bucket linking select menu  Please refer to the data bucket documentation for more information.",
    "link": "/docs/latest/response-configuration/response-body/",
    "sectionTitle": "Data bucket",
    "sectionAnchor": "data-bucket",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#file-serving",
    "title": "File serving",
    "category": "docs",
    "content": "Besides using the body editor, Mockoon allows you to serve different files for each route. File serving should be the preferred method when you want to send lots of data.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "File serving",
    "sectionAnchor": "file-serving",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#using-files",
    "title": "File serving",
    "category": "docs",
    "content": "To serve a file, you must provide a path in the file input field:  fill the file input field  When a file path is provided, the body editor content will be ignored.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "Using files",
    "sectionAnchor": "using-files",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#absolute-or-relative-paths",
    "title": "File serving",
    "category": "docs",
    "content": "You can either provide an absolute path like /home/username/file.json or a relative path. Starting with v1.16.0, relative paths are resolved from the environment's file location. You can check the environment's file location by right-clicking on an environment en select \"Show in folder\" in the contextual menu:  show in folder menu entry  Prior to v1.16.0, relative file paths were resolved from the application executable. This is also supported by the CLI since its version 1.2.0.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "Absolute or relative paths",
    "sectionAnchor": "absolute-or-relative-paths",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#templating",
    "title": "File serving",
    "category": "docs",
    "content": "Templating is available in both the file content and the file input field.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "Templating",
    "sectionAnchor": "templating",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#file-content-templating",
    "title": "File serving",
    "category": "docs",
    "content": "As for the body editor, templating will be parsed inside files for a limited set of MIME types (application/json, text/html, text/css, text/csv, application/javascript, application/typescript, text/plain, application/xhtml+xml, application/xml). You can use all the available templating helpers to generate dynamic mock data.  Templating can be disabled both for the body editor and the file content. Please refer to the templating documentation for more information.  ‚ö° A note on performances  Parsing the templating helpers inside big files can be a very intensive task (CPU and memory intensive). All the files in different formats than the one mentioned above will be streamed to improve performances. If you need to send big files in one of the above formats but don't need to parse the templating, you can disable it in the route response settings. It will stream the file instead of parsing it and improve the performance. disable templating in route response",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "File content templating",
    "sectionAnchor": "file-content-templating",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#file-input-templating",
    "title": "File serving",
    "category": "docs",
    "content": "Templating is also supported directly in the file input field. It allows to dynamically generate the file path using helpers. Please refer to the templating documentation for more information.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "File input templating",
    "sectionAnchor": "file-input-templating",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#404-fallback",
    "title": "File serving",
    "category": "docs",
    "content": "By default, Mockoon will return an error in the body when a file is not found. It will still keep the status code you set up on your route response. You can instead choose to automatically return a 404 by activating an option in the route response settings:  tick the 404 fallback checkbox  This option will also fall back to use the content present in the body editor.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "404 fallback",
    "sectionAnchor": "404-fallback",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/response-configuration/file-serving/#serving-a-range-of-bytes-from-a-file",
    "title": "File serving",
    "category": "docs",
    "content": "Mockoon supports the Range header for files that are not parsed by the templating engine or when the templating is disabled on the response (see above).  To use this feature, you must provide a Range header in your request. The header value must be in the form bytes=start-end where start and end are the byte positions of the file you want to return. For example, bytes=0-100 will return the first 100 bytes of the file.  The server will answer with a 206 Partial Content status code and the Content-Range header containing the range of bytes returned. If the range is invalid, the server will answer with a 416 Range Not Satisfiable status code.",
    "link": "/docs/latest/response-configuration/file-serving/",
    "sectionTitle": "Serving a range of bytes from a file",
    "sectionAnchor": "serving-a-range-of-bytes-from-a-file",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/openapi/openapi-specification-compatibility/#openapi-specification-compatibility",
    "title": "OpenAPI specification compatibility",
    "category": "docs",
    "content": "Importing an OpenAPI specification file in Mockoon can be a good starting point to create a mock from your API definition. And exporting your mock to an OpenAPI specification file is also a way to start an API definition. However, there is currently no equivalent between all the OpenAPI specifications and Mockoon's features:  Some of Mockoon's features will be lost when exporting to an OpenAPI specification because they have no equivalent in the specification. It is the case for the rules system. Some features are not yet exported to an OpenAPI specification: bodies created in Mockoon are not converted to OpenAPI schemas or body examples. when importing an OpenAPI specification file, not all properties have equivalents in Mockoon, or some may not be implemented yet. See below for the list of imported information.  Importing from or exporting to an OpenAPI specification file is a good starting point but not a way to share your mock APIs created with Mockoon. For sharing, we recommend that you directly share Mockoon's data files. Also, if you want to run your mock API with the CLI, you must use Mockoon's data files directly, or you may lose part of your mock's behavior.",
    "link": "/docs/latest/openapi/openapi-specification-compatibility/",
    "sectionTitle": "OpenAPI specification compatibility",
    "sectionAnchor": "openapi-specification-compatibility",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/openapi/openapi-specification-compatibility/#supported-information",
    "title": "OpenAPI specification compatibility",
    "category": "docs",
    "content": "OpenAPI import and export currently support the following API information:  API title. Server URL, port, base path (prefix) and protocol. Routes paths (including route parameters translated to /:param), methods, responses with status code (200, etc.), headers, and descriptions.  Import only: sample responses and JSON bodies are created from OpenAPI schemas and examples during import.",
    "link": "/docs/latest/openapi/openapi-specification-compatibility/",
    "sectionTitle": "Supported information",
    "sectionAnchor": "supported-information",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/openapi/import-export-openapi-format/#importexport-in-openapi-format",
    "title": "Import/export in OpenAPI format",
    "category": "docs",
    "content": "Mockoon supports imports in both OpenAPI v2 (Swagger) and v3 formats. Environments can be exported to OpenAPI version 3.",
    "link": "/docs/latest/openapi/import-export-openapi-format/",
    "sectionTitle": "Import/export in OpenAPI format",
    "sectionAnchor": "importexport-in-openapi-format",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/openapi/import-export-openapi-format/#import-environment-from-an-openapi-v2-or-v3-jsonyaml-file",
    "title": "Import/export in OpenAPI format",
    "category": "docs",
    "content": "To import an environment from a file, open the Import/export menu, select Swagger/OpenAPI and then Import Swagger v2/OpenAPI v3 (JSON or YAML):  Click on Import Swagger v2/OpenAPI v3 (JSON or YAML)",
    "link": "/docs/latest/openapi/import-export-openapi-format/",
    "sectionTitle": "Import environment from an OpenAPI v2 or v3 JSON/YAML file",
    "sectionAnchor": "import-environment-from-an-openapi-v2-or-v3-jsonyaml-file",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/openapi/import-export-openapi-format/#export-an-environment-to-an-openapi-v3-json-file",
    "title": "Import/export in OpenAPI format",
    "category": "docs",
    "content": "To export an environment to a JSON file, open the Import/export menu, select Swagger/OpenAPI and then Export current environment to OpenAPI v3 (JSON):  Click on Export current environment to OpenAPI v3 (JSON)",
    "link": "/docs/latest/openapi/import-export-openapi-format/",
    "sectionTitle": "Export an environment to an OpenAPI v3 JSON file",
    "sectionAnchor": "export-an-environment-to-an-openapi-v3-json-file",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/openapi/import-export-openapi-format/#compatibility",
    "title": "Import/export in OpenAPI format",
    "category": "docs",
    "content": "Compatibility between the OpenAPI specification and Mockoon's features is only partial and detailed in the next article.",
    "link": "/docs/latest/openapi/import-export-openapi-format/",
    "sectionTitle": "Compatibility",
    "sectionAnchor": "compatibility",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/sharing-mock-api-files/#sharing-your-mock-api-files",
    "title": "Sharing your mock API files",
    "category": "docs",
    "content": "üÜï Be among the first to experience our new cloud offering with data synchronization capabilities by signing up for our waiting list.",
    "link": "/docs/latest/mockoon-data-files/sharing-mock-api-files/",
    "sectionTitle": "Sharing your mock API files",
    "sectionAnchor": "sharing-your-mock-api-files",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/sharing-mock-api-files/#sharing-a-mock-api",
    "title": "Sharing your mock API files",
    "category": "docs",
    "content": "Each file can be easily shared with other Mockoon's users, \"as-is\". After locating your environment file, you can share it with your coworkers by using Git for example. You coworkers can then save the file in any folder and open it directly using the \"Open environment\" button:  open an environment",
    "link": "/docs/latest/mockoon-data-files/sharing-mock-api-files/",
    "sectionTitle": "Sharing a mock API",
    "sectionAnchor": "sharing-a-mock-api",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/sharing-mock-api-files/#use-a-git-tracked-folder",
    "title": "Sharing your mock API files",
    "category": "docs",
    "content": "You can save your environment data files in a Git-tracked folder to make sharing easier. By default, an environment file JSON content is saved pretty-printed to allow comparing changes between two commits. You can disable pretty printing in the settings:  disable pretty printing",
    "link": "/docs/latest/mockoon-data-files/sharing-mock-api-files/",
    "sectionTitle": "Use a Git-tracked folder",
    "sectionAnchor": "use-a-git-tracked-folder",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/sharing-mock-api-files/#use-a-mock-api-with-the-cli",
    "title": "Sharing your mock API files",
    "category": "docs",
    "content": "The CLI is directly compatible with environment files. After locating your environment file, you run them with the CLI using the following command: mockoon-cli start -d ./path-to-file/environment-data-file.json.",
    "link": "/docs/latest/mockoon-data-files/sharing-mock-api-files/",
    "sectionTitle": "Use a mock API with the CLI",
    "sectionAnchor": "use-a-mock-api-with-the-cli",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/settings-and-logs/#settings-and-logs",
    "title": "Settings and logs",
    "category": "docs",
    "content": "Depending on your operating system, Mockoon's settings and log files are located in different folders.",
    "link": "/docs/latest/mockoon-data-files/settings-and-logs/",
    "sectionTitle": "Settings and logs",
    "sectionAnchor": "settings-and-logs",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/settings-and-logs/#application-settings",
    "title": "Settings and logs",
    "category": "docs",
    "content": "Mockoon's settings are always stored in your operating system's user folder:  Windows: c:/Users/{username}/AppData/Roaming/mockoon/storage Windows Portable: {PORTABLE_EXECUTABLE_DIR}/mockoon-data/storage Linux: ~/.config/mockoon/storage Linux Snap: ~/snap/mockoon/common macOS: ~/Library/Application Support/mockoon/storage",
    "link": "/docs/latest/mockoon-data-files/settings-and-logs/",
    "sectionTitle": "Application settings",
    "sectionAnchor": "application-settings",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/settings-and-logs/#application-logs",
    "title": "Settings and logs",
    "category": "docs",
    "content": "Mockoon's logs are located in the following folders:  Windows: c:/Users/{username}/AppData/Roaming/mockoon/logs/app.log Windows Portable: {PORTABLE_EXECUTABLE_DIR}/mockoon-data/logs/app.log Linux: ~/.config/mockoon/logs/app.log Linux Snap: ~/snap/mockoon/common/logs/app.log macOS: ~/Library/Logs/Mockoon/app.log",
    "link": "/docs/latest/mockoon-data-files/settings-and-logs/",
    "sectionTitle": "Application logs",
    "sectionAnchor": "application-logs",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/environment-clipboard-copy/#copy-an-environment-or-a-route-json-to-the-clipboard",
    "title": "Copy data to the clipboard",
    "category": "docs",
    "content": "To copy a specific environment or route's JSON data to the clipboard, right-click on the environment or route and select Copy to clipboard (JSON):  Right click on an environment and click on Copy to clipboard (JSON)  The resulting JSON can be saved in a file and directly opened in the desktop app or used with the CLI.",
    "link": "/docs/latest/mockoon-data-files/environment-clipboard-copy/",
    "sectionTitle": "Copy an environment or a route JSON to the clipboard",
    "sectionAnchor": "copy-an-environment-or-a-route-json-to-the-clipboard",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/environment-clipboard-copy/#create-a-new-environment-from-clipboards-data",
    "title": "Copy data to the clipboard",
    "category": "docs",
    "content": "To create a new environment from data present in the clipboard, open the File menu and select New environment from clipboard:  Create new environment from clipboard  You will be prompted to choose a save location for your new environment.",
    "link": "/docs/latest/mockoon-data-files/environment-clipboard-copy/",
    "sectionTitle": "Create a new environment from clipboard's data",
    "sectionAnchor": "create-a-new-environment-from-clipboards-data",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/environment-clipboard-copy/#create-a-new-route-from-clipboards-data",
    "title": "Copy data to the clipboard",
    "category": "docs",
    "content": "To create a new route from data present in the clipboard, open the Routes menu and select Add route from clipboard:  Create new route from clipboard  The new route will be added to your active environment's routes.",
    "link": "/docs/latest/mockoon-data-files/environment-clipboard-copy/",
    "sectionTitle": "Create a new route from clipboard's data",
    "sectionAnchor": "create-a-new-route-from-clipboards-data",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/data-storage-location/#locating-the-files",
    "title": "Data storage location",
    "category": "docs",
    "content": "Since v1.16.0, Mockoon is storing each mock API's data in a separate file.  You can locate the folder in which the API data are stored by right-clicking on each environment and selecting \"Show data file in explorer/finder\":  click on show in folder in the context menu",
    "link": "/docs/latest/mockoon-data-files/data-storage-location/",
    "sectionTitle": "Locating the files",
    "sectionAnchor": "locating-the-files",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/data-storage-location/#moving-the-files",
    "title": "Data storage location",
    "category": "docs",
    "content": "You can move the data files to another folder by right-clicking on an environment and selecting \"Move data file to folder\":  click on Move data file to folder in folder in the context menu  Please note that the environment file will be copied to the new folder, and the original file will not be deleted. If you want to delete the original file, you will have to do it manually.",
    "link": "/docs/latest/mockoon-data-files/data-storage-location/",
    "sectionTitle": "Moving the files",
    "sectionAnchor": "moving-the-files",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/data-storage-location/#enabling-data-file-watching",
    "title": "Data storage location",
    "category": "docs",
    "content": "Mockoon can monitor data files' external changes and automatically reload the interface with the new information. This is particularly useful when you are editing the data files with an external editor or pulling changes from a git repository. You can activate this option in the settings:  enable file monitoring in the settings",
    "link": "/docs/latest/mockoon-data-files/data-storage-location/",
    "sectionTitle": "Enabling data file watching",
    "sectionAnchor": "enabling-data-file-watching",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/mockoon-data-files/data-storage-location/#old-system-pre-v1160",
    "title": "Data storage location",
    "category": "docs",
    "content": "Before version 1.16.0, all of your environments were stored in the same environments.json file in the application data folder. The file was located in your operating system's user folder:  Windows: c:/Users/xxx/AppData/Roaming/mockoon/storage Linux: ~/.config/mockoon/storage macOS: ~/Library/Application Support/mockoon/storage  When updating to version 1.16.0, Mockoon automatically migrated the old environments.json file (see below) and split it into as many files as you had environments. These files were created in the same storage folder with incremental names: environment-0.json, environment-1.json, etc.  one file vs multiple files after the migration  ‚ö†Ô∏è The automatic migration was dropped in version 5.0.0. If you are updating from v1.15.0, please first update to any version between v1.16.0 and v4.1.0, then to v5.0.0.",
    "link": "/docs/latest/mockoon-data-files/data-storage-location/",
    "sectionTitle": "Old system (pre v1.16.0)",
    "sectionAnchor": "old-system-pre-v1160",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/logging-and-recording/requests-logging/#accessing-the-logs",
    "title": "Requests logging",
    "category": "docs",
    "content": "For easier debugging, Mockoon records all entering requests and all the corresponding outgoing responses for each of your mock API. To access an environment's log, click on the \"Logs\" tab at the top of the window:  click the logs tab",
    "link": "/docs/latest/logging-and-recording/requests-logging/",
    "sectionTitle": "Accessing the logs",
    "sectionAnchor": "accessing-the-logs",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/logging-and-recording/requests-logging/#logs-content",
    "title": "Requests logging",
    "category": "docs",
    "content": "The list shows all intercepted requests and how Mockoon answered to them. Please note that all requests are intercepted, even the /favicon request made by the browser. Each record contains the entering request and the outgoing response information. This includes the complete list of headers, route params, query params, and body in raw format.  view the request  view the response  The interface is showing truncated bodies for both the request and the response (the truncation length can be adjusted in the settings). You can still view them in full in a separated editor by clicking on View full body in editor:  click on view full body in editor link  body content is showed in a modal",
    "link": "/docs/latest/logging-and-recording/requests-logging/",
    "sectionTitle": "Logs content",
    "sectionAnchor": "logs-content",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/logging-and-recording/requests-logging/#logs-metadata",
    "title": "Requests logging",
    "category": "docs",
    "content": "You can also easily see if a request has been caught by Mockoon (record shows a green tick) or has been passed to another URL if the proxy mode is activated (record shows a shield icon):  view logs metadata",
    "link": "/docs/latest/logging-and-recording/requests-logging/",
    "sectionTitle": "Logs metadata",
    "sectionAnchor": "logs-metadata",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/logging-and-recording/requests-logging/#file-logging",
    "title": "Requests logging",
    "category": "docs",
    "content": "Mockoon records all transactions in the logs file in JSON format:  {   \"app\": \"mockoon-server\",   \"level\": \"info\",   \"message\": \"Transaction recorded\",   \"timestamp\": \"2023-06-29T09:40:01.772Z\"   \"environmentName\": \"Demo API\",   \"environmentUUID\": \"6a5ccd5b-fd28-471a-bbdc-cbbd7ea54157\",   \"requestMethod\": \"GET\",   \"requestPath\": \"/test\",   \"requestProxied\": false,   \"responseStatus\": 200, }  You can also enable full transaction logging in the application settings by checking the \"Log the full transactions\" checkbox in the settings dialog.  When using this option, logs will contain the full transaction (request and response) with the same information you can see in the desktop application \"Logs\" tab:  {   \"app\": \"mockoon-server\",   \"level\": \"info\",   \"message\": \"Transaction recorded\",   \"timestamp\": \"2023-06-29T09:02:09.801Z\",   \"environmentName\": \"Demo API\",   \"environmentUUID\": \"d682bfab-52aa-4ec5-a3a5-853e6d3950cc\",   \"requestMethod\": \"GET\",   \"requestPath\": \"/test\",   \"requestProxied\": false,   \"responseStatus\": 200,   \"transaction\": {     \"proxied\": false,     \"request\": {       \"body\": \"{}\",       \"headers\": [{ \"key\": \"accept\", \"value\": \"*/*\" }],       \"method\": \"GET\",       \"params\": [],       \"query\": \"\",       \"queryParams\": {},       \"route\": \"/test\",       \"urlPath\": \"/test\"     },     \"response\": {       \"body\": \"{}\",       \"headers\": [         { \"key\": \"content-type\", \"value\": \"application/json; charset=utf-8\" }       ],       \"statusCode\": 200,       \"statusMessage\": \"OK\"     },     \"routeResponseUUID\": \"173e37f8-7edd-4ca4-9244-32ca14eeb158\",     \"routeUUID\": \"03a3f8de-7a4e-4dd1-a008-719e6165207c\"   } }  ‚ö†Ô∏è Enabling this option will generate a lot of logs and can quickly fill up your disk space. Use it with caution.    üîè Our logging system will automatically anonymize any credentials present in the Authorization or Proxy-Authorization headers.",
    "link": "/docs/latest/logging-and-recording/requests-logging/",
    "sectionTitle": "File logging",
    "sectionAnchor": "file-logging",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/logging-and-recording/auto-mocking-and-recording/#automatically-create-mock-routes",
    "title": "Auto-mocking and recording",
    "category": "docs",
    "content": "You can automatically create mock routes from HTTP transactions (request/response). This is especially useful when used in pair with the proxy mode to create a mock API from an existing API.",
    "link": "/docs/latest/logging-and-recording/auto-mocking-and-recording/",
    "sectionTitle": "Automatically create mock routes",
    "sectionAnchor": "automatically-create-mock-routes",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/logging-and-recording/auto-mocking-and-recording/#manually-create-a-mock-from-a-request",
    "title": "Auto-mocking and recording",
    "category": "docs",
    "content": "Mockoon offers the possibility to automatically create mocks for entering requests. Click on the \"plus\" icon on a record to create a route containing the same information (headers, body, etc.):  create a route from a log",
    "link": "/docs/latest/logging-and-recording/auto-mocking-and-recording/",
    "sectionTitle": "Manually create a mock from a request",
    "sectionAnchor": "manually-create-a-mock-from-a-request",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/logging-and-recording/auto-mocking-and-recording/#record-your-api-calls",
    "title": "Auto-mocking and recording",
    "category": "docs",
    "content": "Mockoon can also automatically create mock API endpoints every time a request is logged. To activate this feature, click on the \"Record\" button at the top of the logs view:  click on the record button  You can record in multiple environments at the same time. A red blinking recording icon will appear next to the environment name to indicate that the recording is active:  recording icon  The recording will only create a route once, based on the path and HTTP method.  The recording mode works best with the proxy mode enabled and intercepting all the entering requests.",
    "link": "/docs/latest/logging-and-recording/auto-mocking-and-recording/",
    "sectionTitle": "Record your API calls",
    "sectionAnchor": "record-your-api-calls",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/data-buckets/using-data-buckets/#using-data-buckets",
    "title": "Using data buckets",
    "category": "docs",
    "content": "After creating data buckets, you can use them through the data templating helpers or by directly referencing them in a route response.",
    "link": "/docs/latest/data-buckets/using-data-buckets/",
    "sectionTitle": "Using data buckets",
    "sectionAnchor": "using-data-buckets",
    "score": 10,
    "groupScore": 0
  },
  {
    "objectID": "/docs/latest/data-buckets/using-data-buckets/#using-data-helpers",
    "title": "Using data buckets",
    "category": "docs",
    "content": "Two helpers are available: data and dataRaw. They work in a similar way to the body and bodyRaw helpers.  They can be used anywhere templating helpers are supported: body editor, files, headers keys and values, etc., and allow you to partially reuse your data bucket content and compose dynamic responses body easily.  Both helpers support retrieving the data bucket by its unique ID or name. It also allows you to retrieve only part of the data bucket using an optional object path:  {{data 'ID_or_name' 'object.path'}}  Retrieving data at a specific object path requires that the data bucket content is a valid JSON.    Head over to the data helpers' documentation to see more examples.",
    "link": "/docs/latest/data-buckets/using-data-buckets/",
    "sectionTitle": "Using data helpers",
    "sectionAnchor": "using-data-helpers",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/data-buckets/using-data-buckets/#referencing-in-a-route-response",
    "title": "Using data buckets",
    "category": "docs",
    "content": "A data bucket can also be directly linked to a route response. Linking a data bucket will serve the generated data bucket content \"as-is\".  To link a data bucket to a route response, choose \"Data\" in the body selector and select your data bucket.  Using data bucket in a route response",
    "link": "/docs/latest/data-buckets/using-data-buckets/",
    "sectionTitle": "Referencing in a route response",
    "sectionAnchor": "referencing-in-a-route-response",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/data-buckets/overview/#what-are-data-buckets",
    "title": "Overview",
    "category": "docs",
    "content": "In Mockoon, a data bucket is a key value store where you can create reusable content or data for your routes.  The data buckets are defined at the environment level and are generated when the server starts. It means that their state persists between each call (see below).",
    "link": "/docs/latest/data-buckets/overview/",
    "sectionTitle": "What are data buckets?",
    "sectionAnchor": "what-are-data-buckets",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/data-buckets/overview/#create-a-data-bucket",
    "title": "Overview",
    "category": "docs",
    "content": "To create a new data bucket, open the Data options by clicking on the tab at the top of the window:  Open data bucket view  Add a new data bucket by clicking on the \"plus\" button:  Add a data bucket  You can change the data bucket title and content on the right part of the screen. Mockoon will automatically attribute a new unique ID to your data bucket. You can use this ID to reference the data using the data helpers. To retrieve a bucket's unique ID, look in the footer under the data bucket content or right-click on a bucket name in the list and click on \"Copy ID to clipboard\".",
    "link": "/docs/latest/data-buckets/overview/",
    "sectionTitle": "Create a data bucket",
    "sectionAnchor": "create-a-data-bucket",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/data-buckets/overview/#content-of-a-data-bucket",
    "title": "Overview",
    "category": "docs",
    "content": "Data buckets can contain any text content. They also support all of Mockoon's templating helpers including the data and dataRaw helpers.  Mockoon will always try to parse the data bucket's content from JSON to allow you to reference only part of it using the data helpers and an object path.",
    "link": "/docs/latest/data-buckets/overview/",
    "sectionTitle": "Content of a data bucket",
    "sectionAnchor": "content-of-a-data-bucket",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/data-buckets/overview/#combining-data-buckets",
    "title": "Overview",
    "category": "docs",
    "content": "You can easily combine your data bucket contents by referencing other data buckets using the dataRaw helper:  //data bucket content {   \"data\": {     \"id\": \"{{ dataRaw 'other-data-bucket-content' }}\"   } }  ‚ö†Ô∏è However, data buckets are generated in the order they are defined in the environment. As a consequence, you cannot reference a data bucket that is defined after the current one.",
    "link": "/docs/latest/data-buckets/overview/",
    "sectionTitle": "Combining data buckets",
    "sectionAnchor": "combining-data-buckets",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/data-buckets/overview/#data-buckets-generation",
    "title": "Overview",
    "category": "docs",
    "content": "Data buckets are generated when the server starts in the order they are defined in the environment. Their state persist during all mock API calls. To regenerate a data bucket's content, restart the mock server.  If a data bucket contains request helpers, Mockoon will generate the bucket content only after the first call made to a route using this data bucket (by referencing it directly or using a data helper). It allows you to create bucket \"configuration\" routes that you can call programmatically with the content you want to reuse in your bucket using the request helpers (body, queryParams, etc.).",
    "link": "/docs/latest/data-buckets/overview/",
    "sectionTitle": "Data buckets generation",
    "sectionAnchor": "data-buckets-generation",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/api-endpoints/templates-and-ai-assistant/#overview",
    "title": "Templates and AI assistant",
    "category": "docs",
    "content": "Mockoon templates are pieces of JSON, often with templating helpers, that can be used in Mockoon to quickly prototype your mock APIs. They can be used in your HTTP route's body or as data bucket content to create realistic and dynamic data.  Two types of templates are available: pre-generated and AI-generated.",
    "link": "/docs/latest/api-endpoints/templates-and-ai-assistant/",
    "sectionTitle": "Overview",
    "sectionAnchor": "overview",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/api-endpoints/templates-and-ai-assistant/#use-the-pre-generated-templates",
    "title": "Templates and AI assistant",
    "category": "docs",
    "content": "The pre-generated templates can be found in the desktop application.  To use a template in your routes, click on the \"From template\" entry in the route creation menu to open the templates dialog:  modal with templates list  Then, select the template you want to use and either copy-paste its content manually or click on one of the two buttons to create a new GET endpoint or a CRUD endpoint with a data bucket.  create get route from template  The \"GET route\" button will create a new HTTP GET route and copy the template content as the body. The \"CRUD + data\" button will create a new CRUD endpoint with a linked data bucket and copy the template content as the data bucket content.  Some templates are offered for free, while most of them require a subscription to Mockoon Pro. The templates part of the Pro plans are marked with a small yellow corner.",
    "link": "/docs/latest/api-endpoints/templates-and-ai-assistant/",
    "sectionTitle": "Use the pre-generated templates",
    "sectionAnchor": "use-the-pre-generated-templates",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/api-endpoints/templates-and-ai-assistant/#use-the-ai-assistant-to-generate-realistic-data",
    "title": "Templates and AI assistant",
    "category": "docs",
    "content": "You can also use our AI assistant to generate realistic mock data for your various endpoints by providing a custom prompt. This feature is available in the desktop application and is part of the Mockoon Pro plans.  To generate a new template, click the \"From template\" button in the route creation menu (see above), and select the \"Generate\" tab:  AI assistant generate tab  Then, write a prompt (e.g. \"list of users\") and click the \"Generate\" button.  AI assistant generate button click  Finally, you can copy-paste the generated template manually or click on one of the two buttons to create a new GET endpoint or a CRUD endpoint with a data bucket.  create get route from template",
    "link": "/docs/latest/api-endpoints/templates-and-ai-assistant/",
    "sectionTitle": "Use the AI assistant to generate realistic data",
    "sectionAnchor": "use-the-ai-assistant-to-generate-realistic-data",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/api-endpoints/templates-and-ai-assistant/#writing-prompts",
    "title": "Templates and AI assistant",
    "category": "docs",
    "content": "Mockoon AI assistant wraps your prompt with various instructions to help you generate the most relevant template for your needs. It has been optimized for the JSON format but can also generate templates in XML, CSV, etc. Several options are available to fine-tune the generated templates:  JSON: the generated template will be a valid JSON object. array: the generated template root level will be a JSON array (usually used with the JSON option). templating: the generated template will contain Handlebars templating helpers (e.g. {{faker 'person.firstName'}}). Please note that disabling this option usually results in longer templates.  prompt options buttons  You will obtain best results with shorter prompts: \"list of users\", \"JSON configuration for library X\", etc.  If you want more freedom when generating templates (using a different data format, etc.), you can disable the various options. Our system will still manage your prompt to increase the relevance of the generated template.",
    "link": "/docs/latest/api-endpoints/templates-and-ai-assistant/",
    "sectionTitle": "Writing prompts",
    "sectionAnchor": "writing-prompts",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/api-endpoints/templates-and-ai-assistant/#ai-assistant-quota",
    "title": "Templates and AI assistant",
    "category": "docs",
    "content": "Each use of the AI assistant will count as one credit towards your monthly quota. You can check your quota in your account page.",
    "link": "/docs/latest/api-endpoints/templates-and-ai-assistant/",
    "sectionTitle": "AI assistant quota",
    "sectionAnchor": "ai-assistant-quota",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#api-prefix",
    "title": "Routing",
    "category": "docs",
    "content": "In order to prefix all your mock API routes,  Open the Environment Settings by clicking on the tab at the top of the window:  click on the settings tab  Then, fill the API prefix input at the top of the environment Settings:  fill the prefix input  The prefix will appear under your environment name in the environments list. All your environment's routes will now be prefixed and available at the following address http://localhost:port/myprefix/myroute instead of http://localhost:port/myroute.  You need to restart the environment for the change to take effect.",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "API prefix",
    "sectionAnchor": "api-prefix",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#api-routes",
    "title": "Routing",
    "category": "docs",
    "content": "Mockoon uses Express to run the mock servers. In general, most of the Express' documentation applies. Please refer to the routing documentation for more information and examples on the following topics.",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "API routes",
    "sectionAnchor": "api-routes",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#routes-order",
    "title": "Routing",
    "category": "docs",
    "content": "Routes are declared in the server in the order displayed in the application (inside folders or not). This means that the first ones take precedence over the following ones.  One consequence is that a route parameter will capture any value at the specific URL segment. For example, /users/:id or /users/* will intercept /users/search. The more specific \"search\" route should be declared first. You can always reorder routes by dragging and dropping them.",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "Routes order",
    "sectionAnchor": "routes-order",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#route-patterns-and-regexes",
    "title": "Routing",
    "category": "docs",
    "content": "Routes support certain patterns and a subset of regular expressions. Here are some examples of the available ones:  /path/* will match /path/anything. /ab?cd will match /acd and /abcd. /ab+cd will match abcd, abbcd, abbbcd, and so on. /ab(cd)?e will match /abe and /abcde.  route pattern  For a complete overview of the patterns available, please refer to Express' route paths documentation.",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "Route patterns and regexes",
    "sectionAnchor": "route-patterns-and-regexes",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#route-parameters",
    "title": "Routing",
    "category": "docs",
    "content": "Route parameters can be defined in routes by using a colon :. The name of a parameter can only contains the following characters A-Za-z0-9_.  route parameter  For a complete overview on how to use and declare route parameters, please refer to Express' route parameters documentation.  You can also retrieve the route parameters by using the {{urlParam 'paramName'}} templating helper.  To use a colon : in your route path as a normal character, you can escape it by either using double backslashes \\\\ or square brackets []: /part1[:]part2 > /part1\\\\:part2",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "Route parameters",
    "sectionAnchor": "route-parameters",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#query-parameters",
    "title": "Routing",
    "category": "docs",
    "content": "Routes must be declared without query parameters as they are not part of the route path. They can only be added to the request when calling an endpoint.  Query parameters can be retrieved by using the {{queryParam 'paramName'}} templating helper.",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "Query parameters",
    "sectionAnchor": "query-parameters",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/api-endpoints/routing/#query-parameters-arrays-and-objects",
    "title": "Routing",
    "category": "docs",
    "content": "Mockoon is using qs to parse the query string in a object usable in our templating or rules systems. It supports both arrays and objects. To pass arrays and objects in the query string of a request, you must use the following syntax:  for objects: ?param1=test&obj[prop1]=value. for arrays: ?param1=test&array[]=value1&array[]=value2 or ?param1=test&array[0]=value1&array[1]=value2 or ?param1=test&array=value1,value2.",
    "link": "/docs/latest/api-endpoints/routing/",
    "sectionTitle": "Query parameters arrays and objects",
    "sectionAnchor": "query-parameters-arrays-and-objects",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/api-endpoints/folders/#organize-your-endpoints",
    "title": "Folders",
    "category": "docs",
    "content": "You can organize your routes into folders and sub-folders:  routes organized in folders and sub-folders  This new feature allows you to better organize your routes and make your APIs more readable and easier to navigate, with a clearer hierarchy. You can drag and drop to move or reorganize your routes and folders.",
    "link": "/docs/latest/api-endpoints/folders/",
    "sectionTitle": "Organize your endpoints",
    "sectionAnchor": "organize-your-endpoints",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/api-endpoints/folders/#routes-order",
    "title": "Folders",
    "category": "docs",
    "content": "The server will create the endpoints in the same order they appear in the list, should they be inside folders or not. See the routing documentation for more information.",
    "link": "/docs/latest/api-endpoints/folders/",
    "sectionTitle": "Routes order",
    "sectionAnchor": "routes-order",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/api-endpoints/folders/#repairing-the-data-file",
    "title": "Folders",
    "category": "docs",
    "content": "If Mockoon's data file has broken references due to improper manipulation of the JSON, such as missing routes or nonexistent folders, it will automatically be repaired upon loading. If a route or folder does not exist, it will be automatically removed. On the other hand, unlisted routes and folders will be added back to the root level.",
    "link": "/docs/latest/api-endpoints/folders/",
    "sectionTitle": "Repairing the data file",
    "sectionAnchor": "repairing-the-data-file",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#overview",
    "title": "CRUD routes",
    "category": "docs",
    "content": "Where Mockoon routes are independent and stateless, CRUD routes can generate multiple endpoints to perform CRUD operations (Create, Read, Update, Delete) on data buckets. Data buckets are generated when the server start, their state persisting between calls. It makes them the perfect tool to simulate small databases.  A CRUD endpoint will automatically create a series of routes during runtime, allowing you to perform actions on your data bucket. A typical example is an array of resources (users, invoices, etc.) you can update through a PUT request and see the result in a subsequent GET request.  To create a CRUD route, click on the \"CRUD route\" entry in the add route menu:  Add a new CRUD route  Then, set its path, usually a resource name:  Set the CRUD route path  Your path can be more complex, and contains parameters or multiple sections. Remember that this will be the \"prefix\" of the different endpoints (see below).",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Overview",
    "sectionAnchor": "overview",
    "score": 10,
    "groupScore": 1
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#data-bucket-link",
    "title": "CRUD routes",
    "category": "docs",
    "content": "After creating a CRUD endpoint, you need to link it to a data bucket:  Link a data bucket to a CRUD route  Head over to our data buckets documentation to learn how to create a new data bucket.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Data bucket link",
    "sectionAnchor": "data-bucket-link",
    "score": 10,
    "groupScore": 2
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#supported-content",
    "title": "CRUD routes",
    "category": "docs",
    "content": "The CRUD route will work with any content stored in your data bucket: valid JSON in the form of an array of objects, an object, a primitive, etc., or any non-valid JSON. The route behaviors will vary depending on the content stored in the bucket (see table below).",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Supported content",
    "sectionAnchor": "supported-content",
    "score": 10,
    "groupScore": 3
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#resetting-the-data-bucket-content",
    "title": "CRUD routes",
    "category": "docs",
    "content": "The data bucket content is generated when the server starts, and its state persists between calls. However, its state will not be saved in the data file, and you can reset it to its initial state by restarting the mock API.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Resetting the data bucket content",
    "sectionAnchor": "resetting-the-data-bucket-content",
    "score": 10,
    "groupScore": 4
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#crud-route-differences",
    "title": "CRUD routes",
    "category": "docs",
    "content": "When creating a CRUD route, you may notice some differences in the interface, namely:  The route HTTP method cannot be set and will be handled automatically. The status code cannot be changed and will be set automatically while performing operations. A fixed and default route response is automatically created and must be linked to a data bucket in order to perform CRUD operations.  Latency and custom headers can still be added. However, an application/json Content-Type will be forced when appropriate.  Also, CRUD routes are still compatible with creating multiple responses and rules. The major difference is that the default route response cannot be set and will always be the first one linked to the data bucket. This response cannot be deleted nor reordered. Aside from these differences everything else still applies.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "CRUD route differences",
    "sectionAnchor": "crud-route-differences",
    "score": 10,
    "groupScore": 5
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#list-of-routes-and-operations",
    "title": "CRUD routes",
    "category": "docs",
    "content": "Mockoon will automatically translate a CRUD endpoint to multiple routes allowing for a wide range of behaviors. The system is very flexible and allows for any content, storing and updating primitives to simulate a flag or environment variable system, updating and sorting an array of objects, etc.  Array of objects Array of primitives (id parameter is acting like an index) Object, primitive or non-valid JSON GET /resources Returns the entire array * Returns the entire array * Returns the content GET /resources/:id Returns an object by its id property Returns an item by its index Returns the content POST /resources Inserts a new object in the array (autogenerate the id (UUID) if not provided) Inserts a new item in the array Overwrites the content PUT /resources Replaces the whole data bucket content Replaces the whole data bucket content Overwrites the content PUT /resources/:id Performs a full object update by its id (replace) Replaces the item at index Overwrites the content PATCH /resources Concatenates the arrays Concatenates the arrays Overwrites the content (merge if objects) PATCH /resources/:id Performs a partial object update by its id (merge) Replaces the item at index Overwrites the content (merge if objects) DELETE /resources Deletes the data bucket content Deletes the data bucket content Deletes the content DELETE /resources/:id Deletes an object by its id Deletes an item at index Deletes the content  * Supports sorting and pagination  ‚ö†Ô∏è Note: You can expect the above results assuming that you are sending the same type of content as the one stored in the data bucket (array ‚Üî array, object ‚Üî object, etc.). However, the system is very permissive, and you may push any content in an array, ending up with mixed type contents or replacing content with data of a different type.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "List of routes and operations",
    "sectionAnchor": "list-of-routes-and-operations",
    "score": 10,
    "groupScore": 6
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#customizing-the-id-property",
    "title": "CRUD routes",
    "category": "docs",
    "content": "By default, CRUD endpoints will use the id property to identify objects in an array in all the routes manipulating a single resource (e.g. GET /resource/:id). However, you can change this property to anything you want, like uuid, custom_id, etc:  Customize the CRUD id property",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Customizing the \"id\" property",
    "sectionAnchor": "customizing-the-id-property",
    "score": 10,
    "groupScore": 7
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#overriding-a-route",
    "title": "CRUD routes",
    "category": "docs",
    "content": "You can easily override a CRUD operation route by declaring a regular HTTP route and putting it above the CRUD route (see routes order). This route will intercept the request allowing you to serve custom content for this operation.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Overriding a route",
    "sectionAnchor": "overriding-a-route",
    "score": 10,
    "groupScore": 8
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#sorting-and-pagination-on-the-main-get-route",
    "title": "CRUD routes",
    "category": "docs",
    "content": "The main GET /path route supports sorting and pagination when working with an array.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Sorting and pagination on the main GET route",
    "sectionAnchor": "sorting-and-pagination-on-the-main-get-route",
    "score": 10,
    "groupScore": 9
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#sorting",
    "title": "CRUD routes",
    "category": "docs",
    "content": "To sort an array, you can use the sort and order query parameters. You can sort by any property in the objects (strings or numbers) and order by either ascending or descending order:  GET /path?sort=name&order=desc  Sorting is also working on arrays of primitives (strings, numbers, etc.), in which case, the presence of the sort parameter is enough:  GET /path?sort&order=asc",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Sorting",
    "sectionAnchor": "sorting",
    "score": 10,
    "groupScore": 10
  },
  {
    "objectID": "/docs/latest/api-endpoints/crud-routes/#pagination",
    "title": "CRUD routes",
    "category": "docs",
    "content": "To paginate an array, you can use the page and limit query parameters. If you omit the limit parameter, it will default to 10 per page. If you omit the page parameter, it will show you the first x items.  Examples:  second set of 25 items:  GET /path?page=2&limit=25   first 50 items:  GET /path?limit=50   second set of 10 items:  GET /path?page=2  Pagination will be applied after sorting, both can be cumulated:  GET /path?sort=name&page=2&limit=25  When using pagination, a X-Total-Count header will be present in the response with the total number of items.",
    "link": "/docs/latest/api-endpoints/crud-routes/",
    "sectionTitle": "Pagination",
    "sectionAnchor": "pagination",
    "score": 10,
    "groupScore": 11
  }
]
